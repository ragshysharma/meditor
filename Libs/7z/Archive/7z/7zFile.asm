; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	H:\MinGW\home\other\meditor2\Libs\7z\7zFile.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_File_Construct
; Function compile flags: /Ogtp
; File h:\mingw\home\other\meditor2\libs\7z\7zfile.c
;	COMDAT _File_Construct
_TEXT	SEGMENT
_p$ = 8							; size = 4
_File_Construct PROC					; COMDAT

; 29   : {

	push	ebp
	mov	ebp, esp

; 30   :   #ifdef USE_WINDOWS_FILE
; 31   :   p->handle = INVALID_HANDLE_VALUE;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], -1

; 32   :   #else
; 33   :   p->file = NULL;
; 34   :   #endif
; 35   : }

	pop	ebp
	ret	0
_File_Construct ENDP
_TEXT	ENDS
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__CreateFileA@28:PROC
; Function compile flags: /Ogtp
;	COMDAT _File_Open
_TEXT	SEGMENT
_p$ = 8							; size = 4
_File_Open PROC						; COMDAT
; _name$ = edx
; _writeMode$ = eax

; 38   : {

	push	ebp
	mov	ebp, esp

; 39   :   #ifdef USE_WINDOWS_FILE
; 40   :   p->handle = CreateFileA(name,
; 41   :       writeMode ? GENERIC_WRITE : GENERIC_READ,
; 42   :       FILE_SHARE_READ, NULL,
; 43   :       writeMode ? CREATE_ALWAYS : OPEN_EXISTING,
; 44   :       FILE_ATTRIBUTE_NORMAL, NULL);

	mov	ecx, eax
	push	0
	neg	ecx
	sbb	ecx, ecx
	push	128					; 00000080H
	add	ecx, 3
	neg	eax
	push	ecx
	sbb	eax, eax
	push	0
	and	eax, -1073741824			; c0000000H
	push	1
	add	eax, -2147483648			; 80000000H
	push	eax
	push	edx
	call	DWORD PTR __imp__CreateFileA@28
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], eax

; 45   :   return (p->handle != INVALID_HANDLE_VALUE) ? 0 : GetLastError();

	cmp	eax, -1
	je	SHORT $LN3@File_Open
	xor	eax, eax

; 46   :   #else
; 47   :   p->file = fopen(name, writeMode ? "wb+" : "rb");
; 48   :   return (p->file != 0) ? 0 : errno;
; 49   :   #endif
; 50   : }

	pop	ebp
	ret	0
$LN3@File_Open:
	pop	ebp

; 45   :   return (p->handle != INVALID_HANDLE_VALUE) ? 0 : GetLastError();

	jmp	DWORD PTR __imp__GetLastError@0
_File_Open ENDP
_TEXT	ENDS
PUBLIC	_InFile_Open
; Function compile flags: /Ogtp
;	COMDAT _InFile_Open
_TEXT	SEGMENT
_p$ = 8							; size = 4
_name$ = 12						; size = 4
_InFile_Open PROC					; COMDAT

; 52   : WRes InFile_Open(CSzFile *p, const char *name) { return File_Open(p, name, 0); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _name$[ebp]
	push	eax
	xor	eax, eax
	call	_File_Open
	add	esp, 4
	pop	ebp
	ret	0
_InFile_Open ENDP
_TEXT	ENDS
PUBLIC	_OutFile_Open
; Function compile flags: /Ogtp
;	COMDAT _OutFile_Open
_TEXT	SEGMENT
_p$ = 8							; size = 4
_name$ = 12						; size = 4
_OutFile_Open PROC					; COMDAT

; 53   : WRes OutFile_Open(CSzFile *p, const char *name) { return File_Open(p, name, 1); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _name$[ebp]
	push	eax
	mov	eax, 1
	call	_File_Open
	add	esp, 4
	pop	ebp
	ret	0
_OutFile_Open ENDP
_TEXT	ENDS
PUBLIC	_File_Close
EXTRN	__imp__CloseHandle@4:PROC
; Function compile flags: /Ogtp
;	COMDAT _File_Close
_TEXT	SEGMENT
_p$ = 8							; size = 4
_File_Close PROC					; COMDAT

; 56   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 57   :   #ifdef USE_WINDOWS_FILE
; 58   :   if (p->handle != INVALID_HANDLE_VALUE)

	mov	esi, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [esi]
	cmp	eax, -1
	je	SHORT $LN2@File_Close

; 59   :   {
; 60   :     if (!CloseHandle(p->handle))

	push	eax
	call	DWORD PTR __imp__CloseHandle@4
	test	eax, eax
	jne	SHORT $LN1@File_Close
	pop	esi

; 74   : }

	pop	ebp

; 61   :       return GetLastError();

	jmp	DWORD PTR __imp__GetLastError@0
$LN1@File_Close:

; 62   :     p->handle = INVALID_HANDLE_VALUE;

	mov	DWORD PTR [esi], -1
$LN2@File_Close:

; 63   :   }
; 64   :   #else
; 65   :   if (p->file != NULL)
; 66   :   {
; 67   :     int res = fclose(p->file);
; 68   :     if (res != 0)
; 69   :       return res;
; 70   :     p->file = NULL;
; 71   :   }
; 72   :   #endif
; 73   :   return 0;

	xor	eax, eax
	pop	esi

; 74   : }

	pop	ebp
	ret	0
_File_Close ENDP
_TEXT	ENDS
PUBLIC	_File_Read
EXTRN	__imp__ReadFile@20:PROC
; Function compile flags: /Ogtp
;	COMDAT _File_Read
_TEXT	SEGMENT
_p$ = 8							; size = 4
_data$ = 12						; size = 4
_processed$79982 = 16					; size = 4
_size$ = 16						; size = 4
_File_Read PROC						; COMDAT

; 77   : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 78   :   size_t originalSize = *size;

	mov	edi, DWORD PTR _size$[ebp]
	mov	esi, DWORD PTR [edi]

; 79   :   if (originalSize == 0)

	test	esi, esi

; 80   :     return 0;

	je	SHORT $LN16@File_Read

; 81   : 
; 82   :   #ifdef USE_WINDOWS_FILE
; 83   : 
; 84   :   *size = 0;

	push	ebx
	mov	ebx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edi], 0
	npad	8
$LL5@File_Read:

; 85   :   do
; 86   :   {
; 87   :     DWORD curSize = (originalSize > kChunkSizeMax) ? kChunkSizeMax : (DWORD)originalSize;

	mov	eax, 4194304				; 00400000H
	cmp	esi, 4194304				; 00400000H
	ja	SHORT $LN10@File_Read
	mov	eax, esi
$LN10@File_Read:

; 88   :     DWORD processed = 0;
; 89   :     BOOL res = ReadFile(p->handle, data, curSize, &processed, NULL);

	mov	edx, DWORD PTR _p$[ebp]
	push	0
	lea	ecx, DWORD PTR _processed$79982[ebp]
	push	ecx
	push	eax
	mov	eax, DWORD PTR [edx]
	push	ebx
	push	eax
	mov	DWORD PTR _processed$79982[ebp], 0
	call	DWORD PTR __imp__ReadFile@20

; 90   :     data = (void *)((Byte *)data + processed);

	mov	ecx, DWORD PTR _processed$79982[ebp]

; 91   :     originalSize -= processed;
; 92   :     *size += processed;

	add	DWORD PTR [edi], ecx
	add	ebx, ecx
	sub	esi, ecx

; 93   :     if (!res)

	test	eax, eax
	je	SHORT $LN12@File_Read

; 95   :     if (processed == 0)

	test	ecx, ecx
	je	SHORT $LN3@File_Read

; 96   :       break;
; 97   :   }
; 98   :   while (originalSize > 0);

	test	esi, esi
	jne	SHORT $LL5@File_Read
$LN3@File_Read:
	pop	ebx
$LN16@File_Read:
	pop	edi

; 99   :   return 0;

	xor	eax, eax
	pop	esi

; 100  : 
; 101  :   #else
; 102  :   
; 103  :   *size = fread(data, 1, originalSize, p->file);
; 104  :   if (*size == originalSize)
; 105  :     return 0;
; 106  :   return ferror(p->file);
; 107  :   
; 108  :   #endif
; 109  : }

	pop	ebp
	ret	0
$LN12@File_Read:
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 94   :       return GetLastError();

	jmp	DWORD PTR __imp__GetLastError@0
_File_Read ENDP
_TEXT	ENDS
PUBLIC	_File_Write
EXTRN	__imp__WriteFile@20:PROC
; Function compile flags: /Ogtp
;	COMDAT _File_Write
_TEXT	SEGMENT
_p$ = 8							; size = 4
_data$ = 12						; size = 4
_processed$80003 = 16					; size = 4
_size$ = 16						; size = 4
_File_Write PROC					; COMDAT

; 112  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 113  :   size_t originalSize = *size;

	mov	edi, DWORD PTR _size$[ebp]
	mov	esi, DWORD PTR [edi]

; 114  :   if (originalSize == 0)

	test	esi, esi

; 115  :     return 0;

	je	SHORT $LN16@File_Write

; 116  :   
; 117  :   #ifdef USE_WINDOWS_FILE
; 118  : 
; 119  :   *size = 0;

	push	ebx
	mov	ebx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edi], 0
	npad	8
$LL5@File_Write:

; 120  :   do
; 121  :   {
; 122  :     DWORD curSize = (originalSize > kChunkSizeMax) ? kChunkSizeMax : (DWORD)originalSize;

	mov	eax, 4194304				; 00400000H
	cmp	esi, 4194304				; 00400000H
	ja	SHORT $LN10@File_Write
	mov	eax, esi
$LN10@File_Write:

; 123  :     DWORD processed = 0;
; 124  :     BOOL res = WriteFile(p->handle, data, curSize, &processed, NULL);

	mov	edx, DWORD PTR _p$[ebp]
	push	0
	lea	ecx, DWORD PTR _processed$80003[ebp]
	push	ecx
	push	eax
	mov	eax, DWORD PTR [edx]
	push	ebx
	push	eax
	mov	DWORD PTR _processed$80003[ebp], 0
	call	DWORD PTR __imp__WriteFile@20

; 125  :     data = (void *)((Byte *)data + processed);

	mov	ecx, DWORD PTR _processed$80003[ebp]

; 126  :     originalSize -= processed;
; 127  :     *size += processed;

	add	DWORD PTR [edi], ecx
	add	ebx, ecx
	sub	esi, ecx

; 128  :     if (!res)

	test	eax, eax
	je	SHORT $LN12@File_Write

; 130  :     if (processed == 0)

	test	ecx, ecx
	je	SHORT $LN3@File_Write

; 131  :       break;
; 132  :   }
; 133  :   while (originalSize > 0);

	test	esi, esi
	jne	SHORT $LL5@File_Write
$LN3@File_Write:
	pop	ebx
$LN16@File_Write:
	pop	edi

; 134  :   return 0;

	xor	eax, eax
	pop	esi

; 135  : 
; 136  :   #else
; 137  : 
; 138  :   *size = fwrite(data, 1, originalSize, p->file);
; 139  :   if (*size == originalSize)
; 140  :     return 0;
; 141  :   return ferror(p->file);
; 142  :   
; 143  :   #endif
; 144  : }

	pop	ebp
	ret	0
$LN12@File_Write:
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 129  :       return GetLastError();

	jmp	DWORD PTR __imp__GetLastError@0
_File_Write ENDP
_TEXT	ENDS
PUBLIC	_File_Seek
EXTRN	__imp__SetFilePointer@16:PROC
EXTRN	__aullshr:PROC
; Function compile flags: /Ogtp
;	COMDAT _File_Seek
_TEXT	SEGMENT
_value$ = -8						; size = 8
_p$ = 8							; size = 4
_pos$ = 12						; size = 4
_origin$ = 16						; size = 4
_File_Seek PROC						; COMDAT

; 147  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 148  :   #ifdef USE_WINDOWS_FILE
; 149  : 
; 150  :   LARGE_INTEGER value;
; 151  :   DWORD moveMethod;
; 152  :   value.LowPart = (DWORD)*pos;

	mov	esi, DWORD PTR _pos$[ebp]

; 153  :   value.HighPart = (LONG)((UInt64)*pos >> 16 >> 16); /* for case when UInt64 is 32-bit only */

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	eax, edi
	mov	cl, 32					; 00000020H
	mov	DWORD PTR _value$[ebp], edi
	call	__aullshr
	mov	DWORD PTR _value$[ebp+4], eax

; 154  :   switch (origin)

	mov	eax, DWORD PTR _origin$[ebp]
	sub	eax, 0
	je	SHORT $LN6@File_Seek
	dec	eax
	je	SHORT $LN5@File_Seek
	dec	eax
	je	SHORT $LN4@File_Seek

; 159  :     default: return ERROR_INVALID_PARAMETER;

	pop	edi
	mov	eax, 87					; 00000057H
	pop	esi

; 170  : 
; 171  :   #else
; 172  :   
; 173  :   int moveMethod;
; 174  :   int res;
; 175  :   switch (origin)
; 176  :   {
; 177  :     case SZ_SEEK_SET: moveMethod = SEEK_SET; break;
; 178  :     case SZ_SEEK_CUR: moveMethod = SEEK_CUR; break;
; 179  :     case SZ_SEEK_END: moveMethod = SEEK_END; break;
; 180  :     default: return 1;
; 181  :   }
; 182  :   res = fseek(p->file, (long)*pos, moveMethod);
; 183  :   *pos = ftell(p->file);
; 184  :   return res;
; 185  :   
; 186  :   #endif
; 187  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@File_Seek:

; 158  :     case SZ_SEEK_END: moveMethod = FILE_END; break;

	mov	eax, 2
	jmp	SHORT $LN7@File_Seek
$LN5@File_Seek:

; 157  :     case SZ_SEEK_CUR: moveMethod = FILE_CURRENT; break;

	mov	eax, 1
	jmp	SHORT $LN7@File_Seek
$LN6@File_Seek:

; 155  :   {
; 156  :     case SZ_SEEK_SET: moveMethod = FILE_BEGIN; break;

	xor	eax, eax
$LN7@File_Seek:

; 160  :   }
; 161  :   value.LowPart = SetFilePointer(p->handle, value.LowPart, &value.HighPart, moveMethod);

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	eax
	lea	eax, DWORD PTR _value$[ebp+4]
	push	eax
	push	edi
	push	edx
	call	DWORD PTR __imp__SetFilePointer@16
	mov	ecx, eax
	mov	DWORD PTR _value$[ebp], ecx

; 162  :   if (value.LowPart == 0xFFFFFFFF)

	cmp	ecx, -1
	jne	SHORT $LN1@File_Seek

; 163  :   {
; 164  :     WRes res = GetLastError();

	call	DWORD PTR __imp__GetLastError@0

; 165  :     if (res != NO_ERROR)

	test	eax, eax

; 166  :       return res;

	jne	SHORT $LN9@File_Seek
	mov	ecx, DWORD PTR _value$[ebp]
$LN1@File_Seek:

; 167  :   }
; 168  :   *pos = ((Int64)value.HighPart << 32) | value.LowPart;

	mov	eax, DWORD PTR _value$[ebp+4]
	cdq
	xor	edi, edi
	xor	edx, edx
	or	eax, edi
	or	edx, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], edx

; 169  :   return 0;

	xor	eax, eax
$LN9@File_Seek:
	pop	edi
	pop	esi

; 170  : 
; 171  :   #else
; 172  :   
; 173  :   int moveMethod;
; 174  :   int res;
; 175  :   switch (origin)
; 176  :   {
; 177  :     case SZ_SEEK_SET: moveMethod = SEEK_SET; break;
; 178  :     case SZ_SEEK_CUR: moveMethod = SEEK_CUR; break;
; 179  :     case SZ_SEEK_END: moveMethod = SEEK_END; break;
; 180  :     default: return 1;
; 181  :   }
; 182  :   res = fseek(p->file, (long)*pos, moveMethod);
; 183  :   *pos = ftell(p->file);
; 184  :   return res;
; 185  :   
; 186  :   #endif
; 187  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_File_Seek ENDP
_TEXT	ENDS
PUBLIC	_File_GetLength
EXTRN	__imp__GetFileSize@8:PROC
; Function compile flags: /Ogtp
;	COMDAT _File_GetLength
_TEXT	SEGMENT
_sizeHigh$ = -4						; size = 4
_p$ = 8							; size = 4
_length$ = 12						; size = 4
_File_GetLength PROC					; COMDAT

; 190  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 191  :   #ifdef USE_WINDOWS_FILE
; 192  :   
; 193  :   DWORD sizeHigh;
; 194  :   DWORD sizeLow = GetFileSize(p->handle, &sizeHigh);

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	esi
	lea	eax, DWORD PTR _sizeHigh$[ebp]
	push	eax
	push	edx
	call	DWORD PTR __imp__GetFileSize@8
	mov	esi, eax

; 195  :   if (sizeLow == 0xFFFFFFFF)

	cmp	esi, -1
	jne	SHORT $LN1@File_GetLe

; 196  :   {
; 197  :     DWORD res = GetLastError();

	call	DWORD PTR __imp__GetLastError@0

; 198  :     if (res != NO_ERROR)

	test	eax, eax

; 199  :       return res;

	jne	SHORT $LN3@File_GetLe
$LN1@File_GetLe:

; 200  :   }
; 201  :   *length = (((UInt64)sizeHigh) << 32) + sizeLow;

	mov	edx, DWORD PTR _sizeHigh$[ebp]
	xor	eax, eax
	xor	ecx, ecx
	add	ecx, esi
	adc	edx, eax
	mov	eax, DWORD PTR _length$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 202  :   return 0;

	xor	eax, eax
$LN3@File_GetLe:
	pop	esi

; 203  :   
; 204  :   #else
; 205  :   
; 206  :   long pos = ftell(p->file);
; 207  :   int res = fseek(p->file, 0, SEEK_END);
; 208  :   *length = ftell(p->file);
; 209  :   fseek(p->file, pos, SEEK_SET);
; 210  :   return res;
; 211  :   
; 212  :   #endif
; 213  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_File_GetLength ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _FileSeqInStream_Read
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_buf$ = 12						; size = 4
_size$ = 16						; size = 4
_FileSeqInStream_Read PROC				; COMDAT

; 219  : {

	push	ebp
	mov	ebp, esp

; 220  :   CFileSeqInStream *p = (CFileSeqInStream *)pp;
; 221  :   return File_Read(&p->file, buf, size) == 0 ? SZ_OK : SZ_ERROR_READ;

	mov	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _pp$[ebp]
	push	eax
	push	ecx
	add	edx, 4
	push	edx
	call	_File_Read
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	and	eax, 8

; 222  : }

	pop	ebp
	ret	0
_FileSeqInStream_Read ENDP
_TEXT	ENDS
PUBLIC	_FileSeqInStream_CreateVTable
; Function compile flags: /Ogtp
;	COMDAT _FileSeqInStream_CreateVTable
_TEXT	SEGMENT
_p$ = 8							; size = 4
_FileSeqInStream_CreateVTable PROC			; COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp

; 226  :   p->s.Read = FileSeqInStream_Read;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET _FileSeqInStream_Read

; 227  : }

	pop	ebp
	ret	0
_FileSeqInStream_CreateVTable ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _FileInStream_Read
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_buf$ = 12						; size = 4
_size$ = 16						; size = 4
_FileInStream_Read PROC					; COMDAT

; 233  : {

	push	ebp
	mov	ebp, esp

; 234  :   CFileInStream *p = (CFileInStream *)pp;
; 235  :   return (File_Read(&p->file, buf, size) == 0) ? SZ_OK : SZ_ERROR_READ;

	mov	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _pp$[ebp]
	push	eax
	push	ecx
	add	edx, 8
	push	edx
	call	_File_Read
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	and	eax, 8

; 236  : }

	pop	ebp
	ret	0
_FileInStream_Read ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _FileInStream_Seek
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_pos$ = 12						; size = 4
_origin$ = 16						; size = 4
_FileInStream_Seek PROC					; COMDAT

; 239  : {

	push	ebp
	mov	ebp, esp

; 240  :   CFileInStream *p = (CFileInStream *)pp;
; 241  :   return File_Seek(&p->file, pos, origin);

	mov	eax, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR _pp$[ebp]
	push	eax
	push	ecx
	add	edx, 8
	push	edx
	call	_File_Seek
	add	esp, 12					; 0000000cH

; 242  : }

	pop	ebp
	ret	0
_FileInStream_Seek ENDP
_TEXT	ENDS
PUBLIC	_FileInStream_CreateVTable
; Function compile flags: /Ogtp
;	COMDAT _FileInStream_CreateVTable
_TEXT	SEGMENT
_p$ = 8							; size = 4
_FileInStream_CreateVTable PROC				; COMDAT

; 245  : {

	push	ebp
	mov	ebp, esp

; 246  :   p->s.Read = FileInStream_Read;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET _FileInStream_Read

; 247  :   p->s.Seek = FileInStream_Seek;

	mov	DWORD PTR [eax+4], OFFSET _FileInStream_Seek

; 248  : }

	pop	ebp
	ret	0
_FileInStream_CreateVTable ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _FileOutStream_Write
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_data$ = 12						; size = 4
_size$ = 16						; size = 4
_FileOutStream_Write PROC				; COMDAT

; 254  : {

	push	ebp
	mov	ebp, esp

; 255  :   CFileOutStream *p = (CFileOutStream *)pp;
; 256  :   File_Write(&p->file, data, &size);

	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR _pp$[ebp]
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	push	ecx
	add	edx, 4
	push	edx
	call	_File_Write

; 257  :   return size;

	mov	eax, DWORD PTR _size$[ebp]
	add	esp, 12					; 0000000cH

; 258  : }

	pop	ebp
	ret	0
_FileOutStream_Write ENDP
_TEXT	ENDS
PUBLIC	_FileOutStream_CreateVTable
; Function compile flags: /Ogtp
;	COMDAT _FileOutStream_CreateVTable
_TEXT	SEGMENT
_p$ = 8							; size = 4
_FileOutStream_CreateVTable PROC			; COMDAT

; 261  : {

	push	ebp
	mov	ebp, esp

; 262  :   p->s.Write = FileOutStream_Write;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET _FileOutStream_Write

; 263  : }

	pop	ebp
	ret	0
_FileOutStream_CreateVTable ENDP
_TEXT	ENDS
END
