; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	H:\MinGW\home\other\meditor2\Libs\7z\LzmaDec.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_kLiteralNextStates DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	04H
	DB	05H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
; Function compile flags: /Ogtp
; File h:\mingw\home\other\meditor2\libs\7z\lzmadec.c
CONST	ENDS
;	COMDAT @LzmaDec_DecodeReal@12
_TEXT	SEGMENT
_pbMask$ = -80						; size = 4
tv1447 = -76						; size = 4
_lim$80217 = -76					; size = 4
_matchByte$80042 = -76					; size = 4
_bound$80021 = -76					; size = 4
_lpMask$ = -72						; size = 4
_numDirectBits$80154 = -68				; size = 4
_probLit$80048 = -68					; size = 4
_lc$ = -64						; size = 4
_checkDicSize$ = -60					; size = 4
_mask$80157 = -56					; size = 4
_rep3$ = -56						; size = 4
_dic$ = -52						; size = 4
tv1823 = -48						; size = 4
_i$80176 = -48						; size = 4
_probLen$80091 = -48					; size = 4
_offs$80043 = -48					; size = 4
_posState$80023 = -48					; size = 4
_rep2$ = -44						; size = 4
_rep1$ = -40						; size = 4
_limit$80089 = -36					; size = 4
_len$ = -36						; size = 4
_dicBufSize$ = -32					; size = 4
_probs$ = -28						; size = 4
_rep0$ = -24						; size = 4
_curLen$80209 = -20					; size = 4
_dicPos$ = -20						; size = 4
_state$ = -16						; size = 4
_processedPos$ = -12					; size = 4
_offset$80090 = -8					; size = 4
_prob$80020 = -8					; size = 4
_buf$ = -4						; size = 4
_p$ = 8							; size = 4
_limit$ = 12						; size = 4
_bufLimit$ = 16						; size = 4
@LzmaDec_DecodeReal@12 PROC				; COMDAT

; 138  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _p$[ebp]

; 139  :   CLzmaProb *probs = p->probs;
; 140  : 
; 141  :   unsigned state = p->state;
; 142  :   UInt32 rep0 = p->reps[0], rep1 = p->reps[1], rep2 = p->reps[2], rep3 = p->reps[3];

	mov	ecx, DWORD PTR [edi+56]
	mov	eax, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [edi+60]
	mov	DWORD PTR _probs$[ebp], eax
	mov	eax, DWORD PTR [edi+64]
	mov	ebx, DWORD PTR [edi+52]
	mov	DWORD PTR _rep0$[ebp], ecx
	mov	ecx, DWORD PTR [edi+68]

; 143  :   unsigned pbMask = ((unsigned)1 << (p->prop.pb)) - 1;
; 144  :   unsigned lpMask = ((unsigned)1 << (p->prop.lp)) - 1;
; 145  :   unsigned lc = p->prop.lc;
; 146  : 
; 147  :   Byte *dic = p->dic;
; 148  :   SizeT dicBufSize = p->dicBufSize;
; 149  :   SizeT dicPos = p->dicPos;
; 150  :   
; 151  :   UInt32 processedPos = p->processedPos;
; 152  :   UInt32 checkDicSize = p->checkDicSize;
; 153  :   unsigned len = 0;
; 154  : 
; 155  :   const Byte *buf = p->buf;
; 156  :   UInt32 range = p->range;
; 157  :   UInt32 code = p->code;

	mov	esi, DWORD PTR [edi+32]
	mov	DWORD PTR _rep2$[ebp], eax
	mov	DWORD PTR _rep3$[ebp], ecx
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR _rep1$[ebp], edx
	mov	edx, 1
	shl	edx, cl
	mov	ecx, DWORD PTR [edi+4]
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR [edi+20]
	dec	edx
	mov	DWORD PTR _dic$[ebp], ecx
	mov	ecx, DWORD PTR [edi+36]
	dec	eax
	mov	DWORD PTR _lpMask$[ebp], eax
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR _lc$[ebp], eax
	mov	eax, DWORD PTR [edi+40]
	mov	DWORD PTR _dicBufSize$[ebp], eax
	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR _processedPos$[ebp], eax
	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR _dicPos$[ebp], ecx
	mov	ecx, DWORD PTR [edi+48]
	mov	DWORD PTR _buf$[ebp], eax
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR _state$[ebp], ebx
	mov	DWORD PTR _pbMask$[ebp], edx
	mov	DWORD PTR _checkDicSize$[ebp], ecx
	mov	DWORD PTR _len$[ebp], 0
$LL110@:

; 158  : 
; 159  :   do
; 160  :   {
; 161  :     CLzmaProb *prob;
; 162  :     UInt32 bound;
; 163  :     unsigned ttt;
; 164  :     unsigned posState = processedPos & pbMask;

	mov	ecx, DWORD PTR _processedPos$[ebp]
	and	ecx, edx

; 165  : 
; 166  :     prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;

	mov	edx, ebx
	shl	edx, 4
	add	edx, ecx
	mov	DWORD PTR _posState$80023[ebp], ecx
	mov	ecx, DWORD PTR _probs$[ebp]
	lea	ecx, DWORD PTR [ecx+edx*2]
	mov	DWORD PTR _prob$80020[ebp], ecx

; 167  :     IF_BIT_0(prob)

	movzx	ecx, WORD PTR [ecx]
	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN107@
	mov	edx, DWORD PTR _buf$[ebp]
	movzx	edx, BYTE PTR [edx]
	shl	esi, 8
	shl	eax, 8
	or	esi, edx
	inc	DWORD PTR _buf$[ebp]
$LN107@:
	mov	edx, eax
	shr	edx, 11					; 0000000bH
	imul	edx, ecx
	cmp	esi, edx
	jae	$LN106@

; 168  :     {
; 169  :       unsigned symbol;
; 170  :       UPDATE_0(prob);

	mov	eax, edx
	mov	edx, 2048				; 00000800H
	sub	edx, ecx
	shr	edx, 5
	add	edx, ecx
	mov	ecx, DWORD PTR _prob$80020[ebp]
	mov	WORD PTR [ecx], dx

; 171  :       prob = probs + Literal;

	mov	edx, DWORD PTR _probs$[ebp]
	add	edx, 3692				; 00000e6cH

; 172  :       if (checkDicSize != 0 || processedPos != 0)

	cmp	DWORD PTR _checkDicSize$[ebp], 0
	mov	DWORD PTR _prob$80020[ebp], edx
	jne	SHORT $LN137@
	cmp	DWORD PTR _processedPos$[ebp], 0
	je	SHORT $LN138@
$LN137@:

; 173  :         prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc) +
; 174  :         (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));

	mov	ecx, DWORD PTR _dicPos$[ebp]
	test	ecx, ecx
	jne	SHORT $LN113@
	mov	ecx, DWORD PTR _dicBufSize$[ebp]
$LN113@:
	mov	edx, DWORD PTR _dic$[ebp]
	movzx	edx, BYTE PTR [ecx+edx-1]
	mov	ebx, DWORD PTR _processedPos$[ebp]
	and	ebx, DWORD PTR _lpMask$[ebp]
	mov	ecx, 8
	sub	cl, BYTE PTR _lc$[ebp]
	shr	edx, cl
	mov	ecx, DWORD PTR _lc$[ebp]
	shl	ebx, cl
	add	edx, ebx
	mov	ebx, DWORD PTR _state$[ebp]
	imul	edx, 1536				; 00000600H
	add	DWORD PTR _prob$80020[ebp], edx
$LN138@:

; 175  : 
; 176  :       if (state < kNumLitStates)

	cmp	ebx, 7
	jae	SHORT $LN103@

; 177  :       {
; 178  :         symbol = 1;

	mov	ebx, DWORD PTR _prob$80020[ebp]
	mov	ecx, 1
$LL102@:

; 179  :         do { GET_BIT(prob + symbol, symbol) } while (symbol < 0x100);

	movzx	edx, WORD PTR [ebx+ecx*2]
	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN99@
	mov	edi, DWORD PTR _buf$[ebp]
	movzx	edi, BYTE PTR [edi]
	shl	esi, 8
	shl	eax, 8
	or	esi, edi
	inc	DWORD PTR _buf$[ebp]
$LN99@:
	mov	edi, eax
	shr	edi, 11					; 0000000bH
	imul	edi, edx
	cmp	esi, edi
	jae	SHORT $LN98@
	mov	eax, edi
	mov	edi, 2048				; 00000800H
	sub	edi, edx
	shr	edi, 5
	add	edi, edx
	mov	WORD PTR [ebx+ecx*2], di
	add	ecx, ecx
	jmp	SHORT $LN101@
$LN98@:
	sub	eax, edi
	sub	esi, edi
	mov	edi, edx
	shr	edi, 5
	sub	edx, edi
	mov	WORD PTR [ebx+ecx*2], dx
	lea	ecx, DWORD PTR [ecx+ecx+1]
$LN101@:
	cmp	ecx, 256				; 00000100H
	jb	SHORT $LL102@

; 180  :       }
; 181  :       else

	jmp	$LN93@
$LN103@:

; 182  :       {
; 183  :         unsigned matchByte = p->dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];

	mov	ecx, DWORD PTR _dicPos$[ebp]
	mov	edx, DWORD PTR _rep0$[ebp]
	cmp	ecx, edx
	sbb	ebx, ebx
	and	ebx, DWORD PTR _dicBufSize$[ebp]

; 184  :         unsigned offs = 0x100;

	mov	DWORD PTR _offs$80043[ebp], 256		; 00000100H
	sub	ebx, edx
	add	ebx, DWORD PTR [edi+20]
	movzx	edi, BYTE PTR [ebx+ecx]

; 185  :         symbol = 1;

	mov	ecx, 1
	jmp	SHORT $LN95@
$LL133@:
	mov	edi, DWORD PTR _matchByte$80042[ebp]
$LN95@:

; 186  :         do
; 187  :         {
; 188  :           unsigned bit;
; 189  :           CLzmaProb *probLit;
; 190  :           matchByte <<= 1;
; 191  :           bit = (matchByte & offs);

	mov	ebx, DWORD PTR _offs$80043[ebp]
	add	edi, edi
	mov	edx, ebx
	and	edx, edi
	mov	DWORD PTR _matchByte$80042[ebp], edi

; 192  :           probLit = prob + offs + bit + symbol;

	lea	edi, DWORD PTR [edx+ebx]
	mov	ebx, DWORD PTR _prob$80020[ebp]
	add	edi, ecx
	lea	edi, DWORD PTR [ebx+edi*2]
	mov	DWORD PTR _probLit$80048[ebp], edi

; 193  :           GET_BIT2(probLit, symbol, offs &= ~bit, offs &= bit)

	movzx	edi, WORD PTR [edi]
	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN92@
	mov	ebx, DWORD PTR _buf$[ebp]
	movzx	ebx, BYTE PTR [ebx]
	shl	esi, 8
	shl	eax, 8
	or	esi, ebx
	inc	DWORD PTR _buf$[ebp]
$LN92@:
	mov	ebx, eax
	shr	ebx, 11					; 0000000bH
	imul	ebx, edi
	cmp	esi, ebx
	jae	SHORT $LN91@
	mov	eax, ebx
	mov	ebx, 2048				; 00000800H
	sub	ebx, edi
	shr	ebx, 5
	add	ebx, edi
	mov	edi, DWORD PTR _probLit$80048[ebp]
	mov	WORD PTR [edi], bx
	add	ecx, ecx
	not	edx
	jmp	SHORT $LN141@
$LN91@:
	sub	eax, ebx
	sub	esi, ebx
	mov	ebx, edi
	shr	ebx, 5
	sub	edi, ebx
	mov	ebx, DWORD PTR _probLit$80048[ebp]
	mov	WORD PTR [ebx], di
	lea	ecx, DWORD PTR [ecx+ecx+1]
$LN141@:
	and	DWORD PTR _offs$80043[ebp], edx

; 194  :         }
; 195  :         while (symbol < 0x100);

	cmp	ecx, 256				; 00000100H
	jb	SHORT $LL133@
$LN93@:

; 196  :       }
; 197  :       dic[dicPos++] = (Byte)symbol;

	mov	edx, DWORD PTR _dicPos$[ebp]
	mov	edi, DWORD PTR _dic$[ebp]
	mov	BYTE PTR [edx+edi], cl

; 198  :       processedPos++;
; 199  : 
; 200  :       state = kLiteralNextStates[state];

	mov	ecx, DWORD PTR _state$[ebp]
	inc	edx
	inc	DWORD PTR _processedPos$[ebp]
	mov	DWORD PTR _dicPos$[ebp], edx
	movzx	edx, BYTE PTR _kLiteralNextStates[ecx]
	mov	DWORD PTR _state$[ebp], edx

; 201  :       /* if (state < 4) state = 0; else if (state < 10) state -= 3; else state -= 6; */
; 202  :       continue;

	jmp	$LN109@
$LN106@:

; 203  :     }
; 204  :     else
; 205  :     {
; 206  :       UPDATE_1(prob);

	sub	eax, edx
	sub	esi, edx
	mov	edx, ecx
	shr	edx, 5
	sub	ecx, edx
	mov	edx, DWORD PTR _prob$80020[ebp]
	mov	WORD PTR [edx], cx

; 207  :       prob = probs + IsRep + state;
; 208  :       IF_BIT_0(prob)

	mov	ecx, DWORD PTR _probs$[ebp]
	movzx	edx, WORD PTR [ecx+ebx*2+384]
	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN139@
	mov	edi, DWORD PTR _buf$[ebp]
	movzx	edi, BYTE PTR [edi]
	shl	esi, 8
	shl	eax, 8
	or	esi, edi
	inc	DWORD PTR _buf$[ebp]
$LN139@:
	mov	edi, eax
	shr	edi, 11					; 0000000bH
	imul	edi, edx
	cmp	esi, edi
	jae	SHORT $LN87@

; 209  :       {
; 210  :         UPDATE_0(prob);

	mov	eax, edi
	mov	edi, 2048				; 00000800H
	sub	edi, edx
	shr	edi, 5
	add	edi, edx
	mov	WORD PTR [ecx+ebx*2+384], di

; 211  :         state += kNumStates;

	add	ebx, 12					; 0000000cH

; 212  :         prob = probs + LenCoder;

	add	ecx, 1636				; 00000664H

; 213  :       }
; 214  :       else

	jmp	$LN142@
$LN87@:

; 215  :       {
; 216  :         UPDATE_1(prob);

	sub	eax, edi
	sub	esi, edi
	mov	edi, edx
	shr	edi, 5
	sub	edx, edi

; 217  :         if (checkDicSize == 0 && processedPos == 0)

	cmp	DWORD PTR _checkDicSize$[ebp], 0
	mov	WORD PTR [ecx+ebx*2+384], dx
	jne	SHORT $LN85@
	cmp	DWORD PTR _processedPos$[ebp], 0
	je	$LN127@
$LN85@:

; 219  :         prob = probs + IsRepG0 + state;
; 220  :         IF_BIT_0(prob)

	movzx	edx, WORD PTR [ecx+ebx*2+408]
	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN84@
	mov	edi, DWORD PTR _buf$[ebp]
	movzx	edi, BYTE PTR [edi]
	shl	esi, 8
	shl	eax, 8
	or	esi, edi
	inc	DWORD PTR _buf$[ebp]
$LN84@:
	mov	edi, eax
	shr	edi, 11					; 0000000bH
	imul	edi, edx
	mov	DWORD PTR _bound$80021[ebp], edi
	cmp	esi, edi
	jae	$LN83@

; 221  :         {
; 222  :           UPDATE_0(prob);

	mov	eax, edi
	mov	edi, 2048				; 00000800H
	sub	edi, edx
	shr	edi, 5
	add	edi, edx

; 223  :           prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;

	lea	edx, DWORD PTR [ebx+15]
	shl	edx, 4
	add	edx, DWORD PTR _posState$80023[ebp]
	mov	WORD PTR [ecx+ebx*2+408], di
	lea	edx, DWORD PTR [ecx+edx*2]

; 224  :           IF_BIT_0(prob)

	mov	edi, eax
	mov	DWORD PTR _prob$80020[ebp], edx
	movzx	edx, WORD PTR [edx]
	cmp	edi, 16777216				; 01000000H
	jae	SHORT $LN82@
	shl	edi, 8
	mov	eax, edi
	mov	edi, DWORD PTR _buf$[ebp]
	movzx	edi, BYTE PTR [edi]
	shl	esi, 8
	or	esi, edi
	inc	DWORD PTR _buf$[ebp]
$LN82@:
	mov	edi, eax
	shr	edi, 11					; 0000000bH
	imul	edi, edx
	cmp	esi, edi
	jae	SHORT $LN81@

; 225  :           {
; 226  :             UPDATE_0(prob);

	mov	ecx, 2048				; 00000800H
	sub	ecx, edx
	shr	ecx, 5
	add	ecx, edx
	mov	edx, DWORD PTR _prob$80020[ebp]
	mov	WORD PTR [edx], cx

; 227  :             dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];

	mov	ecx, DWORD PTR _rep0$[ebp]
	mov	eax, edi
	mov	edi, DWORD PTR _dicPos$[ebp]
	cmp	edi, ecx
	sbb	edx, edx
	and	edx, DWORD PTR _dicBufSize$[ebp]

; 228  :             dicPos++;
; 229  :             processedPos++;

	inc	DWORD PTR _processedPos$[ebp]
	sub	edx, ecx
	mov	ecx, DWORD PTR _dic$[ebp]
	add	edx, edi
	mov	dl, BYTE PTR [edx+ecx]
	mov	BYTE PTR [edi+ecx], dl
	inc	edi

; 230  :             state = state < kNumLitStates ? 9 : 11;

	cmp	ebx, 7
	sbb	ecx, ecx
	and	ecx, -2					; fffffffeH
	add	ecx, 11					; 0000000bH
	mov	DWORD PTR _state$[ebp], ecx

; 231  :             continue;

	jmp	$LN143@
$LN81@:

; 232  :           }
; 233  :           UPDATE_1(prob);

	sub	eax, edi
	sub	esi, edi
	mov	edi, edx
	shr	edi, 5
	sub	edx, edi
	mov	edi, DWORD PTR _prob$80020[ebp]
	mov	WORD PTR [edi], dx

; 234  :         }
; 235  :         else

	jmp	$LN80@
$LN83@:

; 236  :         {
; 237  :           UInt32 distance;
; 238  :           UPDATE_1(prob);

	sub	eax, edi
	sub	esi, edi
	mov	edi, edx
	shr	edi, 5
	sub	edx, edi
	mov	WORD PTR [ecx+ebx*2+408], dx

; 239  :           prob = probs + IsRepG1 + state;
; 240  :           IF_BIT_0(prob)

	movzx	edx, WORD PTR [ecx+ebx*2+432]
	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN79@
	mov	edi, DWORD PTR _buf$[ebp]
	movzx	edi, BYTE PTR [edi]
	shl	esi, 8
	shl	eax, 8
	or	esi, edi
	inc	DWORD PTR _buf$[ebp]
$LN79@:
	mov	edi, eax
	shr	edi, 11					; 0000000bH
	imul	edi, edx
	cmp	esi, edi
	jae	SHORT $LN78@

; 241  :           {
; 242  :             UPDATE_0(prob);

	mov	eax, edi
	mov	edi, 2048				; 00000800H
	sub	edi, edx
	shr	edi, 5
	add	edi, edx

; 243  :             distance = rep1;

	mov	edx, DWORD PTR _rep1$[ebp]
	mov	WORD PTR [ecx+ebx*2+432], di

; 244  :           }
; 245  :           else

	jmp	SHORT $LN77@
$LN78@:

; 246  :           {
; 247  :             UPDATE_1(prob);

	sub	eax, edi
	sub	esi, edi
	mov	edi, edx
	shr	edi, 5
	sub	edx, edi
	mov	WORD PTR [ecx+ebx*2+432], dx

; 248  :             prob = probs + IsRepG2 + state;
; 249  :             IF_BIT_0(prob)

	movzx	edx, WORD PTR [ecx+ebx*2+456]
	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN76@
	mov	edi, DWORD PTR _buf$[ebp]
	movzx	edi, BYTE PTR [edi]
	shl	esi, 8
	shl	eax, 8
	or	esi, edi
	inc	DWORD PTR _buf$[ebp]
$LN76@:
	mov	edi, eax
	shr	edi, 11					; 0000000bH
	imul	edi, edx
	cmp	esi, edi
	jae	SHORT $LN75@

; 250  :             {
; 251  :               UPDATE_0(prob);

	mov	eax, edi
	mov	edi, 2048				; 00000800H
	sub	edi, edx
	shr	edi, 5
	add	edi, edx

; 252  :               distance = rep2;

	mov	edx, DWORD PTR _rep2$[ebp]
	mov	WORD PTR [ecx+ebx*2+456], di

; 253  :             }
; 254  :             else

	jmp	SHORT $LN74@
$LN75@:

; 255  :             {
; 256  :               UPDATE_1(prob);

	sub	eax, edi
	sub	esi, edi
	mov	edi, edx
	shr	edi, 5
	sub	edx, edi

; 257  :               distance = rep3;
; 258  :               rep3 = rep2;

	mov	edi, DWORD PTR _rep2$[ebp]
	mov	WORD PTR [ecx+ebx*2+456], dx
	mov	edx, DWORD PTR _rep3$[ebp]
	mov	DWORD PTR _rep3$[ebp], edi
$LN74@:

; 259  :             }
; 260  :             rep2 = rep1;

	mov	edi, DWORD PTR _rep1$[ebp]
	mov	DWORD PTR _rep2$[ebp], edi
$LN77@:

; 261  :           }
; 262  :           rep1 = rep0;

	mov	edi, DWORD PTR _rep0$[ebp]
	mov	DWORD PTR _rep1$[ebp], edi

; 263  :           rep0 = distance;

	mov	DWORD PTR _rep0$[ebp], edx
$LN80@:

; 264  :         }
; 265  :         state = state < kNumLitStates ? 8 : 11;

	cmp	ebx, 7
	sbb	ebx, ebx
	and	ebx, -3					; fffffffdH
	add	ebx, 11					; 0000000bH

; 266  :         prob = probs + RepLenCoder;

	add	ecx, 2664				; 00000a68H
$LN142@:

; 267  :       }
; 268  :       {
; 269  :         unsigned limit, offset;
; 270  :         CLzmaProb *probLen = prob + LenChoice;
; 271  :         IF_BIT_0(probLen)

	movzx	edx, WORD PTR [ecx]
	mov	DWORD PTR _state$[ebp], ebx
	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN73@
	mov	edi, DWORD PTR _buf$[ebp]
	movzx	edi, BYTE PTR [edi]
	shl	esi, 8
	shl	eax, 8
	or	esi, edi
	inc	DWORD PTR _buf$[ebp]
$LN73@:
	mov	edi, eax
	shr	edi, 11					; 0000000bH
	imul	edi, edx
	cmp	esi, edi
	jae	SHORT $LN72@

; 272  :         {
; 273  :           UPDATE_0(probLen);

	mov	eax, edi
	mov	edi, 2048				; 00000800H
	sub	edi, edx
	shr	edi, 5
	add	edi, edx

; 274  :           probLen = prob + LenLow + (posState << kLenNumLowBits);

	mov	edx, DWORD PTR _posState$80023[ebp]
	add	edx, edx
	lea	edx, DWORD PTR [ecx+edx*8+4]
	mov	WORD PTR [ecx], di
	mov	DWORD PTR _probLen$80091[ebp], edx

; 275  :           offset = 0;

	mov	DWORD PTR _offset$80090[ebp], 0

; 276  :           limit = (1 << kLenNumLowBits);

	mov	DWORD PTR _limit$80089[ebp], 8

; 277  :         }
; 278  :         else

	jmp	$LN68@
$LN72@:

; 279  :         {
; 280  :           UPDATE_1(probLen);

	sub	eax, edi
	sub	esi, edi
	mov	edi, edx
	shr	edi, 5
	sub	edx, edi
	mov	WORD PTR [ecx], dx

; 281  :           probLen = prob + LenChoice2;
; 282  :           IF_BIT_0(probLen)

	movzx	edx, WORD PTR [ecx+2]
	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN70@
	mov	edi, DWORD PTR _buf$[ebp]
	movzx	edi, BYTE PTR [edi]
	shl	esi, 8
	shl	eax, 8
	or	esi, edi
	inc	DWORD PTR _buf$[ebp]
$LN70@:
	mov	edi, eax
	shr	edi, 11					; 0000000bH
	imul	edi, edx
	cmp	esi, edi
	jae	SHORT $LN69@

; 283  :           {
; 284  :             UPDATE_0(probLen);

	mov	eax, edi
	mov	edi, 2048				; 00000800H
	sub	edi, edx
	shr	edi, 5
	add	edi, edx

; 285  :             probLen = prob + LenMid + (posState << kLenNumMidBits);

	mov	edx, DWORD PTR _posState$80023[ebp]
	mov	WORD PTR [ecx+2], di
	add	edx, edx
	lea	ecx, DWORD PTR [ecx+edx*8+260]
	mov	DWORD PTR _probLen$80091[ebp], ecx

; 286  :             offset = kLenNumLowSymbols;

	mov	ecx, 8
	mov	DWORD PTR _offset$80090[ebp], ecx

; 287  :             limit = (1 << kLenNumMidBits);

	mov	DWORD PTR _limit$80089[ebp], ecx

; 288  :           }
; 289  :           else

	jmp	SHORT $LN68@
$LN69@:

; 290  :           {
; 291  :             UPDATE_1(probLen);

	sub	eax, edi
	sub	esi, edi
	mov	edi, edx
	shr	edi, 5
	sub	edx, edi
	mov	WORD PTR [ecx+2], dx

; 292  :             probLen = prob + LenHigh;

	add	ecx, 516				; 00000204H
	mov	DWORD PTR _probLen$80091[ebp], ecx

; 293  :             offset = kLenNumLowSymbols + kLenNumMidSymbols;

	mov	DWORD PTR _offset$80090[ebp], 16	; 00000010H

; 294  :             limit = (1 << kLenNumHighBits);

	mov	DWORD PTR _limit$80089[ebp], 256	; 00000100H
$LN68@:

; 295  :           }
; 296  :         }
; 297  :         TREE_DECODE(probLen, limit, len);

	mov	edx, 1
$LL67@:
	mov	ecx, DWORD PTR _probLen$80091[ebp]
	movzx	ecx, WORD PTR [ecx+edx*2]
	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN64@
	mov	edi, DWORD PTR _buf$[ebp]
	movzx	edi, BYTE PTR [edi]
	shl	esi, 8
	shl	eax, 8
	or	esi, edi
	inc	DWORD PTR _buf$[ebp]
$LN64@:
	mov	edi, eax
	shr	edi, 11					; 0000000bH
	imul	edi, ecx
	cmp	esi, edi
	jae	SHORT $LN63@
	mov	eax, edi
	mov	edi, 2048				; 00000800H
	sub	edi, ecx
	shr	edi, 5
	add	edi, ecx
	mov	ecx, DWORD PTR _probLen$80091[ebp]
	mov	WORD PTR [ecx+edx*2], di
	add	edx, edx
	jmp	SHORT $LN66@
$LN63@:
	sub	eax, edi
	sub	esi, edi
	mov	edi, ecx
	shr	edi, 5
	sub	ecx, edi
	mov	edi, DWORD PTR _probLen$80091[ebp]
	mov	WORD PTR [edi+edx*2], cx
	lea	edx, DWORD PTR [edx+edx+1]
$LN66@:
	mov	edi, DWORD PTR _limit$80089[ebp]
	cmp	edx, edi
	jb	SHORT $LL67@

; 298  :         len += offset;

	mov	ecx, DWORD PTR _offset$80090[ebp]
	sub	ecx, edi
	add	edx, ecx
	mov	DWORD PTR _len$[ebp], edx

; 299  :       }
; 300  : 
; 301  :       if (state >= kNumStates)

	cmp	ebx, 12					; 0000000cH
	jb	$LN61@

; 302  :       {
; 303  :         UInt32 distance;
; 304  :         prob = probs + PosSlot +
; 305  :             ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);

	mov	ecx, edx
	cmp	edx, 4
	jb	SHORT $LN116@
	mov	ecx, 3
$LN116@:
	mov	edx, DWORD PTR _probs$[ebp]
	shl	ecx, 7
	lea	ecx, DWORD PTR [ecx+edx+864]

; 306  :         TREE_6_DECODE(prob, distance);

	movzx	edx, WORD PTR [ecx+2]
	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN140@
	mov	edi, DWORD PTR _buf$[ebp]
	movzx	ebx, BYTE PTR [edi]
	shl	esi, 8
	shl	eax, 8
	or	esi, ebx
	inc	edi
	mov	DWORD PTR _buf$[ebp], edi
$LN140@:
	mov	edi, eax
	shr	edi, 11					; 0000000bH
	imul	edi, edx
	cmp	esi, edi
	jae	SHORT $LN59@
	mov	eax, edi
	mov	edi, 2048				; 00000800H
	sub	edi, edx
	shr	edi, 5
	add	edi, edx
	mov	WORD PTR [ecx+2], di
	mov	edx, 2
	jmp	SHORT $LN58@
$LN59@:
	sub	eax, edi
	sub	esi, edi
	mov	edi, edx
	shr	edi, 5
	sub	edx, edi
	mov	WORD PTR [ecx+2], dx
	mov	edx, 3
$LN58@:
	lea	ebx, DWORD PTR [edx+edx]
	movzx	edx, WORD PTR [ebx+ecx]
	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN57@
	mov	edi, DWORD PTR _buf$[ebp]
	movzx	edi, BYTE PTR [edi]
	shl	esi, 8
	shl	eax, 8
	or	esi, edi
	inc	DWORD PTR _buf$[ebp]
$LN57@:
	mov	edi, eax
	shr	edi, 11					; 0000000bH
	imul	edi, edx
	cmp	esi, edi
	jae	SHORT $LN56@
	mov	eax, edi
	mov	edi, 2048				; 00000800H
	sub	edi, edx
	shr	edi, 5
	add	edi, edx
	mov	WORD PTR [ebx+ecx], di
	jmp	SHORT $LN55@
$LN56@:
	sub	eax, edi
	sub	esi, edi
	mov	edi, edx
	shr	edi, 5
	sub	edx, edi
	mov	WORD PTR [ebx+ecx], dx
	inc	ebx
$LN55@:
	add	ebx, ebx
	movzx	edx, WORD PTR [ebx+ecx]
	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN54@
	mov	edi, DWORD PTR _buf$[ebp]
	movzx	edi, BYTE PTR [edi]
	shl	esi, 8
	shl	eax, 8
	or	esi, edi
	inc	DWORD PTR _buf$[ebp]
$LN54@:
	mov	edi, eax
	shr	edi, 11					; 0000000bH
	imul	edi, edx
	cmp	esi, edi
	jae	SHORT $LN53@
	mov	eax, edi
	mov	edi, 2048				; 00000800H
	sub	edi, edx
	shr	edi, 5
	add	edi, edx
	mov	WORD PTR [ebx+ecx], di
	jmp	SHORT $LN52@
$LN53@:
	sub	eax, edi
	sub	esi, edi
	mov	edi, edx
	shr	edi, 5
	sub	edx, edi
	mov	WORD PTR [ebx+ecx], dx
	inc	ebx
$LN52@:
	add	ebx, ebx
	movzx	edx, WORD PTR [ebx+ecx]
	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN51@
	mov	edi, DWORD PTR _buf$[ebp]
	movzx	edi, BYTE PTR [edi]
	shl	esi, 8
	shl	eax, 8
	or	esi, edi
	inc	DWORD PTR _buf$[ebp]
$LN51@:
	mov	edi, eax
	shr	edi, 11					; 0000000bH
	imul	edi, edx
	cmp	esi, edi
	jae	SHORT $LN50@
	mov	eax, edi
	mov	edi, 2048				; 00000800H
	sub	edi, edx
	shr	edi, 5
	add	edi, edx
	mov	WORD PTR [ebx+ecx], di
	jmp	SHORT $LN49@
$LN50@:
	sub	eax, edi
	sub	esi, edi
	mov	edi, edx
	shr	edi, 5
	sub	edx, edi
	mov	WORD PTR [ebx+ecx], dx
	inc	ebx
$LN49@:
	add	ebx, ebx
	movzx	edx, WORD PTR [ebx+ecx]
	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN48@
	mov	edi, DWORD PTR _buf$[ebp]
	movzx	edi, BYTE PTR [edi]
	shl	esi, 8
	shl	eax, 8
	or	esi, edi
	inc	DWORD PTR _buf$[ebp]
$LN48@:
	mov	edi, eax
	shr	edi, 11					; 0000000bH
	imul	edi, edx
	cmp	esi, edi
	jae	SHORT $LN47@
	mov	eax, edi
	mov	edi, 2048				; 00000800H
	sub	edi, edx
	shr	edi, 5
	add	edi, edx
	mov	WORD PTR [ebx+ecx], di
	jmp	SHORT $LN46@
$LN47@:
	sub	eax, edi
	sub	esi, edi
	mov	edi, edx
	shr	edi, 5
	sub	edx, edi
	mov	WORD PTR [ebx+ecx], dx
	inc	ebx
$LN46@:
	add	ebx, ebx
	movzx	edx, WORD PTR [ebx+ecx]
	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN45@
	mov	edi, DWORD PTR _buf$[ebp]
	movzx	edi, BYTE PTR [edi]
	shl	esi, 8
	shl	eax, 8
	or	esi, edi
	inc	DWORD PTR _buf$[ebp]
$LN45@:
	mov	edi, eax
	shr	edi, 11					; 0000000bH
	imul	edi, edx
	cmp	esi, edi
	jae	SHORT $LN44@
	mov	eax, edi
	mov	edi, 2048				; 00000800H
	sub	edi, edx
	shr	edi, 5
	add	edi, edx
	mov	WORD PTR [ebx+ecx], di
	jmp	SHORT $LN43@
$LN44@:
	sub	eax, edi
	sub	esi, edi
	mov	edi, edx
	shr	edi, 5
	sub	edx, edi
	mov	WORD PTR [ebx+ecx], dx
	inc	ebx
$LN43@:
	sub	ebx, 64					; 00000040H

; 307  :         if (distance >= kStartPosModelIndex)

	cmp	ebx, 4
	jb	$LN17@

; 308  :         {
; 309  :           unsigned posSlot = (unsigned)distance;
; 310  :           int numDirectBits = (int)(((distance >> 1) - 1));

	mov	ecx, ebx
	mov	edx, ebx
	mov	edi, 1
	shr	ecx, 1

; 311  :           distance = (2 | (distance & 1));

	and	ebx, edi
	sub	ecx, edi
	or	ebx, 2
	mov	DWORD PTR _numDirectBits$80154[ebp], ecx

; 312  :           if (posSlot < kEndPosModelIndex)

	cmp	edx, 14					; 0000000eH
	jae	$LN41@

; 313  :           {
; 314  :             distance <<= numDirectBits;

	shl	ebx, cl

; 315  :             prob = probs + SpecPos + distance - posSlot - 1;
; 316  :             {
; 317  :               UInt32 mask = 1;

	mov	DWORD PTR _mask$80157[ebp], edi
	mov	ecx, ebx
	sub	ecx, edx
	mov	edx, DWORD PTR _probs$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*2+1374]
	mov	DWORD PTR _prob$80020[ebp], ecx
	npad	2
$LL40@:

; 318  :               unsigned i = 1;
; 319  :               do
; 320  :               {
; 321  :                 GET_BIT2(prob + i, i, ; , distance |= mask);

	movzx	edx, WORD PTR [ecx+edi*2]
	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN37@
	mov	ecx, DWORD PTR _buf$[ebp]
	movzx	ecx, BYTE PTR [ecx]
	shl	esi, 8
	shl	eax, 8
	or	esi, ecx
	inc	DWORD PTR _buf$[ebp]
$LN37@:
	mov	ecx, eax
	shr	ecx, 11					; 0000000bH
	imul	ecx, edx
	cmp	esi, ecx
	jae	SHORT $LN36@
	mov	eax, ecx
	mov	ecx, 2048				; 00000800H
	sub	ecx, edx
	shr	ecx, 5
	add	ecx, edx
	mov	edx, ecx
	mov	ecx, DWORD PTR _prob$80020[ebp]
	mov	WORD PTR [ecx+edi*2], dx
	add	edi, edi
	jmp	SHORT $LN35@
$LN36@:
	sub	eax, ecx
	sub	esi, ecx
	mov	ecx, edx
	shr	ecx, 5
	sub	edx, ecx
	mov	ecx, DWORD PTR _prob$80020[ebp]
	or	ebx, DWORD PTR _mask$80157[ebp]
	mov	WORD PTR [ecx+edi*2], dx
	lea	edi, DWORD PTR [edi+edi+1]
$LN35@:

; 322  :                 mask <<= 1;

	shl	DWORD PTR _mask$80157[ebp], 1

; 323  :               }
; 324  :               while (--numDirectBits != 0);

	dec	DWORD PTR _numDirectBits$80154[ebp]
	jne	SHORT $LL40@

; 325  :             }
; 326  :           }
; 327  :           else

	jmp	$LN17@
$LN41@:

; 328  :           {
; 329  :             numDirectBits -= kNumAlignBits;

	sub	ecx, 4
	npad	4
$LL33@:

; 330  :             do
; 331  :             {
; 332  :               NORMALIZE

	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN30@
	mov	edx, DWORD PTR _buf$[ebp]
	movzx	edi, BYTE PTR [edx]
	shl	esi, 8
	shl	eax, 8
	or	esi, edi
	inc	edx
	mov	DWORD PTR _buf$[ebp], edx
$LN30@:

; 333  :               range >>= 1;

	shr	eax, 1

; 334  :               
; 335  :               {
; 336  :                 UInt32 t;
; 337  :                 code -= range;

	sub	esi, eax

; 338  :                 t = (0 - ((UInt32)code >> 31)); /* (UInt32)((Int32)code >> 31) */

	mov	edx, esi
	shr	edx, 31					; 0000001fH
	neg	edx

; 339  :                 distance = (distance << 1) + (t + 1);

	lea	ebx, DWORD PTR [edx+ebx*2+1]

; 340  :                 code += range & t;

	and	edx, eax
	add	esi, edx

; 341  :               }
; 342  :               /*
; 343  :               distance <<= 1;
; 344  :               if (code >= range)
; 345  :               {
; 346  :                 code -= range;
; 347  :                 distance |= 1;
; 348  :               }
; 349  :               */
; 350  :             }
; 351  :             while (--numDirectBits != 0);

	dec	ecx
	jne	SHORT $LL33@

; 352  :             prob = probs + Align;
; 353  :             distance <<= kNumAlignBits;
; 354  :             {
; 355  :               unsigned i = 1;
; 356  :               GET_BIT2(prob + i, i, ; , distance |= 1);

	mov	ecx, DWORD PTR _probs$[ebp]
	movzx	edx, WORD PTR [ecx+1606]
	shl	ebx, 4
	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN135@
	mov	edi, DWORD PTR _buf$[ebp]
	movzx	edi, BYTE PTR [edi]
	shl	esi, 8
	shl	eax, 8
	or	esi, edi
	inc	DWORD PTR _buf$[ebp]
$LN135@:
	mov	edi, eax
	shr	edi, 11					; 0000000bH
	imul	edi, edx
	cmp	esi, edi
	jae	SHORT $LN28@
	mov	eax, edi
	mov	edi, 2048				; 00000800H
	sub	edi, edx
	shr	edi, 5
	add	edi, edx
	mov	WORD PTR [ecx+1606], di
	mov	edx, 2
	jmp	SHORT $LN27@
$LN28@:
	sub	eax, edi
	sub	esi, edi
	mov	edi, edx
	shr	edi, 5
	sub	edx, edi
	mov	WORD PTR [ecx+1606], dx
	mov	edx, 3
	or	ebx, 1
$LN27@:

; 357  :               GET_BIT2(prob + i, i, ; , distance |= 2);

	add	edx, edx
	mov	DWORD PTR tv1823[ebp], edx
	movzx	edx, WORD PTR [edx+ecx+1604]
	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN26@
	mov	edi, DWORD PTR _buf$[ebp]
	movzx	edi, BYTE PTR [edi]
	shl	esi, 8
	shl	eax, 8
	or	esi, edi
	inc	DWORD PTR _buf$[ebp]
$LN26@:
	mov	edi, eax
	shr	edi, 11					; 0000000bH
	imul	edi, edx
	cmp	esi, edi
	jae	SHORT $LN25@
	mov	eax, edi
	mov	edi, 2048				; 00000800H
	sub	edi, edx
	shr	edi, 5
	add	edi, edx
	mov	edx, DWORD PTR tv1823[ebp]
	mov	WORD PTR [edx+ecx+1604], di
	jmp	SHORT $LN24@
$LN25@:
	sub	eax, edi
	sub	esi, edi
	mov	edi, edx
	shr	edi, 5
	sub	edx, edi
	mov	edi, DWORD PTR tv1823[ebp]
	mov	WORD PTR [edi+ecx+1604], dx
	lea	edx, DWORD PTR [edi+1]
	or	ebx, 2
$LN24@:

; 358  :               GET_BIT2(prob + i, i, ; , distance |= 4);

	add	edx, edx
	mov	DWORD PTR tv1823[ebp], edx
	movzx	edx, WORD PTR [edx+ecx+1604]
	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN23@
	mov	edi, DWORD PTR _buf$[ebp]
	movzx	edi, BYTE PTR [edi]
	shl	esi, 8
	shl	eax, 8
	or	esi, edi
	inc	DWORD PTR _buf$[ebp]
$LN23@:
	mov	edi, eax
	shr	edi, 11					; 0000000bH
	imul	edi, edx
	cmp	esi, edi
	jae	SHORT $LN22@
	mov	eax, edi
	mov	edi, 2048				; 00000800H
	sub	edi, edx
	shr	edi, 5
	add	edi, edx
	mov	edx, DWORD PTR tv1823[ebp]
	mov	WORD PTR [edx+ecx+1604], di
	jmp	SHORT $LN144@
$LN22@:
	sub	eax, edi
	sub	esi, edi
	mov	edi, edx
	shr	edi, 5
	sub	edx, edi
	mov	edi, DWORD PTR tv1823[ebp]
	mov	WORD PTR [edi+ecx+1604], dx
	lea	edx, DWORD PTR [edi+1]
	or	ebx, 4
$LN144@:
	mov	DWORD PTR _i$80176[ebp], edx

; 359  :               GET_BIT2(prob + i, i, ; , distance |= 8);

	movzx	edx, WORD PTR [ecx+edx*2+1604]
	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN20@
	mov	edi, DWORD PTR _buf$[ebp]
	movzx	edi, BYTE PTR [edi]
	shl	esi, 8
	shl	eax, 8
	or	esi, edi
	inc	DWORD PTR _buf$[ebp]
$LN20@:
	mov	edi, eax
	shr	edi, 11					; 0000000bH
	imul	edi, edx
	cmp	esi, edi
	jae	SHORT $LN19@
	mov	eax, edi
	mov	edi, 2048				; 00000800H
	sub	edi, edx
	shr	edi, 5
	add	edi, edx
	mov	edx, DWORD PTR _i$80176[ebp]
	mov	WORD PTR [ecx+edx*2+1604], di
	jmp	SHORT $LN18@
$LN19@:
	sub	eax, edi
	sub	esi, edi
	mov	edi, edx
	shr	edi, 5
	sub	edx, edi
	mov	edi, DWORD PTR _i$80176[ebp]
	mov	WORD PTR [ecx+edi*2+1604], dx
	or	ebx, 8
$LN18@:

; 360  :             }
; 361  :             if (distance == (UInt32)0xFFFFFFFF)

	cmp	ebx, -1
	je	$LN128@
$LN17@:

; 365  :               break;
; 366  :             }
; 367  :           }
; 368  :         }
; 369  :         rep3 = rep2;

	mov	ecx, DWORD PTR _rep2$[ebp]

; 370  :         rep2 = rep1;

	mov	edx, DWORD PTR _rep1$[ebp]
	mov	DWORD PTR _rep3$[ebp], ecx

; 371  :         rep1 = rep0;

	mov	ecx, DWORD PTR _rep0$[ebp]
	mov	DWORD PTR _rep1$[ebp], ecx

; 372  :         rep0 = distance + 1;
; 373  :         if (checkDicSize == 0)

	mov	ecx, DWORD PTR _checkDicSize$[ebp]
	mov	DWORD PTR _rep2$[ebp], edx
	lea	edx, DWORD PTR [ebx+1]
	mov	DWORD PTR _rep0$[ebp], edx
	test	ecx, ecx
	jne	SHORT $LN16@

; 374  :         {
; 375  :           if (distance >= processedPos)

	cmp	ebx, DWORD PTR _processedPos$[ebp]

; 376  :             return SZ_ERROR_DATA;
; 377  :         }
; 378  :         else if (distance >= checkDicSize)

	jmp	SHORT $LN145@
$LN16@:
	cmp	ebx, ecx
$LN145@:
	jae	$LN127@

; 379  :           return SZ_ERROR_DATA;
; 380  :         state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3;

	cmp	DWORD PTR _state$[ebp], 19		; 00000013H
	mov	edx, DWORD PTR _len$[ebp]
	sbb	ecx, ecx
	and	ecx, -3					; fffffffdH
	add	ecx, 10					; 0000000aH
	mov	DWORD PTR _state$[ebp], ecx
$LN61@:

; 381  :         /* state = kLiteralNextStates[state]; */
; 382  :       }
; 383  : 
; 384  :       len += kMatchMinLen;
; 385  : 
; 386  :       if (limit == dicPos)

	mov	ecx, DWORD PTR _limit$[ebp]
	mov	edi, DWORD PTR _dicPos$[ebp]
	add	edx, 2
	cmp	ecx, edi
	je	$LN127@

; 387  :         return SZ_ERROR_DATA;
; 388  :       {
; 389  :         SizeT rem = limit - dicPos;

	sub	ecx, edi

; 390  :         unsigned curLen = ((rem < len) ? (unsigned)rem : len);

	mov	DWORD PTR _curLen$80209[ebp], ecx
	cmp	ecx, edx
	jb	SHORT $LN118@
	mov	DWORD PTR _curLen$80209[ebp], edx
$LN118@:

; 391  :         SizeT pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);

	cmp	edi, DWORD PTR _rep0$[ebp]

; 392  : 
; 393  :         processedPos += curLen;

	mov	ebx, DWORD PTR _curLen$80209[ebp]
	sbb	ecx, ecx
	and	ecx, DWORD PTR _dicBufSize$[ebp]
	add	DWORD PTR _processedPos$[ebp], ebx
	sub	ecx, DWORD PTR _rep0$[ebp]

; 394  : 
; 395  :         len -= curLen;

	sub	edx, ebx
	add	ecx, edi
	mov	DWORD PTR _len$[ebp], edx

; 396  :         if (pos + curLen <= dicBufSize)

	lea	edx, DWORD PTR [ecx+ebx]
	cmp	edx, DWORD PTR _dicBufSize$[ebp]

; 397  :         {
; 398  :           Byte *dest = dic + dicPos;

	mov	edx, DWORD PTR _dic$[ebp]
	ja	SHORT $LL6@
	add	edx, edi

; 399  :           ptrdiff_t src = (ptrdiff_t)pos - (ptrdiff_t)dicPos;
; 400  :           const Byte *lim = dest + curLen;

	add	ebx, edx
	sub	ecx, edi

; 401  :           dicPos += curLen;

	add	edi, DWORD PTR _curLen$80209[ebp]
	mov	DWORD PTR _lim$80217[ebp], ebx
	mov	DWORD PTR _dicPos$[ebp], edi
	npad	1
$LL10@:

; 402  :           do
; 403  :             *(dest) = (Byte)*(dest + src);

	mov	bl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [edx], bl

; 404  :           while (++dest != lim);

	inc	edx
	cmp	edx, DWORD PTR _lim$80217[ebp]
	jne	SHORT $LL10@

; 405  :         }
; 406  :         else

	jmp	SHORT $LN109@
	npad	3
$LL6@:

; 407  :         {
; 408  :           do
; 409  :           {
; 410  :             dic[dicPos++] = dic[pos];

	mov	bl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [edi+edx], bl

; 411  :             if (++pos == dicBufSize)

	inc	ecx
	inc	edi
	cmp	ecx, DWORD PTR _dicBufSize$[ebp]
	jne	SHORT $LN5@

; 412  :               pos = 0;

	xor	ecx, ecx
$LN5@:

; 413  :           }
; 414  :           while (--curLen != 0);

	dec	DWORD PTR _curLen$80209[ebp]
	jne	SHORT $LL6@
$LN143@:

; 407  :         {
; 408  :           do
; 409  :           {
; 410  :             dic[dicPos++] = dic[pos];

	mov	DWORD PTR _dicPos$[ebp], edi
$LN109@:

; 415  :         }
; 416  :       }
; 417  :     }
; 418  :   }
; 419  :   while (dicPos < limit && buf < bufLimit);

	mov	ecx, DWORD PTR _dicPos$[ebp]
	cmp	ecx, DWORD PTR _limit$[ebp]
	jae	SHORT $LN108@
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	edx, DWORD PTR _bufLimit$[ebp]
	jae	SHORT $LN108@
	mov	edx, DWORD PTR _pbMask$[ebp]
	mov	ebx, DWORD PTR _state$[ebp]
	mov	edi, DWORD PTR _p$[ebp]
	jmp	$LL110@
$LN127@:
	pop	edi
	pop	esi

; 218  :           return SZ_ERROR_DATA;

	mov	eax, 1
	pop	ebx

; 434  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN128@:

; 362  :             {
; 363  :               len += kMatchSpecLenStart;

	add	DWORD PTR _len$[ebp], 274		; 00000112H

; 364  :               state -= kNumStates;

	sub	DWORD PTR _state$[ebp], 12		; 0000000cH
$LN108@:

; 420  :   NORMALIZE;

	mov	edx, DWORD PTR _buf$[ebp]
	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN1@
	movzx	ecx, BYTE PTR [edx]
	shl	esi, 8
	shl	eax, 8
	or	esi, ecx
	inc	edx
$LN1@:

; 421  :   p->buf = buf;

	mov	ecx, DWORD PTR _p$[ebp]

; 422  :   p->range = range;

	mov	DWORD PTR [ecx+28], eax

; 423  :   p->code = code;
; 424  :   p->remainLen = len;
; 425  :   p->dicPos = dicPos;

	mov	eax, DWORD PTR _dicPos$[ebp]
	mov	DWORD PTR [ecx+24], edx
	mov	edx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 426  :   p->processedPos = processedPos;
; 427  :   p->reps[0] = rep0;

	mov	eax, DWORD PTR _rep0$[ebp]
	mov	DWORD PTR [ecx+72], edx
	mov	edx, DWORD PTR _processedPos$[ebp]
	mov	DWORD PTR [ecx+56], eax

; 428  :   p->reps[1] = rep1;
; 429  :   p->reps[2] = rep2;

	mov	eax, DWORD PTR _rep2$[ebp]
	mov	DWORD PTR [ecx+44], edx
	mov	edx, DWORD PTR _rep1$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 430  :   p->reps[3] = rep3;
; 431  :   p->state = state;

	mov	eax, DWORD PTR _state$[ebp]
	pop	edi
	mov	DWORD PTR [ecx+32], esi
	mov	DWORD PTR [ecx+60], edx
	mov	edx, DWORD PTR _rep3$[ebp]
	pop	esi
	mov	DWORD PTR [ecx+52], eax
	mov	DWORD PTR [ecx+68], edx

; 432  : 
; 433  :   return SZ_OK;

	xor	eax, eax
	pop	ebx

; 434  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
@LzmaDec_DecodeReal@12 ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT @LzmaDec_WriteRem@8
_TEXT	SEGMENT
_dicBufSize$80239 = -8					; size = 4
_rep0$80241 = -4					; size = 4
_limit$ = 8						; size = 4
@LzmaDec_WriteRem@8 PROC				; COMDAT
; _p$ = esi

; 437  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 438  :   if (p->remainLen != 0 && p->remainLen < kMatchSpecLenStart)

	mov	ebx, DWORD PTR [esi+72]
	test	ebx, ebx
	je	SHORT $LN5@
	cmp	ebx, 274				; 00000112H
	jae	SHORT $LN5@

; 439  :   {
; 440  :     Byte *dic = p->dic;
; 441  :     SizeT dicPos = p->dicPos;
; 442  :     SizeT dicBufSize = p->dicBufSize;
; 443  :     unsigned len = p->remainLen;
; 444  :     UInt32 rep0 = p->reps[0];

	mov	edx, DWORD PTR [esi+56]
	mov	ecx, DWORD PTR [esi+40]
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR _rep0$80241[ebp], edx

; 445  :     if (limit - dicPos < len)

	mov	edx, DWORD PTR _limit$[ebp]
	mov	DWORD PTR _dicBufSize$80239[ebp], ecx
	mov	ecx, ebx
	sub	edx, eax
	push	edi
	mov	edi, DWORD PTR [esi+20]
	cmp	edx, ecx
	jae	SHORT $LN4@

; 446  :       len = (unsigned)(limit - dicPos);

	mov	ecx, edx
$LN4@:

; 447  : 
; 448  :     if (p->checkDicSize == 0 && p->prop.dicSize - p->processedPos <= len)

	cmp	DWORD PTR [esi+48], 0
	jne	SHORT $LN12@
	mov	edx, DWORD PTR [esi+12]
	sub	edx, DWORD PTR [esi+44]
	cmp	edx, ecx
	ja	SHORT $LN12@

; 449  :       p->checkDicSize = p->prop.dicSize;

	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+48], edx
$LN12@:

; 450  : 
; 451  :     p->processedPos += len;

	add	DWORD PTR [esi+44], ecx

; 452  :     p->remainLen -= len;

	sub	ebx, ecx
	mov	DWORD PTR [esi+72], ebx

; 453  :     while (len-- != 0)

	test	ecx, ecx
	je	SHORT $LN9@
$LL2@:

; 454  :     {
; 455  :       dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];

	cmp	eax, DWORD PTR _rep0$80241[ebp]
	sbb	edx, edx
	and	edx, DWORD PTR _dicBufSize$80239[ebp]
	sub	edx, DWORD PTR _rep0$80241[ebp]
	add	edx, eax
	mov	dl, BYTE PTR [edx+edi]
	mov	BYTE PTR [eax+edi], dl

; 456  :       dicPos++;

	inc	eax
	dec	ecx
	jne	SHORT $LL2@
$LN9@:

; 457  :     }
; 458  :     p->dicPos = dicPos;

	mov	DWORD PTR [esi+36], eax
	pop	edi
$LN5@:
	pop	ebx

; 459  :   }
; 460  : }

	mov	esp, ebp
	pop	ebp
	ret	4
@LzmaDec_WriteRem@8 ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT @LzmaDec_DecodeReal2@12
_TEXT	SEGMENT
_bufLimit$ = 8						; size = 4
@LzmaDec_DecodeReal2@12 PROC				; COMDAT
; _p$ = eax
; _limit$ = edi

; 463  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, eax
$LL9@:

; 464  :   do
; 465  :   {
; 466  :     SizeT limit2 = limit;
; 467  :     if (p->checkDicSize == 0)

	cmp	DWORD PTR [esi+48], 0
	mov	edx, edi
	jne	SHORT $LN14@

; 468  :     {
; 469  :       UInt32 rem = p->prop.dicSize - p->processedPos;

	mov	eax, DWORD PTR [esi+12]

; 470  :       if (limit - p->dicPos > rem)

	mov	ecx, DWORD PTR [esi+36]
	sub	eax, DWORD PTR [esi+44]
	mov	ebx, edi
	sub	ebx, ecx
	cmp	ebx, eax
	jbe	SHORT $LN14@

; 471  :         limit2 = p->dicPos + rem;

	lea	edx, DWORD PTR [ecx+eax]
$LN14@:

; 472  :     }
; 473  :     RINOK(LzmaDec_DecodeReal(p, limit2, bufLimit));

	mov	ebx, DWORD PTR _bufLimit$[ebp]
	push	ebx
	push	edx
	push	esi
	call	@LzmaDec_DecodeReal@12
	test	eax, eax
	jne	SHORT $LN10@

; 474  :     if (p->processedPos >= p->prop.dicSize)

	mov	eax, DWORD PTR [esi+12]
	cmp	DWORD PTR [esi+44], eax
	jb	SHORT $LN3@

; 475  :       p->checkDicSize = p->prop.dicSize;

	mov	DWORD PTR [esi+48], eax
$LN3@:

; 476  :     LzmaDec_WriteRem(p, limit);

	push	edi
	call	@LzmaDec_WriteRem@8

; 477  :   }
; 478  :   while (p->dicPos < limit && p->buf < bufLimit && p->remainLen < kMatchSpecLenStart);

	cmp	DWORD PTR [esi+36], edi
	jae	SHORT $LN15@
	cmp	DWORD PTR [esi+24], ebx
	jae	SHORT $LN15@
	mov	eax, 274				; 00000112H
	cmp	DWORD PTR [esi+72], eax
	jb	SHORT $LL9@
	jmp	SHORT $LN2@
$LN15@:
	mov	eax, 274				; 00000112H
$LN2@:

; 479  : 
; 480  :   if (p->remainLen > kMatchSpecLenStart)

	cmp	DWORD PTR [esi+72], eax
	jbe	SHORT $LN1@

; 481  :   {
; 482  :     p->remainLen = kMatchSpecLenStart;

	mov	DWORD PTR [esi+72], eax
$LN1@:

; 483  :   }
; 484  :   return 0;

	xor	eax, eax
$LN10@:
	pop	esi
	pop	ebx

; 485  : }

	pop	ebp
	ret	4
@LzmaDec_DecodeReal2@12 ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _LzmaDec_TryDummy
_TEXT	SEGMENT
_res$ = -24						; size = 4
_matchByte$80309 = -24					; size = 4
_numDirectBits$80384 = -20				; size = 4
_offset$80353 = -20					; size = 4
_limit$80352 = -16					; size = 4
_ttt$80290 = -16					; size = 4
_prob$80288 = -12					; size = 4
_state$ = -12						; size = 4
_offs$80310 = -8					; size = 4
_probs$ = -8						; size = 4
_bufLimit$ = -4						; size = 4
_buf$ = 8						; size = 4
_LzmaDec_TryDummy PROC					; COMDAT
; _p$ = ecx
; _inSize$ = eax

; 496  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 497  :   UInt32 range = p->range;
; 498  :   UInt32 code = p->code;
; 499  :   const Byte *bufLimit = buf + inSize;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [edi+28]
	mov	esi, DWORD PTR [edi+32]
	add	ecx, eax

; 500  :   CLzmaProb *probs = p->probs;

	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR _bufLimit$[ebp], ecx

; 501  :   unsigned state = p->state;

	mov	ecx, DWORD PTR [edi+52]
	mov	DWORD PTR _state$[ebp], ecx

; 502  :   ELzmaDummy res;
; 503  : 
; 504  :   {
; 505  :     CLzmaProb *prob;
; 506  :     UInt32 bound;
; 507  :     unsigned ttt;
; 508  :     unsigned posState = (p->processedPos) & ((1 << p->prop.pb) - 1);

	mov	ecx, DWORD PTR [edi+8]
	mov	ebx, 1
	shl	ebx, cl

; 509  : 
; 510  :     prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
; 511  :     IF_BIT_0_CHECK(prob)

	mov	ecx, DWORD PTR _state$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _probs$[ebp], eax
	dec	ebx
	and	ebx, DWORD PTR [edi+44]
	add	ecx, ebx
	movzx	eax, WORD PTR [eax+ecx*2]
	mov	DWORD PTR _ttt$80290[ebp], eax
	cmp	edx, 16777216				; 01000000H
	jae	SHORT $LN84@LzmaDec_Tr
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	eax, DWORD PTR _bufLimit$[ebp]
	jae	$LN99@LzmaDec_Tr
	movzx	ecx, BYTE PTR [eax]
	shl	esi, 8
	shl	edx, 8
	or	esi, ecx
	inc	eax
	mov	DWORD PTR _buf$[ebp], eax
$LN84@LzmaDec_Tr:
	mov	eax, edx
	shr	eax, 11					; 0000000bH
	imul	eax, DWORD PTR _ttt$80290[ebp]
	cmp	esi, eax
	jae	$LN82@LzmaDec_Tr

; 512  :     {
; 513  :       UPDATE_0_CHECK

	mov	edx, eax

; 514  : 
; 515  :       /* if (bufLimit - buf >= 7) return DUMMY_LIT; */
; 516  : 
; 517  :       prob = probs + Literal;

	mov	eax, DWORD PTR _probs$[ebp]
	add	eax, 3692				; 00000e6cH

; 518  :       if (p->checkDicSize != 0 || p->processedPos != 0)

	cmp	DWORD PTR [edi+48], 0
	mov	DWORD PTR _prob$80288[ebp], eax
	jne	SHORT $LN80@LzmaDec_Tr
	cmp	DWORD PTR [edi+44], 0
	je	SHORT $LN81@LzmaDec_Tr
$LN80@LzmaDec_Tr:

; 519  :         prob += (LZMA_LIT_SIZE *
; 520  :           ((((p->processedPos) & ((1 << (p->prop.lp)) - 1)) << p->prop.lc) +
; 521  :           (p->dic[(p->dicPos == 0 ? p->dicBufSize : p->dicPos) - 1] >> (8 - p->prop.lc))));

	mov	ecx, DWORD PTR [edi+36]
	test	ecx, ecx
	jne	SHORT $LN87@LzmaDec_Tr
	mov	ecx, DWORD PTR [edi+40]
$LN87@LzmaDec_Tr:
	mov	ebx, DWORD PTR [edi+20]
	movzx	ebx, BYTE PTR [ebx+ecx-1]
	mov	eax, DWORD PTR [edi]
	mov	ecx, 8
	sub	cl, al
	shr	ebx, cl
	mov	ecx, DWORD PTR [edi+4]
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR [edi]
	dec	eax
	and	eax, DWORD PTR [edi+44]
	shl	eax, cl
	add	ebx, eax
	imul	ebx, 1536				; 00000600H
	add	DWORD PTR _prob$80288[ebp], ebx
$LN81@LzmaDec_Tr:

; 522  : 
; 523  :       if (state < kNumLitStates)

	cmp	DWORD PTR [edi+52], 7
	jae	SHORT $LN79@LzmaDec_Tr

; 524  :       {
; 525  :         unsigned symbol = 1;

	mov	ecx, 1
	npad	12
$LL78@LzmaDec_Tr:

; 526  :         do { GET_BIT_CHECK(prob + symbol, symbol) } while (symbol < 0x100);

	mov	eax, DWORD PTR _prob$80288[ebp]
	movzx	edi, WORD PTR [eax+ecx*2]
	cmp	edx, 16777216				; 01000000H
	jae	SHORT $LN75@LzmaDec_Tr
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	eax, DWORD PTR _bufLimit$[ebp]
	jae	$LN99@LzmaDec_Tr
	movzx	ebx, BYTE PTR [eax]
	shl	esi, 8
	shl	edx, 8
	or	esi, ebx
	inc	eax
	mov	DWORD PTR _buf$[ebp], eax
$LN75@LzmaDec_Tr:
	mov	eax, edx
	shr	eax, 11					; 0000000bH
	imul	eax, edi
	cmp	esi, eax
	jae	SHORT $LN73@LzmaDec_Tr
	mov	edx, eax
	add	ecx, ecx
	jmp	SHORT $LN77@LzmaDec_Tr
$LN73@LzmaDec_Tr:
	sub	edx, eax
	sub	esi, eax
	lea	ecx, DWORD PTR [ecx+ecx+1]
$LN77@LzmaDec_Tr:
	cmp	ecx, 256				; 00000100H
	jb	SHORT $LL78@LzmaDec_Tr
$LN68@LzmaDec_Tr:

; 544  :       }
; 545  :       res = DUMMY_LIT;

	mov	eax, 1

; 546  :     }
; 547  :     else

	jmp	$LN7@LzmaDec_Tr
$LN79@LzmaDec_Tr:

; 527  :       }
; 528  :       else
; 529  :       {
; 530  :         unsigned matchByte = p->dic[p->dicPos - p->reps[0] +
; 531  :             ((p->dicPos < p->reps[0]) ? p->dicBufSize : 0)];

	mov	ecx, DWORD PTR [edi+36]
	mov	ebx, DWORD PTR [edi+56]
	cmp	ecx, ebx
	jae	SHORT $LN89@LzmaDec_Tr
	mov	eax, DWORD PTR [edi+40]
	jmp	SHORT $LN90@LzmaDec_Tr
$LN89@LzmaDec_Tr:
	xor	eax, eax
$LN90@LzmaDec_Tr:
	mov	edi, DWORD PTR [edi+20]
	sub	edi, ebx
	add	edi, ecx
	movzx	ecx, BYTE PTR [edi+eax]

; 532  :         unsigned offs = 0x100;

	mov	DWORD PTR _offs$80310[ebp], 256		; 00000100H

; 533  :         unsigned symbol = 1;

	mov	edi, 1
	npad	2
$LL70@LzmaDec_Tr:

; 534  :         do
; 535  :         {
; 536  :           unsigned bit;
; 537  :           CLzmaProb *probLit;
; 538  :           matchByte <<= 1;
; 539  :           bit = (matchByte & offs);

	mov	ebx, DWORD PTR _offs$80310[ebp]
	add	ecx, ecx
	mov	eax, ebx
	and	eax, ecx
	mov	DWORD PTR _matchByte$80309[ebp], ecx

; 540  :           probLit = prob + offs + bit + symbol;
; 541  :           GET_BIT2_CHECK(probLit, symbol, offs &= ~bit, offs &= bit)

	lea	ecx, DWORD PTR [eax+edi]
	add	ecx, ebx
	mov	ebx, DWORD PTR _prob$80288[ebp]
	movzx	ecx, WORD PTR [ebx+ecx*2]
	mov	DWORD PTR _ttt$80290[ebp], ecx
	cmp	edx, 16777216				; 01000000H
	jae	SHORT $LN67@LzmaDec_Tr
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	ecx, DWORD PTR _bufLimit$[ebp]
	jae	$LN99@LzmaDec_Tr
	movzx	ebx, BYTE PTR [ecx]
	shl	esi, 8
	shl	edx, 8
	or	esi, ebx
	inc	ecx
	mov	DWORD PTR _buf$[ebp], ecx
$LN67@LzmaDec_Tr:
	mov	ecx, edx
	shr	ecx, 11					; 0000000bH
	imul	ecx, DWORD PTR _ttt$80290[ebp]
	cmp	esi, ecx
	jae	SHORT $LN65@LzmaDec_Tr
	mov	edx, ecx
	add	edi, edi
	not	eax
	jmp	SHORT $LN113@LzmaDec_Tr
$LN65@LzmaDec_Tr:
	sub	edx, ecx
	sub	esi, ecx
	lea	edi, DWORD PTR [edi+edi+1]
$LN113@LzmaDec_Tr:
	and	DWORD PTR _offs$80310[ebp], eax

; 542  :         }
; 543  :         while (symbol < 0x100);

	cmp	edi, 256				; 00000100H
	jae	$LN68@LzmaDec_Tr
	mov	ecx, DWORD PTR _matchByte$80309[ebp]
	jmp	SHORT $LL70@LzmaDec_Tr
$LN82@LzmaDec_Tr:

; 548  :     {
; 549  :       unsigned len;
; 550  :       UPDATE_1_CHECK;
; 551  : 
; 552  :       prob = probs + IsRep + state;
; 553  :       IF_BIT_0_CHECK(prob)

	mov	ecx, DWORD PTR _state$[ebp]
	sub	edx, eax
	sub	esi, eax
	mov	eax, DWORD PTR _probs$[ebp]
	movzx	ecx, WORD PTR [eax+ecx*2+384]
	cmp	edx, 16777216				; 01000000H
	jae	SHORT $LN62@LzmaDec_Tr
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	eax, DWORD PTR _bufLimit$[ebp]
	jae	$LN99@LzmaDec_Tr
	movzx	edi, BYTE PTR [eax]
	shl	esi, 8
	shl	edx, 8
	or	esi, edi
	inc	eax
	mov	DWORD PTR _buf$[ebp], eax
$LN62@LzmaDec_Tr:
	mov	eax, edx
	shr	eax, 11					; 0000000bH
	imul	eax, ecx
	cmp	esi, eax
	jae	SHORT $LN60@LzmaDec_Tr

; 554  :       {
; 555  :         UPDATE_0_CHECK;
; 556  :         state = 0;
; 557  :         prob = probs + LenCoder;

	mov	edi, DWORD PTR _probs$[ebp]
	mov	edx, eax

; 558  :         res = DUMMY_MATCH;
; 559  :       }
; 560  :       else

	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _state$[ebp], 0
	add	edi, 1636				; 00000664H
	mov	DWORD PTR _res$[ebp], 2
	jmp	$LN59@LzmaDec_Tr
$LN60@LzmaDec_Tr:

; 561  :       {
; 562  :         UPDATE_1_CHECK;
; 563  :         res = DUMMY_REP;
; 564  :         prob = probs + IsRepG0 + state;
; 565  :         IF_BIT_0_CHECK(prob)

	mov	ecx, DWORD PTR _probs$[ebp]
	sub	edx, eax
	sub	esi, eax
	mov	eax, DWORD PTR _state$[ebp]
	movzx	edi, WORD PTR [ecx+eax*2+408]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _res$[ebp], 3
	cmp	edx, 16777216				; 01000000H
	jae	SHORT $LN58@LzmaDec_Tr
	cmp	eax, DWORD PTR _bufLimit$[ebp]
	jae	$LN99@LzmaDec_Tr
	movzx	ecx, BYTE PTR [eax]
	shl	esi, 8
	shl	edx, 8
	or	esi, ecx
	inc	eax
	mov	DWORD PTR _buf$[ebp], eax
$LN58@LzmaDec_Tr:
	mov	ecx, edx
	shr	ecx, 11					; 0000000bH
	imul	ecx, edi
	cmp	esi, ecx
	jae	SHORT $LN56@LzmaDec_Tr

; 566  :         {
; 567  :           UPDATE_0_CHECK;
; 568  :           prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
; 569  :           IF_BIT_0_CHECK(prob)

	mov	eax, DWORD PTR _state$[ebp]
	mov	edi, DWORD PTR _probs$[ebp]
	add	eax, 15					; 0000000fH
	shl	eax, 4
	add	eax, ebx
	movzx	edi, WORD PTR [edi+eax*2]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	edx, ecx
	cmp	ecx, 16777216				; 01000000H
	jae	SHORT $LN55@LzmaDec_Tr
	cmp	eax, DWORD PTR _bufLimit$[ebp]
	jae	$LN99@LzmaDec_Tr
	shl	ecx, 8
	mov	edx, ecx
	movzx	ecx, BYTE PTR [eax]
	shl	esi, 8
	or	esi, ecx
	inc	eax
	mov	DWORD PTR _buf$[ebp], eax
$LN55@LzmaDec_Tr:
	mov	ecx, edx
	shr	ecx, 11					; 0000000bH
	imul	ecx, edi
	cmp	esi, ecx
	jae	$LN42@LzmaDec_Tr

; 570  :           {
; 571  :             UPDATE_0_CHECK;
; 572  :             NORMALIZE_CHECK;

	cmp	ecx, 16777216				; 01000000H
	jae	SHORT $LN51@LzmaDec_Tr
	cmp	eax, DWORD PTR _bufLimit$[ebp]
	jae	$LN99@LzmaDec_Tr
$LN51@LzmaDec_Tr:
	pop	edi
	pop	esi

; 573  :             return DUMMY_REP;

	mov	eax, 3
	pop	ebx

; 682  :   return res;
; 683  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN56@LzmaDec_Tr:

; 574  :           }
; 575  :           else
; 576  :           {
; 577  :             UPDATE_1_CHECK;
; 578  :           }
; 579  :         }
; 580  :         else
; 581  :         {
; 582  :           UPDATE_1_CHECK;
; 583  :           prob = probs + IsRepG1 + state;
; 584  :           IF_BIT_0_CHECK(prob)

	mov	edi, DWORD PTR _state$[ebp]
	sub	edx, ecx
	sub	esi, ecx
	mov	ecx, DWORD PTR _probs$[ebp]
	movzx	edi, WORD PTR [ecx+edi*2+432]
	cmp	edx, 16777216				; 01000000H
	jae	SHORT $LN48@LzmaDec_Tr
	cmp	eax, DWORD PTR _bufLimit$[ebp]
	jae	$LN99@LzmaDec_Tr
	movzx	ecx, BYTE PTR [eax]
	shl	esi, 8
	shl	edx, 8
	or	esi, ecx
	inc	eax
	mov	DWORD PTR _buf$[ebp], eax
$LN48@LzmaDec_Tr:
	mov	ecx, edx
	shr	ecx, 11					; 0000000bH
	imul	ecx, edi
	cmp	esi, ecx
	jae	SHORT $LN46@LzmaDec_Tr

; 585  :           {
; 586  :             UPDATE_0_CHECK;

	mov	edx, ecx

; 587  :           }
; 588  :           else

	jmp	SHORT $LN41@LzmaDec_Tr
$LN46@LzmaDec_Tr:

; 589  :           {
; 590  :             UPDATE_1_CHECK;
; 591  :             prob = probs + IsRepG2 + state;
; 592  :             IF_BIT_0_CHECK(prob)

	mov	edi, DWORD PTR _state$[ebp]
	sub	edx, ecx
	sub	esi, ecx
	mov	ecx, DWORD PTR _probs$[ebp]
	movzx	edi, WORD PTR [ecx+edi*2+456]
	cmp	edx, 16777216				; 01000000H
	jae	SHORT $LN44@LzmaDec_Tr
	cmp	eax, DWORD PTR _bufLimit$[ebp]
	jae	$LN99@LzmaDec_Tr
	movzx	ecx, BYTE PTR [eax]
	shl	esi, 8
	shl	edx, 8
	or	esi, ecx
	inc	eax
	mov	DWORD PTR _buf$[ebp], eax
$LN44@LzmaDec_Tr:
	mov	ecx, edx
	shr	ecx, 11					; 0000000bH
	imul	ecx, edi
	cmp	esi, ecx
	jae	SHORT $LN42@LzmaDec_Tr

; 593  :             {
; 594  :               UPDATE_0_CHECK;

	mov	edx, ecx

; 595  :             }
; 596  :             else

	jmp	SHORT $LN41@LzmaDec_Tr
$LN42@LzmaDec_Tr:

; 597  :             {
; 598  :               UPDATE_1_CHECK;

	sub	edx, ecx
	sub	esi, ecx
$LN41@LzmaDec_Tr:

; 599  :             }
; 600  :           }
; 601  :         }
; 602  :         state = kNumStates;
; 603  :         prob = probs + RepLenCoder;

	mov	edi, DWORD PTR _probs$[ebp]
	mov	DWORD PTR _state$[ebp], 12		; 0000000cH
	add	edi, 2664				; 00000a68H
$LN59@LzmaDec_Tr:

; 604  :       }
; 605  :       {
; 606  :         unsigned limit, offset;
; 607  :         CLzmaProb *probLen = prob + LenChoice;
; 608  :         IF_BIT_0_CHECK(probLen)

	cmp	edx, 16777216				; 01000000H
	jae	SHORT $LN40@LzmaDec_Tr
	cmp	eax, DWORD PTR _bufLimit$[ebp]
	jae	$LN99@LzmaDec_Tr
	movzx	ecx, BYTE PTR [eax]
	shl	esi, 8
	shl	edx, 8
	or	esi, ecx
	inc	eax
	mov	DWORD PTR _buf$[ebp], eax
$LN40@LzmaDec_Tr:
	movzx	eax, WORD PTR [edi]
	mov	ecx, edx
	shr	ecx, 11					; 0000000bH
	imul	ecx, eax
	cmp	esi, ecx
	jae	SHORT $LN38@LzmaDec_Tr

; 609  :         {
; 610  :           UPDATE_0_CHECK;
; 611  :           probLen = prob + LenLow + (posState << kLenNumLowBits);

	add	ebx, ebx
	mov	edx, ecx
	lea	ebx, DWORD PTR [edi+ebx*8+4]

; 612  :           offset = 0;

	mov	DWORD PTR _offset$80353[ebp], 0

; 613  :           limit = 1 << kLenNumLowBits;

	mov	DWORD PTR _limit$80352[ebp], 8

; 614  :         }
; 615  :         else

	jmp	SHORT $LN33@LzmaDec_Tr
$LN38@LzmaDec_Tr:

; 616  :         {
; 617  :           UPDATE_1_CHECK;

	sub	edx, ecx
	sub	esi, ecx

; 618  :           probLen = prob + LenChoice2;
; 619  :           IF_BIT_0_CHECK(probLen)

	cmp	edx, 16777216				; 01000000H
	jae	SHORT $LN36@LzmaDec_Tr
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	eax, DWORD PTR _bufLimit$[ebp]
	jae	$LN99@LzmaDec_Tr
	movzx	ecx, BYTE PTR [eax]
	shl	esi, 8
	shl	edx, 8
	or	esi, ecx
	inc	eax
	mov	DWORD PTR _buf$[ebp], eax
$LN36@LzmaDec_Tr:
	movzx	eax, WORD PTR [edi+2]
	mov	ecx, edx
	shr	ecx, 11					; 0000000bH
	imul	ecx, eax
	cmp	esi, ecx
	jae	SHORT $LN34@LzmaDec_Tr

; 620  :           {
; 621  :             UPDATE_0_CHECK;
; 622  :             probLen = prob + LenMid + (posState << kLenNumMidBits);
; 623  :             offset = kLenNumLowSymbols;

	mov	eax, 8
	add	ebx, ebx
	mov	edx, ecx
	lea	ebx, DWORD PTR [edi+ebx*8+260]
	mov	DWORD PTR _offset$80353[ebp], eax

; 624  :             limit = 1 << kLenNumMidBits;

	mov	DWORD PTR _limit$80352[ebp], eax

; 625  :           }
; 626  :           else

	jmp	SHORT $LN33@LzmaDec_Tr
$LN34@LzmaDec_Tr:

; 627  :           {
; 628  :             UPDATE_1_CHECK;

	sub	edx, ecx
	sub	esi, ecx

; 629  :             probLen = prob + LenHigh;

	lea	ebx, DWORD PTR [edi+516]

; 630  :             offset = kLenNumLowSymbols + kLenNumMidSymbols;

	mov	DWORD PTR _offset$80353[ebp], 16	; 00000010H

; 631  :             limit = 1 << kLenNumHighBits;

	mov	DWORD PTR _limit$80352[ebp], 256	; 00000100H
$LN33@LzmaDec_Tr:

; 632  :           }
; 633  :         }
; 634  :         TREE_DECODE_CHECK(probLen, limit, len);

	mov	edi, 1
$LN114@LzmaDec_Tr:
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	edx, 16777216				; 01000000H
	jae	SHORT $LN29@LzmaDec_Tr
	cmp	eax, DWORD PTR _bufLimit$[ebp]
	jae	$LN99@LzmaDec_Tr
	movzx	ecx, BYTE PTR [eax]
	shl	esi, 8
	shl	edx, 8
	or	esi, ecx
	inc	eax
	mov	DWORD PTR _buf$[ebp], eax
$LN29@LzmaDec_Tr:
	movzx	eax, WORD PTR [ebx+edi*2]
	mov	ecx, edx
	shr	ecx, 11					; 0000000bH
	imul	ecx, eax
	cmp	esi, ecx
	jae	SHORT $LN27@LzmaDec_Tr
	mov	edx, ecx
	add	edi, edi
	jmp	SHORT $LN31@LzmaDec_Tr
$LN27@LzmaDec_Tr:
	sub	edx, ecx
	sub	esi, ecx
	lea	edi, DWORD PTR [edi+edi+1]
$LN31@LzmaDec_Tr:
	mov	ecx, DWORD PTR _limit$80352[ebp]
	cmp	edi, ecx
	jb	SHORT $LN114@LzmaDec_Tr

; 635  :         len += offset;

	mov	eax, DWORD PTR _offset$80353[ebp]
	sub	eax, ecx
	add	edi, eax

; 636  :       }
; 637  : 
; 638  :       if (state < 4)

	cmp	DWORD PTR _state$[ebp], 4
	jae	$LN112@LzmaDec_Tr

; 639  :       {
; 640  :         unsigned posSlot;
; 641  :         prob = probs + PosSlot +
; 642  :             ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) <<
; 643  :             kNumPosSlotBits);

	cmp	edi, 4
	jb	SHORT $LN92@LzmaDec_Tr
	mov	edi, 3
$LN92@LzmaDec_Tr:
	mov	eax, DWORD PTR _probs$[ebp]
	shl	edi, 7
	lea	ebx, DWORD PTR [edi+eax+864]

; 644  :         TREE_DECODE_CHECK(prob, 1 << kNumPosSlotBits, posSlot);

	mov	eax, DWORD PTR _buf$[ebp]
	mov	edi, 1
$LL24@LzmaDec_Tr:
	movzx	ecx, WORD PTR [ebx+edi*2]
	mov	DWORD PTR _ttt$80290[ebp], ecx
	cmp	edx, 16777216				; 01000000H
	jae	SHORT $LN21@LzmaDec_Tr
	cmp	eax, DWORD PTR _bufLimit$[ebp]
	jae	$LN99@LzmaDec_Tr
	movzx	ecx, BYTE PTR [eax]
	shl	esi, 8
	shl	edx, 8
	or	esi, ecx
	inc	eax
$LN21@LzmaDec_Tr:
	mov	ecx, edx
	shr	ecx, 11					; 0000000bH
	imul	ecx, DWORD PTR _ttt$80290[ebp]
	cmp	esi, ecx
	jae	SHORT $LN19@LzmaDec_Tr
	mov	edx, ecx
	add	edi, edi
	jmp	SHORT $LN23@LzmaDec_Tr
$LN19@LzmaDec_Tr:
	sub	edx, ecx
	sub	esi, ecx
	lea	edi, DWORD PTR [edi+edi+1]
$LN23@LzmaDec_Tr:
	cmp	edi, 64					; 00000040H
	jb	SHORT $LL24@LzmaDec_Tr
	sub	edi, 64					; 00000040H
	mov	DWORD PTR _buf$[ebp], eax

; 645  :         if (posSlot >= kStartPosModelIndex)

	cmp	edi, 4
	jb	$LN112@LzmaDec_Tr

; 646  :         {
; 647  :           int numDirectBits = ((posSlot >> 1) - 1);

	mov	ebx, edi
	shr	ebx, 1
	dec	ebx
	mov	DWORD PTR _numDirectBits$80384[ebp], ebx

; 648  : 
; 649  :           /* if (bufLimit - buf >= 8) return DUMMY_MATCH; */
; 650  : 
; 651  :           if (posSlot < kEndPosModelIndex)

	cmp	edi, 14					; 0000000eH
	jae	SHORT $LN16@LzmaDec_Tr

; 652  :           {
; 653  :             prob = probs + SpecPos + ((2 | (posSlot & 1)) << numDirectBits) - posSlot - 1;

	mov	eax, edi
	and	eax, 1
	or	eax, 2
	mov	ecx, ebx
	shl	eax, cl
	mov	ecx, DWORD PTR _probs$[ebp]
	sub	eax, edi
	lea	eax, DWORD PTR [ecx+eax*2+1374]
	mov	DWORD PTR _prob$80288[ebp], eax

; 654  :           }
; 655  :           else

	jmp	SHORT $LN15@LzmaDec_Tr
$LN16@LzmaDec_Tr:

; 656  :           {
; 657  :             numDirectBits -= kNumAlignBits;

	mov	ecx, DWORD PTR _bufLimit$[ebp]
	sub	ebx, 4
$LL14@LzmaDec_Tr:

; 658  :             do
; 659  :             {
; 660  :               NORMALIZE_CHECK

	cmp	edx, 16777216				; 01000000H
	jae	SHORT $LN11@LzmaDec_Tr
	cmp	eax, ecx
	jae	$LN99@LzmaDec_Tr
	movzx	edi, BYTE PTR [eax]
	shl	esi, 8
	shl	edx, 8
	or	esi, edi
	inc	eax
$LN11@LzmaDec_Tr:

; 661  :               range >>= 1;

	shr	edx, 1

; 662  :               code -= range & (((code - range) >> 31) - 1);

	mov	edi, esi
	sub	edi, edx
	shr	edi, 31					; 0000001fH
	dec	edi
	and	edi, edx
	sub	esi, edi

; 663  :               /* if (code >= range) code -= range; */
; 664  :             }
; 665  :             while (--numDirectBits != 0);

	dec	ebx
	jne	SHORT $LL14@LzmaDec_Tr

; 666  :             prob = probs + Align;

	mov	ecx, DWORD PTR _probs$[ebp]
	add	ecx, 1604				; 00000644H

; 667  :             numDirectBits = kNumAlignBits;

	mov	ebx, 4
	mov	DWORD PTR _buf$[ebp], eax
	mov	DWORD PTR _prob$80288[ebp], ecx
	mov	DWORD PTR _numDirectBits$80384[ebp], ebx
$LN15@LzmaDec_Tr:

; 668  :           }
; 669  :           {
; 670  :             unsigned i = 1;

	mov	eax, 1
	npad	2
$LL9@LzmaDec_Tr:

; 671  :             do
; 672  :             {
; 673  :               GET_BIT_CHECK(prob + i, i);

	mov	ecx, DWORD PTR _prob$80288[ebp]
	movzx	ecx, WORD PTR [ecx+eax*2]
	cmp	edx, 16777216				; 01000000H
	jae	SHORT $LN6@LzmaDec_Tr
	mov	edi, DWORD PTR _bufLimit$[ebp]
	cmp	DWORD PTR _buf$[ebp], edi
	jae	SHORT $LN99@LzmaDec_Tr
	mov	edi, DWORD PTR _buf$[ebp]
	movzx	ebx, BYTE PTR [edi]
	shl	esi, 8
	or	esi, ebx
	mov	ebx, DWORD PTR _numDirectBits$80384[ebp]
	shl	edx, 8
	inc	edi
	mov	DWORD PTR _buf$[ebp], edi
$LN6@LzmaDec_Tr:
	mov	edi, edx
	shr	edi, 11					; 0000000bH
	imul	edi, ecx
	cmp	esi, edi
	jae	SHORT $LN4@LzmaDec_Tr
	mov	edx, edi
	add	eax, eax
	jmp	SHORT $LN8@LzmaDec_Tr
$LN4@LzmaDec_Tr:
	sub	edx, edi
	sub	esi, edi
	lea	eax, DWORD PTR [eax+eax+1]
$LN8@LzmaDec_Tr:

; 674  :             }
; 675  :             while (--numDirectBits != 0);

	dec	ebx
	mov	DWORD PTR _numDirectBits$80384[ebp], ebx
	jne	SHORT $LL9@LzmaDec_Tr
$LN112@LzmaDec_Tr:
	mov	eax, DWORD PTR _res$[ebp]
$LN7@LzmaDec_Tr:

; 676  :           }
; 677  :         }
; 678  :       }
; 679  :     }
; 680  :   }
; 681  :   NORMALIZE_CHECK;

	cmp	edx, 16777216				; 01000000H
	jae	SHORT $LN85@LzmaDec_Tr
	mov	edx, DWORD PTR _bufLimit$[ebp]
	cmp	DWORD PTR _buf$[ebp], edx
	jb	SHORT $LN85@LzmaDec_Tr
$LN99@LzmaDec_Tr:
	xor	eax, eax
$LN85@LzmaDec_Tr:
	pop	edi
	pop	esi
	pop	ebx

; 682  :   return res;
; 683  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_LzmaDec_TryDummy ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _LzmaDec_InitRc
_TEXT	SEGMENT
_LzmaDec_InitRc PROC					; COMDAT
; _p$ = ecx
; _data$ = eax

; 688  :   p->code = ((UInt32)data[1] << 24) | ((UInt32)data[2] << 16) | ((UInt32)data[3] << 8) | ((UInt32)data[4]);

	movzx	edx, BYTE PTR [eax+1]
	push	esi
	movzx	esi, BYTE PTR [eax+2]
	shl	edx, 8
	or	edx, esi
	movzx	esi, BYTE PTR [eax+3]
	movzx	eax, BYTE PTR [eax+4]
	shl	edx, 8
	or	edx, esi
	shl	edx, 8
	or	edx, eax
	mov	DWORD PTR [ecx+32], edx

; 689  :   p->range = 0xFFFFFFFF;

	mov	DWORD PTR [ecx+28], -1

; 690  :   p->needFlush = 0;

	mov	DWORD PTR [ecx+76], 0
	pop	esi

; 691  : }

	ret	0
_LzmaDec_InitRc ENDP
_TEXT	ENDS
PUBLIC	_LzmaDec_InitDicAndState
; Function compile flags: /Ogtp
;	COMDAT _LzmaDec_InitDicAndState
_TEXT	SEGMENT
_p$ = 8							; size = 4
_initDic$ = 12						; size = 4
_initState$ = 16					; size = 4
_LzmaDec_InitDicAndState PROC				; COMDAT

; 694  : {

	push	ebp
	mov	ebp, esp

; 695  :   p->needFlush = 1;

	mov	eax, DWORD PTR _p$[ebp]

; 696  :   p->remainLen = 0;

	xor	ecx, ecx
	mov	edx, 1
	mov	DWORD PTR [eax+76], edx
	mov	DWORD PTR [eax+72], ecx

; 697  :   p->tempBufSize = 0;

	mov	DWORD PTR [eax+88], ecx

; 698  : 
; 699  :   if (initDic)

	cmp	DWORD PTR _initDic$[ebp], ecx
	je	SHORT $LN2@LzmaDec_In

; 700  :   {
; 701  :     p->processedPos = 0;

	mov	DWORD PTR [eax+44], ecx

; 702  :     p->checkDicSize = 0;

	mov	DWORD PTR [eax+48], ecx

; 703  :     p->needInitState = 1;

	mov	DWORD PTR [eax+80], edx
$LN2@LzmaDec_In:

; 704  :   }
; 705  :   if (initState)

	cmp	DWORD PTR _initState$[ebp], ecx
	je	SHORT $LN1@LzmaDec_In

; 706  :     p->needInitState = 1;

	mov	DWORD PTR [eax+80], edx
$LN1@LzmaDec_In:

; 707  : }

	pop	ebp
	ret	0
_LzmaDec_InitDicAndState ENDP
_TEXT	ENDS
PUBLIC	_LzmaDec_Init
; Function compile flags: /Ogtp
;	COMDAT _LzmaDec_Init
_TEXT	SEGMENT
_p$ = 8							; size = 4
_LzmaDec_Init PROC					; COMDAT

; 710  : {

	push	ebp
	mov	ebp, esp

; 711  :   p->dicPos = 0;

	mov	eax, DWORD PTR _p$[ebp]

; 712  :   LzmaDec_InitDicAndState(p, True, True);

	push	1
	push	1
	push	eax
	mov	DWORD PTR [eax+36], 0
	call	_LzmaDec_InitDicAndState
	add	esp, 12					; 0000000cH

; 713  : }

	pop	ebp
	ret	0
_LzmaDec_Init ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _LzmaDec_InitStateReal
_TEXT	SEGMENT
_LzmaDec_InitStateReal PROC				; COMDAT
; _p$ = edx

; 717  :   UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (p->prop.lc + p->prop.lp));

	mov	ecx, DWORD PTR [edx+4]
	add	ecx, DWORD PTR [edx]
	mov	eax, 768				; 00000300H
	shl	eax, cl
	push	edi

; 718  :   UInt32 i;
; 719  :   CLzmaProb *probs = p->probs;

	mov	edi, DWORD PTR [edx+16]
	add	eax, 1846				; 00000736H

; 720  :   for (i = 0; i < numProbs; i++)

	je	SHORT $LN3@LzmaDec_In@2

; 717  :   UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (p->prop.lc + p->prop.lp));

	mov	ecx, eax
	push	esi
	mov	eax, 1024				; 00000400H
	movzx	esi, ax
	mov	eax, esi
	shl	esi, 16					; 00000010H
	or	eax, esi
	shr	ecx, 1
	rep stosd
	adc	ecx, ecx
	rep stosw
	pop	esi
$LN3@LzmaDec_In@2:

; 721  :     probs[i] = kBitModelTotal >> 1;
; 722  :   p->reps[0] = p->reps[1] = p->reps[2] = p->reps[3] = 1;

	mov	eax, 1
	mov	DWORD PTR [edx+68], eax
	mov	DWORD PTR [edx+64], eax
	mov	DWORD PTR [edx+60], eax
	mov	DWORD PTR [edx+56], eax

; 723  :   p->state = 0;

	xor	eax, eax
	mov	DWORD PTR [edx+52], eax

; 724  :   p->needInitState = 0;

	mov	DWORD PTR [edx+80], eax
	pop	edi

; 725  : }

	ret	0
_LzmaDec_InitStateReal ENDP
_TEXT	ENDS
PUBLIC	_LzmaDec_DecodeToDic
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT _LzmaDec_DecodeToDic
_TEXT	SEGMENT
_lookAhead$80482 = -8					; size = 4
_inSize$ = -4						; size = 4
_checkEndMarkNow$80456 = 8				; size = 4
_p$ = 8							; size = 4
_dicLimit$ = 12						; size = 4
_src$ = 16						; size = 4
_srcLen$ = 20						; size = 4
_finishMode$ = 24					; size = 4
_status$ = 28						; size = 4
_LzmaDec_DecodeToDic PROC				; COMDAT

; 729  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 730  :   SizeT inSize = *srcLen;
; 731  :   (*srcLen) = 0;
; 732  :   LzmaDec_WriteRem(p, dicLimit);

	mov	eax, DWORD PTR _dicLimit$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _srcLen$[ebp]
	push	esi
	mov	esi, DWORD PTR _p$[ebp]
	push	edi
	mov	edi, DWORD PTR [ebx]
	push	eax
	mov	DWORD PTR _inSize$[ebp], edi
	mov	DWORD PTR [ebx], 0
	call	@LzmaDec_WriteRem@8

; 733  :   
; 734  :   *status = LZMA_STATUS_NOT_SPECIFIED;

	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [ecx], 0

; 735  : 
; 736  :   while (p->remainLen != kMatchSpecLenStart)

	cmp	DWORD PTR [esi+72], 274			; 00000112H
	jne	SHORT $LN29@LzmaDec_De
$LN28@LzmaDec_De:

; 841  :       }
; 842  :   }
; 843  :   if (p->code == 0)

	cmp	DWORD PTR [esi+32], 0
	jne	SHORT $LN1@LzmaDec_De

; 844  :     *status = LZMA_STATUS_FINISHED_WITH_MARK;

	mov	edx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [edx], 1
$LN1@LzmaDec_De:

; 845  :   return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;

	xor	eax, eax
	cmp	DWORD PTR [esi+32], eax
	pop	edi
	pop	esi
	setne	al
	pop	ebx

; 846  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LL48@LzmaDec_De:

; 735  : 
; 736  :   while (p->remainLen != kMatchSpecLenStart)

	mov	edi, DWORD PTR _inSize$[ebp]
	mov	ebx, DWORD PTR _srcLen$[ebp]
$LN29@LzmaDec_De:

; 737  :   {
; 738  :       int checkEndMarkNow;
; 739  : 
; 740  :       if (p->needFlush != 0)

	cmp	DWORD PTR [esi+76], 0
	je	SHORT $LN27@LzmaDec_De

; 741  :       {
; 742  :         for (; inSize > 0 && p->tempBufSize < RC_INIT_SIZE; (*srcLen)++, inSize--)

	test	edi, edi
	je	SHORT $LN24@LzmaDec_De
$LL51@LzmaDec_De:
	mov	ecx, DWORD PTR [esi+88]
	cmp	ecx, 5
	jae	SHORT $LN53@LzmaDec_De

; 743  :           p->tempBuf[p->tempBufSize++] = *src++;

	mov	eax, DWORD PTR _src$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx+esi+92], dl
	inc	DWORD PTR [esi+88]
	inc	DWORD PTR [ebx]
	inc	eax
	dec	edi
	mov	DWORD PTR _src$[ebp], eax
	jne	SHORT $LL51@LzmaDec_De
$LN53@LzmaDec_De:

; 741  :       {
; 742  :         for (; inSize > 0 && p->tempBufSize < RC_INIT_SIZE; (*srcLen)++, inSize--)

	mov	DWORD PTR _inSize$[ebp], edi
$LN24@LzmaDec_De:

; 744  :         if (p->tempBufSize < RC_INIT_SIZE)

	cmp	DWORD PTR [esi+88], 5
	jb	$LN35@LzmaDec_De

; 745  :         {
; 746  :           *status = LZMA_STATUS_NEEDS_MORE_INPUT;
; 747  :           return SZ_OK;
; 748  :         }
; 749  :         if (p->tempBuf[0] != 0)

	cmp	BYTE PTR [esi+92], 0
	lea	eax, DWORD PTR [esi+92]
	jne	$LN36@LzmaDec_De

; 750  :           return SZ_ERROR_DATA;
; 751  : 
; 752  :         LzmaDec_InitRc(p, p->tempBuf);

	mov	ecx, esi
	call	_LzmaDec_InitRc

; 753  :         p->tempBufSize = 0;

	mov	DWORD PTR [esi+88], 0
$LN27@LzmaDec_De:

; 754  :       }
; 755  : 
; 756  :       checkEndMarkNow = 0;
; 757  :       if (p->dicPos >= dicLimit)

	mov	eax, DWORD PTR _dicLimit$[ebp]
	mov	DWORD PTR _checkEndMarkNow$80456[ebp], 0
	cmp	DWORD PTR [esi+36], eax
	jb	SHORT $LN50@LzmaDec_De

; 758  :       {
; 759  :         if (p->remainLen == 0 && p->code == 0)

	mov	eax, DWORD PTR [esi+72]
	test	eax, eax
	jne	SHORT $LN20@LzmaDec_De
	cmp	DWORD PTR [esi+32], eax
	je	$LN37@LzmaDec_De
$LN20@LzmaDec_De:

; 763  :         }
; 764  :         if (finishMode == LZMA_FINISH_ANY)

	cmp	DWORD PTR _finishMode$[ebp], 0
	je	$LN38@LzmaDec_De

; 768  :         }
; 769  :         if (p->remainLen != 0)

	test	eax, eax
	jne	$LN39@LzmaDec_De

; 773  :         }
; 774  :         checkEndMarkNow = 1;

	mov	DWORD PTR _checkEndMarkNow$80456[ebp], 1
$LN50@LzmaDec_De:

; 775  :       }
; 776  : 
; 777  :       if (p->needInitState)

	cmp	DWORD PTR [esi+80], 0
	je	SHORT $LN17@LzmaDec_De

; 778  :         LzmaDec_InitStateReal(p);

	mov	edx, esi
	call	_LzmaDec_InitStateReal
$LN17@LzmaDec_De:

; 779  :   
; 780  :       if (p->tempBufSize == 0)

	mov	eax, DWORD PTR [esi+88]
	test	eax, eax
	jne	SHORT $LN16@LzmaDec_De

; 781  :       {
; 782  :         SizeT processed;
; 783  :         const Byte *bufLimit;
; 784  :         if (inSize < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)

	cmp	edi, 20					; 00000014H
	jb	SHORT $LN14@LzmaDec_De
	cmp	DWORD PTR _checkEndMarkNow$80456[ebp], eax
	jne	SHORT $LN14@LzmaDec_De

; 801  :         }
; 802  :         else
; 803  :           bufLimit = src + inSize - LZMA_REQUIRED_INPUT_MAX;

	mov	ebx, DWORD PTR _src$[ebp]
	lea	eax, DWORD PTR [edi+ebx-20]
	jmp	SHORT $LN11@LzmaDec_De
$LN14@LzmaDec_De:

; 785  :         {
; 786  :           int dummyRes = LzmaDec_TryDummy(p, src, inSize);

	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	mov	eax, edi
	mov	ecx, esi
	call	_LzmaDec_TryDummy
	add	esp, 4

; 787  :           if (dummyRes == DUMMY_ERROR)

	test	eax, eax
	je	$LN40@LzmaDec_De

; 794  :           }
; 795  :           if (checkEndMarkNow && dummyRes != DUMMY_MATCH)

	cmp	DWORD PTR _checkEndMarkNow$80456[ebp], 0
	je	SHORT $LN12@LzmaDec_De
	cmp	eax, 2
	jne	$LN41@LzmaDec_De
$LN12@LzmaDec_De:

; 799  :           }
; 800  :           bufLimit = src;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ebx, eax
$LN11@LzmaDec_De:

; 804  :         p->buf = src;
; 805  :         if (LzmaDec_DecodeReal2(p, dicLimit, bufLimit) != 0)

	mov	edi, DWORD PTR _dicLimit$[ebp]
	push	eax
	mov	eax, esi
	mov	DWORD PTR [esi+24], ebx
	call	@LzmaDec_DecodeReal2@12
	test	eax, eax
	jne	$LN36@LzmaDec_De

; 806  :           return SZ_ERROR_DATA;
; 807  :         processed = (SizeT)(p->buf - src);

	mov	eax, DWORD PTR [esi+24]

; 808  :         (*srcLen) += processed;

	mov	ecx, DWORD PTR _srcLen$[ebp]
	sub	eax, ebx
	add	DWORD PTR [ecx], eax

; 809  :         src += processed;

	add	ebx, eax
	mov	DWORD PTR _src$[ebp], ebx

; 810  :         inSize -= processed;
; 811  :       }
; 812  :       else

	jmp	$LN55@LzmaDec_De
$LN16@LzmaDec_De:

; 813  :       {
; 814  :         unsigned rem = p->tempBufSize, lookAhead = 0;

	mov	ebx, eax
	xor	edi, edi
	mov	DWORD PTR _lookAhead$80482[ebp], edi

; 815  :         while (rem < LZMA_REQUIRED_INPUT_MAX && lookAhead < inSize)

	cmp	ebx, 20					; 00000014H
	jae	SHORT $LN7@LzmaDec_De
	npad	7
$LL8@LzmaDec_De:
	cmp	edi, DWORD PTR _inSize$[ebp]
	jae	SHORT $LN54@LzmaDec_De

; 816  :           p->tempBuf[rem++] = src[lookAhead++];

	mov	edx, DWORD PTR _src$[ebp]
	mov	al, BYTE PTR [edi+edx]
	mov	BYTE PTR [ebx+esi+92], al
	inc	ebx
	inc	edi
	cmp	ebx, 20					; 00000014H
	jb	SHORT $LL8@LzmaDec_De
$LN54@LzmaDec_De:
	mov	DWORD PTR _lookAhead$80482[ebp], edi
$LN7@LzmaDec_De:

; 817  :         p->tempBufSize = rem;

	mov	DWORD PTR [esi+88], ebx

; 818  :         if (rem < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)

	cmp	ebx, 20					; 00000014H
	jb	SHORT $LN5@LzmaDec_De
	cmp	DWORD PTR _checkEndMarkNow$80456[ebp], 0
	je	SHORT $LN3@LzmaDec_De
$LN5@LzmaDec_De:

; 819  :         {
; 820  :           int dummyRes = LzmaDec_TryDummy(p, p->tempBuf, rem);

	lea	ecx, DWORD PTR [esi+92]
	push	ecx
	mov	eax, ebx
	mov	ecx, esi
	call	_LzmaDec_TryDummy
	add	esp, 4

; 821  :           if (dummyRes == DUMMY_ERROR)

	test	eax, eax
	je	$LN43@LzmaDec_De

; 826  :           }
; 827  :           if (checkEndMarkNow && dummyRes != DUMMY_MATCH)

	cmp	DWORD PTR _checkEndMarkNow$80456[ebp], 0
	je	SHORT $LN3@LzmaDec_De
	cmp	eax, 2
	jne	SHORT $LN39@LzmaDec_De
$LN3@LzmaDec_De:

; 828  :           {
; 829  :             *status = LZMA_STATUS_NOT_FINISHED;
; 830  :             return SZ_ERROR_DATA;
; 831  :           }
; 832  :         }
; 833  :         p->buf = p->tempBuf;
; 834  :         if (LzmaDec_DecodeReal2(p, dicLimit, p->buf) != 0)

	mov	edi, DWORD PTR _dicLimit$[ebp]
	lea	eax, DWORD PTR [esi+92]
	mov	DWORD PTR [esi+24], eax
	push	eax
	mov	eax, esi
	call	@LzmaDec_DecodeReal2@12
	test	eax, eax
	jne	SHORT $LN36@LzmaDec_De

; 835  :           return SZ_ERROR_DATA;
; 836  :         lookAhead -= (rem - (unsigned)(p->buf - p->tempBuf));

	mov	edx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR _lookAhead$80482[ebp]

; 837  :         (*srcLen) += lookAhead;

	mov	ecx, DWORD PTR _srcLen$[ebp]
	sub	edx, ebx
	sub	edx, esi
	lea	eax, DWORD PTR [eax+edx-92]
	add	DWORD PTR [ecx], eax

; 838  :         src += lookAhead;

	add	DWORD PTR _src$[ebp], eax

; 839  :         inSize -= lookAhead;
; 840  :         p->tempBufSize = 0;

	mov	DWORD PTR [esi+88], 0
$LN55@LzmaDec_De:

; 735  : 
; 736  :   while (p->remainLen != kMatchSpecLenStart)

	sub	DWORD PTR _inSize$[ebp], eax
	cmp	DWORD PTR [esi+72], 274			; 00000112H
	jne	$LL48@LzmaDec_De

; 828  :           {
; 829  :             *status = LZMA_STATUS_NOT_FINISHED;
; 830  :             return SZ_ERROR_DATA;
; 831  :           }
; 832  :         }
; 833  :         p->buf = p->tempBuf;
; 834  :         if (LzmaDec_DecodeReal2(p, dicLimit, p->buf) != 0)

	jmp	$LN28@LzmaDec_De
$LN37@LzmaDec_De:

; 760  :         {
; 761  :           *status = LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK;

	mov	edx, DWORD PTR _status$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [edx], 4

; 762  :           return SZ_OK;

	xor	eax, eax
	pop	ebx

; 846  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@LzmaDec_De:

; 765  :         {
; 766  :           *status = LZMA_STATUS_NOT_FINISHED;

	mov	eax, DWORD PTR _status$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], 2

; 767  :           return SZ_OK;

	xor	eax, eax
	pop	ebx

; 846  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@LzmaDec_De:

; 770  :         {
; 771  :           *status = LZMA_STATUS_NOT_FINISHED;

	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [ecx], 2
$LN36@LzmaDec_De:

; 772  :           return SZ_ERROR_DATA;

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx

; 846  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@LzmaDec_De:

; 788  :           {
; 789  :             memcpy(p->tempBuf, src, inSize);

	mov	edx, DWORD PTR _src$[ebp]
	push	edi
	push	edx
	lea	eax, DWORD PTR [esi+92]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 790  :             p->tempBufSize = (unsigned)inSize;

	mov	DWORD PTR [esi+88], edi

; 791  :             (*srcLen) += inSize;

	add	DWORD PTR [ebx], edi
$LN35@LzmaDec_De:

; 792  :             *status = LZMA_STATUS_NEEDS_MORE_INPUT;

	mov	ecx, DWORD PTR _status$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], 3

; 793  :             return SZ_OK;

	xor	eax, eax
	pop	ebx

; 846  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@LzmaDec_De:

; 796  :           {
; 797  :             *status = LZMA_STATUS_NOT_FINISHED;

	mov	edx, DWORD PTR _status$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [edx], 2

; 798  :             return SZ_ERROR_DATA;

	mov	eax, 1
	pop	ebx

; 846  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@LzmaDec_De:

; 822  :           {
; 823  :             (*srcLen) += lookAhead;

	mov	eax, DWORD PTR _srcLen$[ebp]
	add	DWORD PTR [eax], edi

; 824  :             *status = LZMA_STATUS_NEEDS_MORE_INPUT;

	mov	eax, DWORD PTR _status$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], 3

; 825  :             return SZ_OK;

	xor	eax, eax
	pop	ebx

; 846  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_LzmaDec_DecodeToDic ENDP
_TEXT	ENDS
PUBLIC	_LzmaDec_DecodeToBuf
; Function compile flags: /Ogtp
;	COMDAT _LzmaDec_DecodeToBuf
_TEXT	SEGMENT
_res$80518 = -12					; size = 4
_inSize$ = -8						; size = 4
_outSize$ = -4						; size = 4
_inSizeCur$80514 = 8					; size = 4
_p$ = 8							; size = 4
_dest$ = 12						; size = 4
_destLen$ = 16						; size = 4
_src$ = 20						; size = 4
_srcLen$ = 24						; size = 4
_finishMode$ = 28					; size = 4
_status$ = 32						; size = 4
_LzmaDec_DecodeToBuf PROC				; COMDAT

; 849  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 850  :   SizeT outSize = *destLen;

	mov	eax, DWORD PTR _destLen$[ebp]

; 851  :   SizeT inSize = *srcLen;

	mov	edx, DWORD PTR _srcLen$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ebx
	push	esi
	mov	esi, DWORD PTR [edx]
	push	edi

; 852  :   *srcLen = *destLen = 0;

	mov	edi, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _outSize$[ebp], ecx
	mov	DWORD PTR _inSize$[ebp], esi
	mov	DWORD PTR [edx], 0
	npad	8
$LL8@LzmaDec_De@2:

; 853  :   for (;;)
; 854  :   {
; 855  :     SizeT inSizeCur = inSize, outSizeCur, dicPos;

	mov	eax, DWORD PTR _inSize$[ebp]
	mov	DWORD PTR _inSizeCur$80514[ebp], eax

; 856  :     ELzmaFinishMode curFinishMode;
; 857  :     SRes res;
; 858  :     if (p->dicPos == p->dicBufSize)

	mov	eax, DWORD PTR [edi+40]
	cmp	DWORD PTR [edi+36], eax
	jne	SHORT $LN14@LzmaDec_De@2

; 859  :       p->dicPos = 0;

	mov	DWORD PTR [edi+36], 0
$LN14@LzmaDec_De@2:

; 860  :     dicPos = p->dicPos;

	mov	ebx, DWORD PTR [edi+36]

; 861  :     if (outSize > p->dicBufSize - dicPos)

	mov	edx, eax
	sub	edx, ebx
	cmp	ecx, edx
	jbe	SHORT $LN5@LzmaDec_De@2

; 862  :     {
; 863  :       outSizeCur = p->dicBufSize;
; 864  :       curFinishMode = LZMA_FINISH_ANY;

	xor	ecx, ecx

; 865  :     }
; 866  :     else

	jmp	SHORT $LN4@LzmaDec_De@2
$LN5@LzmaDec_De@2:

; 867  :     {
; 868  :       outSizeCur = dicPos + outSize;

	lea	eax, DWORD PTR [ebx+ecx]

; 869  :       curFinishMode = finishMode;

	mov	ecx, DWORD PTR _finishMode$[ebp]
$LN4@LzmaDec_De@2:

; 870  :     }
; 871  : 
; 872  :     res = LzmaDec_DecodeToDic(p, outSizeCur, src, &inSizeCur, curFinishMode, status);

	mov	edx, DWORD PTR _status$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	push	edx
	push	ecx
	lea	ecx, DWORD PTR _inSizeCur$80514[ebp]
	push	ecx
	push	esi
	push	eax
	push	edi
	call	_LzmaDec_DecodeToDic

; 873  :     src += inSizeCur;
; 874  :     inSize -= inSizeCur;
; 875  :     *srcLen += inSizeCur;

	mov	ecx, DWORD PTR _srcLen$[ebp]
	mov	DWORD PTR _res$80518[ebp], eax
	mov	eax, DWORD PTR _inSizeCur$80514[ebp]
	add	DWORD PTR [ecx], eax

; 876  :     outSizeCur = p->dicPos - dicPos;
; 877  :     memcpy(dest, p->dic + dicPos, outSizeCur);

	mov	edx, DWORD PTR [edi+20]
	sub	DWORD PTR _inSize$[ebp], eax
	add	esi, eax
	mov	DWORD PTR _src$[ebp], esi
	mov	esi, DWORD PTR [edi+36]
	sub	esi, ebx
	add	edx, ebx
	mov	ebx, DWORD PTR _dest$[ebp]
	push	esi
	push	edx
	push	ebx
	call	_memcpy

; 878  :     dest += outSizeCur;
; 879  :     outSize -= outSizeCur;
; 880  :     *destLen += outSizeCur;

	mov	eax, DWORD PTR _destLen$[ebp]
	add	DWORD PTR [eax], esi

; 881  :     if (res != 0)

	mov	eax, DWORD PTR _res$80518[ebp]
	sub	DWORD PTR _outSize$[ebp], esi
	add	ebx, esi
	add	esp, 36					; 00000024H
	mov	DWORD PTR _dest$[ebp], ebx
	test	eax, eax
	jne	SHORT $LN7@LzmaDec_De@2

; 882  :       return res;
; 883  :     if (outSizeCur == 0 || outSize == 0)

	test	esi, esi
	je	SHORT $LN13@LzmaDec_De@2
	cmp	DWORD PTR _outSize$[ebp], eax
	je	SHORT $LN13@LzmaDec_De@2

; 885  :   }

	mov	ecx, DWORD PTR _outSize$[ebp]
	jmp	$LL8@LzmaDec_De@2
$LN13@LzmaDec_De@2:

; 884  :       return SZ_OK;

	xor	eax, eax
$LN7@LzmaDec_De@2:
	pop	edi
	pop	esi
	pop	ebx

; 886  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_LzmaDec_DecodeToBuf ENDP
_TEXT	ENDS
PUBLIC	_LzmaDec_FreeProbs
; Function compile flags: /Ogtp
;	COMDAT _LzmaDec_FreeProbs
_TEXT	SEGMENT
_p$ = 8							; size = 4
_alloc$ = 12						; size = 4
_LzmaDec_FreeProbs PROC					; COMDAT

; 889  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 890  :   alloc->Free(alloc, p->probs);

	mov	esi, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [esi+16]
	push	eax
	mov	eax, DWORD PTR _alloc$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	eax
	call	ecx
	add	esp, 8

; 891  :   p->probs = 0;

	mov	DWORD PTR [esi+16], 0
	pop	esi

; 892  : }

	pop	ebp
	ret	0
_LzmaDec_FreeProbs ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _LzmaDec_FreeDict
_TEXT	SEGMENT
_LzmaDec_FreeDict PROC					; COMDAT
; _p$ = esi
; _alloc$ = eax

; 896  :   alloc->Free(alloc, p->dic);

	mov	ecx, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [eax+4]
	push	ecx
	push	eax
	call	edx
	add	esp, 8

; 897  :   p->dic = 0;

	mov	DWORD PTR [esi+20], 0

; 898  : }

	ret	0
_LzmaDec_FreeDict ENDP
_TEXT	ENDS
PUBLIC	_LzmaDec_Free
; Function compile flags: /Ogtp
;	COMDAT _LzmaDec_Free
_TEXT	SEGMENT
_p$ = 8							; size = 4
_alloc$ = 12						; size = 4
_LzmaDec_Free PROC					; COMDAT

; 901  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 902  :   LzmaDec_FreeProbs(p, alloc);

	mov	esi, DWORD PTR _p$[ebp]
	push	edi
	mov	edi, DWORD PTR _alloc$[ebp]
	push	edi
	push	esi
	call	_LzmaDec_FreeProbs
	add	esp, 8

; 903  :   LzmaDec_FreeDict(p, alloc);

	mov	eax, edi
	call	_LzmaDec_FreeDict
	pop	edi
	pop	esi

; 904  : }

	pop	ebp
	ret	0
_LzmaDec_Free ENDP
_TEXT	ENDS
PUBLIC	_LzmaProps_Decode
; Function compile flags: /Ogtp
;	COMDAT _LzmaProps_Decode
_TEXT	SEGMENT
_p$ = 8							; size = 4
_data$ = 12						; size = 4
_size$ = 16						; size = 4
_LzmaProps_Decode PROC					; COMDAT

; 907  : {

	push	ebp
	mov	ebp, esp

; 908  :   UInt32 dicSize;
; 909  :   Byte d;
; 910  :   
; 911  :   if (size < LZMA_PROPS_SIZE)

	cmp	DWORD PTR _size$[ebp], 5
	jae	SHORT $LN4@LzmaProps_
$LN7@LzmaProps_:

; 912  :     return SZ_ERROR_UNSUPPORTED;

	mov	eax, 4

; 930  : }

	pop	ebp
	ret	0
$LN4@LzmaProps_:

; 913  :   else
; 914  :     dicSize = data[1] | ((UInt32)data[2] << 8) | ((UInt32)data[3] << 16) | ((UInt32)data[4] << 24);

	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+4]
	movzx	ecx, BYTE PTR [edx+3]
	shl	eax, 8
	or	eax, ecx
	movzx	ecx, BYTE PTR [edx+2]
	shl	eax, 8
	or	eax, ecx
	movzx	ecx, BYTE PTR [edx+1]
	shl	eax, 8
	or	eax, ecx

; 915  :  
; 916  :   if (dicSize < LZMA_DIC_MIN)

	cmp	eax, 4096				; 00001000H
	jae	SHORT $LN2@LzmaProps_

; 917  :     dicSize = LZMA_DIC_MIN;

	mov	eax, 4096				; 00001000H
$LN2@LzmaProps_:

; 918  :   p->dicSize = dicSize;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 919  : 
; 920  :   d = data[0];

	mov	al, BYTE PTR [edx]

; 921  :   if (d >= (9 * 5 * 5))

	cmp	al, 225					; 000000e1H

; 922  :     return SZ_ERROR_UNSUPPORTED;

	jae	SHORT $LN7@LzmaProps_

; 923  : 
; 924  :   p->lc = d % 9;

	movzx	eax, al
	cdq
	push	esi
	mov	esi, 9
	idiv	esi

; 925  :   d /= 9;
; 926  :   p->pb = d / 5;

	mov	esi, 5
	movzx	eax, al
	mov	DWORD PTR [ecx], edx
	cdq
	idiv	esi
	pop	esi
	mov	DWORD PTR [ecx+8], eax

; 927  :   p->lp = d % 5;

	mov	DWORD PTR [ecx+4], edx

; 928  : 
; 929  :   return SZ_OK;

	xor	eax, eax

; 930  : }

	pop	ebp
	ret	0
_LzmaProps_Decode ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _LzmaDec_AllocateProbs2
_TEXT	SEGMENT
_LzmaDec_AllocateProbs2 PROC				; COMDAT
; _p$ = edi
; _propNew$ = eax
; _alloc$ = ebx

; 934  :   UInt32 numProbs = LzmaProps_GetNumProbs(propNew);

	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, 768				; 00000300H
	shl	esi, cl
	add	esi, 1846				; 00000736H

; 935  :   if (p->probs == 0 || numProbs != p->numProbs)

	cmp	DWORD PTR [edi+16], 0
	je	SHORT $LN2@LzmaDec_Al
	cmp	esi, DWORD PTR [edi+84]
	je	SHORT $LN1@LzmaDec_Al
$LN2@LzmaDec_Al:

; 936  :   {
; 937  :     LzmaDec_FreeProbs(p, alloc);

	push	ebx
	push	edi
	call	_LzmaDec_FreeProbs

; 938  :     p->probs = (CLzmaProb *)alloc->Alloc(alloc, numProbs * sizeof(CLzmaProb));

	mov	ecx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [esi+esi]
	push	eax
	push	ebx
	call	ecx
	add	esp, 16					; 00000010H
	mov	DWORD PTR [edi+16], eax

; 939  :     p->numProbs = numProbs;

	mov	DWORD PTR [edi+84], esi

; 940  :     if (p->probs == 0)

	test	eax, eax
	jne	SHORT $LN1@LzmaDec_Al

; 941  :       return SZ_ERROR_MEM;

	mov	eax, 2
	pop	esi

; 944  : }

	ret	0
$LN1@LzmaDec_Al:

; 942  :   }
; 943  :   return SZ_OK;

	xor	eax, eax
	pop	esi

; 944  : }

	ret	0
_LzmaDec_AllocateProbs2 ENDP
_TEXT	ENDS
PUBLIC	_LzmaDec_AllocateProbs
; Function compile flags: /Ogtp
;	COMDAT _LzmaDec_AllocateProbs
_TEXT	SEGMENT
_propNew$ = -16						; size = 16
_p$ = 8							; size = 4
_props$ = 12						; size = 4
_propsSize$ = 16					; size = 4
_alloc$ = 20						; size = 4
_LzmaDec_AllocateProbs PROC				; COMDAT

; 947  : {

	push	ebp
	mov	ebp, esp

; 948  :   CLzmaProps propNew;
; 949  :   RINOK(LzmaProps_Decode(&propNew, props, propsSize));

	mov	eax, DWORD PTR _propsSize$[ebp]
	mov	ecx, DWORD PTR _props$[ebp]
	sub	esp, 16					; 00000010H
	push	eax
	push	ecx
	lea	edx, DWORD PTR _propNew$[ebp]
	push	edx
	call	_LzmaProps_Decode
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@LzmaDec_Al@2

; 950  :   RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));

	push	ebx
	mov	ebx, DWORD PTR _alloc$[ebp]
	push	edi
	mov	edi, DWORD PTR _p$[ebp]
	lea	eax, DWORD PTR _propNew$[ebp]
	call	_LzmaDec_AllocateProbs2
	test	eax, eax
	jne	SHORT $LN5@LzmaDec_Al@2

; 951  :   p->prop = propNew;

	mov	eax, DWORD PTR _propNew$[ebp]
	mov	ecx, DWORD PTR _propNew$[ebp+4]
	mov	edx, DWORD PTR _propNew$[ebp+8]
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR _propNew$[ebp+12]
	mov	DWORD PTR [edi+4], ecx
	mov	DWORD PTR [edi+8], edx
	mov	DWORD PTR [edi+12], eax

; 952  :   return SZ_OK;

	xor	eax, eax
$LN5@LzmaDec_Al@2:
	pop	edi
	pop	ebx
$LN3@LzmaDec_Al@2:

; 953  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_LzmaDec_AllocateProbs ENDP
_TEXT	ENDS
PUBLIC	_LzmaDec_Allocate
; Function compile flags: /Ogtp
;	COMDAT _LzmaDec_Allocate
_TEXT	SEGMENT
_propNew$ = -16						; size = 16
_p$ = 8							; size = 4
_props$ = 12						; size = 4
_propsSize$ = 16					; size = 4
_alloc$ = 20						; size = 4
_LzmaDec_Allocate PROC					; COMDAT

; 956  : {

	push	ebp
	mov	ebp, esp

; 957  :   CLzmaProps propNew;
; 958  :   SizeT dicBufSize;
; 959  :   RINOK(LzmaProps_Decode(&propNew, props, propsSize));

	mov	eax, DWORD PTR _propsSize$[ebp]
	mov	ecx, DWORD PTR _props$[ebp]
	sub	esp, 16					; 00000010H
	push	eax
	push	ecx
	lea	edx, DWORD PTR _propNew$[ebp]
	push	edx
	call	_LzmaProps_Decode
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@LzmaDec_Al@3

; 960  :   RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));

	push	ebx
	mov	ebx, DWORD PTR _alloc$[ebp]
	push	esi
	mov	esi, DWORD PTR _p$[ebp]
	push	edi
	lea	eax, DWORD PTR _propNew$[ebp]
	mov	edi, esi
	call	_LzmaDec_AllocateProbs2
	test	eax, eax
	jne	SHORT $LN8@LzmaDec_Al@3

; 961  :   dicBufSize = propNew.dicSize;
; 962  :   if (p->dic == 0 || dicBufSize != p->dicBufSize)

	mov	edi, DWORD PTR _propNew$[ebp+12]
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN2@LzmaDec_Al@3
	cmp	edi, DWORD PTR [esi+40]
	je	SHORT $LN1@LzmaDec_Al@3
$LN2@LzmaDec_Al@3:

; 963  :   {
; 964  :     LzmaDec_FreeDict(p, alloc);

	mov	eax, ebx
	call	_LzmaDec_FreeDict

; 965  :     p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);

	mov	eax, DWORD PTR [ebx]
	push	edi
	push	ebx
	call	eax
	add	esp, 8
	mov	DWORD PTR [esi+20], eax

; 966  :     if (p->dic == 0)

	test	eax, eax
	jne	SHORT $LN1@LzmaDec_Al@3

; 967  :     {
; 968  :       LzmaDec_FreeProbs(p, alloc);

	push	ebx
	push	esi
	call	_LzmaDec_FreeProbs
	add	esp, 8
	pop	edi
	pop	esi

; 969  :       return SZ_ERROR_MEM;

	mov	eax, 2
	pop	ebx

; 975  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@LzmaDec_Al@3:

; 970  :     }
; 971  :   }
; 972  :   p->dicBufSize = dicBufSize;
; 973  :   p->prop = propNew;

	mov	ecx, DWORD PTR _propNew$[ebp]
	mov	edx, DWORD PTR _propNew$[ebp+4]
	mov	eax, DWORD PTR _propNew$[ebp+8]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], edx
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+40], edi
	mov	DWORD PTR [esi+12], edi

; 974  :   return SZ_OK;

	xor	eax, eax
$LN8@LzmaDec_Al@3:
	pop	edi
	pop	esi
	pop	ebx
$LN6@LzmaDec_Al@3:

; 975  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_LzmaDec_Allocate ENDP
_TEXT	ENDS
PUBLIC	_alloc$GSCopy$
PUBLIC	_status$GSCopy$
PUBLIC	_dest$GSCopy$
PUBLIC	_src$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_LzmaDecode
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtp
;	COMDAT _LzmaDecode
_TEXT	SEGMENT
_dest$GSCopy$ = -136					; size = 4
_src$GSCopy$ = -132					; size = 4
_alloc$GSCopy$ = -128					; size = 4
_status$GSCopy$ = -124					; size = 4
_outSize$ = -120					; size = 4
_p$ = -116						; size = 112
__$ArrayPad$ = -4					; size = 4
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_src$ = 16						; size = 4
_srcLen$ = 20						; size = 4
_propData$ = 24						; size = 4
_propSize$ = 28						; size = 4
_finishMode$ = 32					; size = 4
_status$ = 36						; size = 4
_alloc$ = 40						; size = 4
_LzmaDecode PROC					; COMDAT

; 980  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _status$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _destLen$[ebp]

; 981  :   CLzmaDec p;
; 982  :   SRes res;
; 983  :   SizeT inSize = *srcLen;
; 984  :   SizeT outSize = *destLen;

	mov	DWORD PTR _src$GSCopy$[ebp], ecx
	mov	ecx, DWORD PTR [ebx]
	push	esi
	mov	esi, DWORD PTR _srcLen$[ebp]
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR _outSize$[ebp], ecx

; 985  :   *srcLen = *destLen = 0;

	xor	ecx, ecx
	mov	DWORD PTR _dest$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _alloc$[ebp]
	mov	DWORD PTR [ebx], ecx
	mov	DWORD PTR _status$GSCopy$[ebp], edx
	mov	DWORD PTR _alloc$GSCopy$[ebp], eax
	mov	DWORD PTR [esi], ecx

; 986  :   if (inSize < RC_INIT_SIZE)

	cmp	edi, 5
	jae	SHORT $LN3@LzmaDecode

; 987  :     return SZ_ERROR_INPUT_EOF;

	pop	edi
	pop	esi
	lea	eax, DWORD PTR [ecx+6]
	pop	ebx

; 1007 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@LzmaDecode:

; 988  : 
; 989  :   LzmaDec_Construct(&p);
; 990  :   res = LzmaDec_AllocateProbs(&p, propData, propSize, alloc);

	mov	edx, DWORD PTR _propSize$[ebp]
	push	eax
	mov	eax, DWORD PTR _propData$[ebp]
	push	edx
	mov	DWORD PTR _p$[ebp+20], ecx
	mov	DWORD PTR _p$[ebp+16], ecx
	push	eax
	lea	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	_LzmaDec_AllocateProbs
	add	esp, 16					; 00000010H

; 991  :   if (res != 0)

	test	eax, eax

; 992  :     return res;

	jne	SHORT $LN4@LzmaDecode

; 993  :   p.dic = dest;

	mov	edx, DWORD PTR _dest$GSCopy$[ebp]

; 994  :   p.dicBufSize = outSize;

	mov	eax, DWORD PTR _outSize$[ebp]

; 995  : 
; 996  :   LzmaDec_Init(&p);

	lea	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	DWORD PTR _p$[ebp+20], edx
	mov	DWORD PTR _p$[ebp+40], eax
	call	_LzmaDec_Init

; 997  :   
; 998  :   *srcLen = inSize;
; 999  :   res = LzmaDec_DecodeToDic(&p, outSize, src, srcLen, finishMode, status);

	mov	edx, DWORD PTR _finishMode$[ebp]
	mov	eax, DWORD PTR _src$GSCopy$[ebp]
	mov	ecx, DWORD PTR _outSize$[ebp]
	mov	DWORD PTR [esi], edi
	mov	edi, DWORD PTR _status$GSCopy$[ebp]
	push	edi
	push	edx
	push	esi
	push	eax
	push	ecx
	lea	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_LzmaDec_DecodeToDic
	mov	esi, eax
	add	esp, 28					; 0000001cH

; 1000 : 
; 1001 :   if (res == SZ_OK && *status == LZMA_STATUS_NEEDS_MORE_INPUT)

	test	esi, esi
	jne	SHORT $LN1@LzmaDecode
	cmp	DWORD PTR [edi], 3
	jne	SHORT $LN1@LzmaDecode

; 1002 :     res = SZ_ERROR_INPUT_EOF;

	lea	esi, DWORD PTR [eax+6]
$LN1@LzmaDecode:

; 1003 : 
; 1004 :   (*destLen) = p.dicPos;
; 1005 :   LzmaDec_FreeProbs(&p, alloc);

	mov	ecx, DWORD PTR _alloc$GSCopy$[ebp]
	mov	eax, DWORD PTR _p$[ebp+36]
	push	ecx
	lea	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	DWORD PTR [ebx], eax
	call	_LzmaDec_FreeProbs
	add	esp, 8

; 1006 :   return res;

	mov	eax, esi
$LN4@LzmaDecode:

; 1007 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_LzmaDecode ENDP
_TEXT	ENDS
END
