; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	H:\MinGW\home\other\meditor2\Libs\7z\Archive\7z\7zDec.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0M@DDCEBJEG@?6ERROR?3?5?$CFs?6?$AA@	; `string'
PUBLIC	_PrintError
EXTRN	_printf:PROC
;	COMDAT ??_C@_0M@DDCEBJEG@?6ERROR?3?5?$CFs?6?$AA@
; File h:\mingw\home\other\meditor2\libs\7z\archive\7z\7zdec.c
CONST	SEGMENT
??_C@_0M@DDCEBJEG@?6ERROR?3?5?$CFs?6?$AA@ DB 0aH, 'ERROR: %s', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _PrintError
_TEXT	SEGMENT
_sz$ = 8						; size = 4
_PrintError PROC					; COMDAT

; 88   : {

	push	ebp
	mov	ebp, esp

; 89   : 	printf("\nERROR: %s\n", sz);

	mov	eax, DWORD PTR _sz$[ebp]
	push	eax
	push	OFFSET ??_C@_0M@DDCEBJEG@?6ERROR?3?5?$CFs?6?$AA@
	call	_printf
	add	esp, 8

; 90   : }

	pop	ebp
	ret	0
_PrintError ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@JNKOPALL@can?5not?5write?5output?5file?$AA@ ; `string'
PUBLIC	??_C@_0BK@CGEAHMLA@can?5not?5close?5output?5file?$AA@ ; `string'
PUBLIC	??_C@_0BJ@PLLNBKKJ@can?5not?5open?5output?5file?$AA@ ; `string'
PUBLIC	??_C@_01KICIPPFI@?2?$AA@			; `string'
PUBLIC	??_C@_0BI@BPMIDDPE@can?5not?5open?5input?5file?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_Un7zFile
EXTRN	_SzArEx_Free:PROC
EXTRN	_File_Close:PROC
EXTRN	_File_Write:PROC
EXTRN	_OutFile_Open:PROC
EXTRN	_SzAr_Extract:PROC
EXTRN	__imp__CreateDirectoryA@8:PROC
EXTRN	_strrchr:PROC
EXTRN	_strcpy_s:PROC
EXTRN	__imp__SetCurrentDirectoryA@4:PROC
EXTRN	_strcat_s:PROC
EXTRN	__imp__GetCurrentDirectoryA@8:PROC
EXTRN	_SzArEx_Open:PROC
EXTRN	_SzArEx_Init:PROC
EXTRN	@CrcGenerateTable@0:PROC
EXTRN	_SzFreeTemp:PROC
EXTRN	_SzAllocTemp:PROC
EXTRN	_SzFree:PROC
EXTRN	_SzAlloc:PROC
EXTRN	_LookToRead_Init:PROC
EXTRN	_LookToRead_CreateVTable:PROC
EXTRN	_FileInStream_CreateVTable:PROC
EXTRN	_InFile_Open:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
;	COMDAT ??_C@_0BK@JNKOPALL@can?5not?5write?5output?5file?$AA@
CONST	SEGMENT
??_C@_0BK@JNKOPALL@can?5not?5write?5output?5file?$AA@ DB 'can not write o'
	DB	'utput file', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CGEAHMLA@can?5not?5close?5output?5file?$AA@
CONST	SEGMENT
??_C@_0BK@CGEAHMLA@can?5not?5close?5output?5file?$AA@ DB 'can not close o'
	DB	'utput file', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PLLNBKKJ@can?5not?5open?5output?5file?$AA@
CONST	SEGMENT
??_C@_0BJ@PLLNBKKJ@can?5not?5open?5output?5file?$AA@ DB 'can not open out'
	DB	'put file', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2?$AA@
CONST	SEGMENT
??_C@_01KICIPPFI@?2?$AA@ DB '\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BPMIDDPE@can?5not?5open?5input?5file?$AA@
CONST	SEGMENT
??_C@_0BI@BPMIDDPE@can?5not?5open?5input?5file?$AA@ DB 'can not open inpu'
	DB	't file', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _Un7zFile
_TEXT	SEGMENT
_db$ = -17340						; size = 64
_archiveStream$ = -17276				; size = 12
_allocTempImp$ = -17264					; size = 8
_offset$81854 = -17256					; size = 4
_outBufferSize$81839 = -17252				; size = 4
_blockIndex$81837 = -17248				; size = 4
_outSizeProcessed$81855 = -17244			; size = 4
_outFile$81866 = -17240					; size = 4
tv347 = -17236						; size = 4
_processedSize$81867 = -17232				; size = 4
_i$81836 = -17228					; size = 4
_allocImp$ = -17224					; size = 8
_outBuffer$81838 = -17216				; size = 4
_res$ = -17212						; size = 4
_lookStream$ = -17208					; size = 16412
_sz7zPath$81843 = -796					; size = 261
_szCurPath$81841 = -532					; size = 261
_szNewPath$81842 = -268					; size = 261
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_DecPath$ = 12						; size = 4
_ex_filename$ = 16					; size = 4
_Un7zFile PROC						; COMDAT

; 94   : {

	push	ebp
	mov	ebp, esp
	mov	eax, 17340				; 000043bcH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _filename$[ebp]
	push	esi
	mov	esi, DWORD PTR _DecPath$[ebp]

; 95   : 	CFileInStream archiveStream;
; 96   : 	CLookToRead lookStream;
; 97   : 	CSzArEx db;
; 98   : 	SRes res;
; 99   : 	ISzAlloc allocImp;
; 100  : 	ISzAlloc allocTempImp;
; 101  : 
; 102  : 	if (InFile_Open(&archiveStream.file, filename))

	push	eax
	lea	eax, DWORD PTR _archiveStream$[ebp+8]
	push	eax
	call	_InFile_Open
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@Un7zFile

; 103  : 	{
; 104  : 		PrintError("can not open input file");

	push	OFFSET ??_C@_0BI@BPMIDDPE@can?5not?5open?5input?5file?$AA@
	call	_PrintError
	add	esp, 4

; 105  : 		return 0;

	xor	eax, eax
	pop	esi

; 222  : 	if (res == SZ_OK)
; 223  : 		return 1;
; 224  : 	return 0;
; 225  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@Un7zFile:

; 106  : 	}
; 107  : 
; 108  : 	FileInStream_CreateVTable(&archiveStream);

	lea	ecx, DWORD PTR _archiveStream$[ebp]
	push	edi
	push	ecx
	call	_FileInStream_CreateVTable

; 109  : 	LookToRead_CreateVTable(&lookStream, False);

	lea	edx, DWORD PTR _lookStream$[ebp]
	push	0
	push	edx
	call	_LookToRead_CreateVTable

; 110  : 
; 111  : 	lookStream.realStream = &archiveStream.s;
; 112  : 	LookToRead_Init(&lookStream);

	lea	ecx, DWORD PTR _lookStream$[ebp]
	lea	eax, DWORD PTR _archiveStream$[ebp]
	push	ecx
	mov	DWORD PTR _lookStream$[ebp+16], eax
	call	_LookToRead_Init
	add	esp, 16					; 00000010H

; 113  : 
; 114  : 	allocImp.Alloc = SzAlloc;

	mov	DWORD PTR _allocImp$[ebp], OFFSET _SzAlloc

; 115  : 	allocImp.Free = SzFree;

	mov	DWORD PTR _allocImp$[ebp+4], OFFSET _SzFree

; 116  : 
; 117  : 	allocTempImp.Alloc = SzAllocTemp;

	mov	DWORD PTR _allocTempImp$[ebp], OFFSET _SzAllocTemp

; 118  : 	allocTempImp.Free = SzFreeTemp;

	mov	DWORD PTR _allocTempImp$[ebp+4], OFFSET _SzFreeTemp

; 119  : 
; 120  : 	CrcGenerateTable();

	call	@CrcGenerateTable@0

; 121  : 
; 122  : 	SzArEx_Init(&db);

	lea	edx, DWORD PTR _db$[ebp]
	push	edx
	call	_SzArEx_Init

; 123  : 	res = SzArEx_Open(&db, &lookStream.s, &allocImp, &allocTempImp);

	lea	eax, DWORD PTR _allocTempImp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _allocImp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lookStream$[ebp]
	push	edx
	lea	eax, DWORD PTR _db$[ebp]
	push	eax
	call	_SzArEx_Open
	mov	edi, eax
	add	esp, 20					; 00000014H
	mov	DWORD PTR _res$[ebp], edi

; 124  : 	if (res == SZ_OK)

	test	edi, edi
	jne	$LN24@Un7zFile

; 125  : 	{
; 126  : 		UInt32 i;
; 127  : 
; 128  : 		/*
; 129  : 		if you need cache, use these 3 variables.
; 130  : 		if you use external function, you can make these variable as static.
; 131  : 		*/
; 132  : 		UInt32 blockIndex = 0xFFFFFFFF; /* it can have any value before first call (if outBuffer = 0) */

	mov	DWORD PTR _blockIndex$81837[ebp], -1

; 133  : 		Byte *outBuffer = 0; /* it must be 0 before first call for each new archive. */

	mov	DWORD PTR _outBuffer$81838[ebp], eax

; 134  : 		size_t outBufferSize = 0;  /* it can have any value before first call (if outBuffer = 0) */

	mov	DWORD PTR _outBufferSize$81839[ebp], eax

; 135  : 
; 136  : 
; 137  : 		char  *dir, szCurPath[MAX_PATH + 1], szNewPath[MAX_PATH + 1], sz7zPath[MAX_PATH + 1];
; 138  : 
; 139  : 		if(DecPath == NULL)

	test	esi, esi
	jne	SHORT $LN23@Un7zFile

; 140  : 		{
; 141  : 			GetCurrentDirectory(MAX_PATH,szCurPath);

	lea	ecx, DWORD PTR _szCurPath$81841[ebp]
	push	ecx
	push	260					; 00000104H
	call	DWORD PTR __imp__GetCurrentDirectoryA@8

; 142  : 			strcat_s(szCurPath,MAX_PATH,"\\");

	push	OFFSET ??_C@_01KICIPPFI@?2?$AA@
	lea	edx, DWORD PTR _szCurPath$81841[ebp]
	push	260					; 00000104H
	push	edx
	call	_strcat_s
	jmp	SHORT $LN44@Un7zFile
$LN23@Un7zFile:

; 143  : 		}
; 144  : 		else if(ex_filename != NULL)

	cmp	DWORD PTR _ex_filename$[ebp], 0

; 145  : 			SetCurrentDirectory(DecPath);

	push	esi
	je	SHORT $LN21@Un7zFile
	call	DWORD PTR __imp__SetCurrentDirectoryA@4

; 146  : 		else

	jmp	SHORT $LN20@Un7zFile
$LN21@Un7zFile:

; 147  : 			strcpy_s(szCurPath,MAX_PATH,DecPath);

	lea	eax, DWORD PTR _szCurPath$81841[ebp]
	push	260					; 00000104H
	push	eax
	call	_strcpy_s
$LN44@Un7zFile:
	add	esp, 12					; 0000000cH
$LN20@Un7zFile:

; 148  : 
; 149  : 		for (i = 0; i < db.db.NumFiles; i++)

	xor	esi, esi
	mov	DWORD PTR _i$81836[ebp], esi
	cmp	DWORD PTR _db$[ebp+28], esi
	jbe	$LN42@Un7zFile
	xor	edi, edi
	mov	DWORD PTR tv347[ebp], edi
	npad	10
$LL19@Un7zFile:
	add	edi, DWORD PTR _db$[ebp+16]

; 150  : 		{
; 151  : 			size_t offset;
; 152  : 			size_t outSizeProcessed;
; 153  : 			CSzFileItem *f = db.db.Files + i;
; 154  : 			if (f->IsDir)

	cmp	BYTE PTR [edi+25], 0
	jne	$LN18@Un7zFile

; 155  : 				continue;
; 156  : 
; 157  : 			if(ex_filename != NULL)

	mov	eax, DWORD PTR _ex_filename$[ebp]
	test	eax, eax
	je	SHORT $LN15@Un7zFile

; 158  : 			{
; 159  : 				if(strcmp(ex_filename,f->Name) != 0)

	mov	ecx, DWORD PTR [edi+16]
	npad	6
$LL37@Un7zFile:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN38@Un7zFile
	test	dl, dl
	je	SHORT $LN39@Un7zFile
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN38@Un7zFile
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL37@Un7zFile
$LN39@Un7zFile:
	xor	eax, eax
	jmp	SHORT $LN40@Un7zFile
$LN38@Un7zFile:
	sbb	eax, eax
	sbb	eax, -1
$LN40@Un7zFile:
	test	eax, eax
	jne	$LN18@Un7zFile

; 160  : 					continue;
; 161  : 			}
; 162  : 			else

	jmp	SHORT $LN13@Un7zFile
$LN15@Un7zFile:

; 163  : 			{
; 164  : 				strcpy_s(szNewPath,MAX_PATH,szCurPath);

	lea	edx, DWORD PTR _szCurPath$81841[ebp]
	push	edx
	lea	eax, DWORD PTR _szNewPath$81842[ebp]
	push	260					; 00000104H
	push	eax
	call	_strcpy_s

; 165  : 				strcpy_s(sz7zPath , MAX_PATH,f->Name);

	mov	ecx, DWORD PTR [edi+16]
	push	ecx
	lea	edx, DWORD PTR _sz7zPath$81843[ebp]
	push	260					; 00000104H
	push	edx
	call	_strcpy_s

; 166  : 				dir = strrchr(sz7zPath, '/');

	lea	eax, DWORD PTR _sz7zPath$81843[ebp]
	push	47					; 0000002fH
	push	eax
	call	_strrchr
	add	esp, 32					; 00000020H

; 167  : 				if(dir)

	test	eax, eax
	je	SHORT $LN12@Un7zFile

; 168  : 				{
; 169  : 					dir[0] = 0;
; 170  : 					strcat_s(szNewPath,MAX_PATH,sz7zPath);

	lea	ecx, DWORD PTR _sz7zPath$81843[ebp]
	push	ecx
	lea	edx, DWORD PTR _szNewPath$81842[ebp]
	push	260					; 00000104H
	push	edx
	mov	BYTE PTR [eax], 0
	call	_strcat_s
	add	esp, 12					; 0000000cH

; 171  : 					CreateDirectory(szNewPath,NULL);

	push	0
	lea	eax, DWORD PTR _szNewPath$81842[ebp]
	push	eax
	call	DWORD PTR __imp__CreateDirectoryA@8
$LN12@Un7zFile:

; 172  : 				}
; 173  : 				SetCurrentDirectory(szNewPath);

	lea	ecx, DWORD PTR _szNewPath$81842[ebp]
	push	ecx
	call	DWORD PTR __imp__SetCurrentDirectoryA@4
$LN13@Un7zFile:

; 174  : 			}
; 175  : 			res = SzAr_Extract(&db, &lookStream.s, i,
; 176  : 				&blockIndex, &outBuffer, &outBufferSize, 
; 177  : 				&offset, &outSizeProcessed, 
; 178  : 				&allocImp, &allocTempImp);

	lea	edx, DWORD PTR _allocTempImp$[ebp]
	push	edx
	lea	eax, DWORD PTR _allocImp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _outSizeProcessed$81855[ebp]
	push	ecx
	lea	edx, DWORD PTR _offset$81854[ebp]
	push	edx
	lea	eax, DWORD PTR _outBufferSize$81839[ebp]
	push	eax
	lea	ecx, DWORD PTR _outBuffer$81838[ebp]
	push	ecx
	lea	edx, DWORD PTR _blockIndex$81837[ebp]
	push	edx
	push	esi
	lea	eax, DWORD PTR _lookStream$[ebp]
	push	eax
	lea	ecx, DWORD PTR _db$[ebp]
	push	ecx
	call	_SzAr_Extract
	add	esp, 40					; 00000028H
	mov	DWORD PTR _res$[ebp], eax

; 179  : 			if (res != SZ_OK)

	test	eax, eax
	jne	$LN42@Un7zFile

; 180  : 				break;	
; 181  : 			else
; 182  : 			{
; 183  : 				CSzFile outFile;
; 184  : 				size_t processedSize;
; 185  : 				char *fileName = f->Name;

	mov	esi, DWORD PTR [edi+16]

; 186  : 				size_t nameLen = strlen(f->Name);

	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
	npad	7
$LL41@Un7zFile:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL41@Un7zFile
	sub	eax, edx

; 187  : 				for (; nameLen > 0; nameLen--)

	je	SHORT $LN7@Un7zFile

; 180  : 				break;	
; 181  : 			else
; 182  : 			{
; 183  : 				CSzFile outFile;
; 184  : 				size_t processedSize;
; 185  : 				char *fileName = f->Name;

	mov	edx, esi
	lea	ecx, DWORD PTR [edx+eax-1]
$LL9@Un7zFile:

; 188  : 				{
; 189  : 					if (f->Name[nameLen - 1] == '/')

	cmp	BYTE PTR [ecx], 47			; 0000002fH
	je	SHORT $LN30@Un7zFile

; 187  : 				for (; nameLen > 0; nameLen--)

	dec	ecx
	dec	eax
	jne	SHORT $LL9@Un7zFile

; 207  : 					break;
; 208  : 				}
; 209  : 				if (File_Close(&outFile))

	jmp	SHORT $LN7@Un7zFile
$LN30@Un7zFile:

; 190  : 					{
; 191  : 						fileName = f->Name + nameLen;

	lea	esi, DWORD PTR [edx+eax]
$LN7@Un7zFile:

; 192  : 						break;
; 193  : 					}
; 194  : 				}
; 195  : 				if (OutFile_Open(&outFile, fileName))

	lea	edx, DWORD PTR _outFile$81866[ebp]
	push	esi
	push	edx
	call	_OutFile_Open
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN32@Un7zFile

; 200  : 				}
; 201  : 				processedSize = outSizeProcessed;

	mov	eax, DWORD PTR _outSizeProcessed$81855[ebp]
	mov	DWORD PTR _processedSize$81867[ebp], eax

; 202  : 				if (File_Write(&outFile, outBuffer + offset, &processedSize) != 0 ||
; 203  : 					processedSize != outSizeProcessed)

	mov	eax, DWORD PTR _offset$81854[ebp]
	add	eax, DWORD PTR _outBuffer$81838[ebp]
	lea	ecx, DWORD PTR _processedSize$81867[ebp]
	push	ecx
	push	eax
	lea	ecx, DWORD PTR _outFile$81866[ebp]
	push	ecx
	call	_File_Write
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@Un7zFile
	mov	edx, DWORD PTR _processedSize$81867[ebp]
	cmp	edx, DWORD PTR _outSizeProcessed$81855[ebp]
	jne	SHORT $LN3@Un7zFile

; 207  : 					break;
; 208  : 				}
; 209  : 				if (File_Close(&outFile))

	lea	eax, DWORD PTR _outFile$81866[ebp]
	push	eax
	call	_File_Close
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN34@Un7zFile
	mov	esi, DWORD PTR _i$81836[ebp]
$LN18@Un7zFile:

; 148  : 
; 149  : 		for (i = 0; i < db.db.NumFiles; i++)

	mov	edi, DWORD PTR tv347[ebp]
	inc	esi
	add	edi, 32					; 00000020H
	mov	DWORD PTR _i$81836[ebp], esi
	mov	DWORD PTR tv347[ebp], edi
	cmp	esi, DWORD PTR _db$[ebp+28]
	jb	$LL19@Un7zFile

; 207  : 					break;
; 208  : 				}
; 209  : 				if (File_Close(&outFile))

	jmp	SHORT $LN42@Un7zFile
$LN32@Un7zFile:

; 196  : 				{
; 197  : 					PrintError("can not open output file");

	push	OFFSET ??_C@_0BJ@PLLNBKKJ@can?5not?5open?5output?5file?$AA@

; 198  : 					res = SZ_ERROR_FAIL;
; 199  : 					break;

	jmp	SHORT $LN45@Un7zFile
$LN34@Un7zFile:

; 210  : 				{
; 211  : 					PrintError("can not close output file");

	push	OFFSET ??_C@_0BK@CGEAHMLA@can?5not?5close?5output?5file?$AA@

; 212  : 					res = SZ_ERROR_FAIL;
; 213  : 					break;

	jmp	SHORT $LN45@Un7zFile
$LN3@Un7zFile:

; 204  : 				{
; 205  : 					PrintError("can not write output file");

	push	OFFSET ??_C@_0BK@JNKOPALL@can?5not?5write?5output?5file?$AA@
$LN45@Un7zFile:
	call	_PrintError
	add	esp, 4

; 206  : 					res = SZ_ERROR_FAIL;

	mov	DWORD PTR _res$[ebp], 11		; 0000000bH
$LN42@Un7zFile:

; 214  : 				}
; 215  : 			}
; 216  : 		}
; 217  : 		IAlloc_Free(&allocImp, outBuffer);

	mov	ecx, DWORD PTR _outBuffer$81838[ebp]
	push	ecx
	lea	edx, DWORD PTR _allocImp$[ebp]
	push	edx
	call	DWORD PTR _allocImp$[ebp+4]
	mov	edi, DWORD PTR _res$[ebp]
	add	esp, 8
$LN24@Un7zFile:

; 218  : 	}
; 219  : 	SzArEx_Free(&db, &allocImp);

	lea	eax, DWORD PTR _allocImp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _db$[ebp]
	push	ecx
	call	_SzArEx_Free

; 220  : 
; 221  : 	File_Close(&archiveStream.file);

	lea	edx, DWORD PTR _archiveStream$[ebp+8]
	push	edx
	call	_File_Close

; 222  : 	if (res == SZ_OK)
; 223  : 		return 1;
; 224  : 	return 0;
; 225  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 12					; 0000000cH
	xor	eax, eax
	test	edi, edi
	sete	al
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Un7zFile ENDP
_TEXT	ENDS
END
