; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	H:\MinGW\home\other\meditor2\Libs\7z\Archive\7z\7zItem.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_SzCoderInfo_Init
EXTRN	_Buf_Init:PROC
; Function compile flags: /Ogtp
; File h:\mingw\home\other\meditor2\libs\7z\archive\7z\7zitem.c
;	COMDAT _SzCoderInfo_Init
_TEXT	SEGMENT
_p$ = 8							; size = 4
_SzCoderInfo_Init PROC					; COMDAT

; 7    : {

	push	ebp
	mov	ebp, esp

; 8    :   Buf_Init(&p->Props);

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	_Buf_Init
	add	esp, 4

; 9    : }

	pop	ebp
	ret	0
_SzCoderInfo_Init ENDP
_TEXT	ENDS
PUBLIC	_SzCoderInfo_Free
EXTRN	_Buf_Free:PROC
; Function compile flags: /Ogtp
;	COMDAT _SzCoderInfo_Free
_TEXT	SEGMENT
_p$ = 8							; size = 4
_alloc$ = 12						; size = 4
_SzCoderInfo_Free PROC					; COMDAT

; 12   : {

	push	ebp
	mov	ebp, esp

; 13   :   Buf_Free(&p->Props, alloc);

	mov	eax, DWORD PTR _alloc$[ebp]
	push	esi
	mov	esi, DWORD PTR _p$[ebp]
	push	eax
	lea	ecx, DWORD PTR [esi+16]
	push	ecx
	call	_Buf_Free

; 14   :   SzCoderInfo_Init(p);

	push	esi
	call	_SzCoderInfo_Init
	add	esp, 12					; 0000000cH
	pop	esi

; 15   : }

	pop	ebp
	ret	0
_SzCoderInfo_Free ENDP
_TEXT	ENDS
PUBLIC	_SzFolder_Init
; Function compile flags: /Ogtp
;	COMDAT _SzFolder_Init
_TEXT	SEGMENT
_p$ = 8							; size = 4
_SzFolder_Init PROC					; COMDAT

; 18   : {

	push	ebp
	mov	ebp, esp

; 19   :   p->Coders = 0;

	mov	eax, DWORD PTR _p$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 20   :   p->BindPairs = 0;

	mov	DWORD PTR [eax+4], ecx

; 21   :   p->PackStreams = 0;

	mov	DWORD PTR [eax+8], ecx

; 22   :   p->UnpackSizes = 0;

	mov	DWORD PTR [eax+12], ecx

; 23   :   p->NumCoders = 0;

	mov	DWORD PTR [eax+16], ecx

; 24   :   p->NumBindPairs = 0;

	mov	DWORD PTR [eax+20], ecx

; 25   :   p->NumPackStreams = 0;

	mov	DWORD PTR [eax+24], ecx

; 26   :   p->UnpackCRCDefined = 0;

	mov	DWORD PTR [eax+28], ecx

; 27   :   p->UnpackCRC = 0;

	mov	DWORD PTR [eax+32], ecx

; 28   :   p->NumUnpackStreams = 0;

	mov	DWORD PTR [eax+36], ecx

; 29   : }

	pop	ebp
	ret	0
_SzFolder_Init ENDP
_TEXT	ENDS
PUBLIC	_SzFolder_Free
; Function compile flags: /Ogtp
;	COMDAT _SzFolder_Free
_TEXT	SEGMENT
_p$ = 8							; size = 4
_alloc$ = 12						; size = 4
_SzFolder_Free PROC					; COMDAT

; 32   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 33   :   UInt32 i;
; 34   :   if (p->Coders)

	mov	esi, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [esi], 0
	push	edi
	je	SHORT $LN1@SzFolder_F

; 35   :     for (i = 0; i < p->NumCoders; i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+16], edi
	jbe	SHORT $LN1@SzFolder_F
	push	ebx
	xor	ebx, ebx
$LL3@SzFolder_F:

; 36   :       SzCoderInfo_Free(&p->Coders[i], alloc);

	mov	eax, DWORD PTR _alloc$[ebp]
	mov	ecx, DWORD PTR [esi]
	push	eax
	add	ecx, ebx
	push	ecx
	call	_SzCoderInfo_Free
	inc	edi
	add	esp, 8
	add	ebx, 24					; 00000018H
	cmp	edi, DWORD PTR [esi+16]
	jb	SHORT $LL3@SzFolder_F
	pop	ebx
$LN1@SzFolder_F:

; 37   :   IAlloc_Free(alloc, p->Coders);

	mov	edx, DWORD PTR [esi]
	mov	edi, DWORD PTR _alloc$[ebp]
	mov	eax, DWORD PTR [edi+4]
	push	edx
	push	edi
	call	eax

; 38   :   IAlloc_Free(alloc, p->BindPairs);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [edi+4]
	push	ecx
	push	edi
	call	edx

; 39   :   IAlloc_Free(alloc, p->PackStreams);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [edi+4]
	push	eax
	push	edi
	call	ecx

; 40   :   IAlloc_Free(alloc, p->UnpackSizes);

	mov	edx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [edi+4]
	push	edx
	push	edi
	call	eax

; 41   :   SzFolder_Init(p);

	push	esi
	call	_SzFolder_Init
	add	esp, 36					; 00000024H
	pop	edi
	pop	esi

; 42   : }

	pop	ebp
	ret	0
_SzFolder_Free ENDP
_TEXT	ENDS
PUBLIC	_SzFolder_GetNumOutStreams
; Function compile flags: /Ogtp
;	COMDAT _SzFolder_GetNumOutStreams
_TEXT	SEGMENT
_result$ = -4						; size = 4
_p$ = 8							; size = 4
_SzFolder_GetNumOutStreams PROC				; COMDAT

; 45   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 46   :   UInt32 result = 0;
; 47   :   UInt32 i;
; 48   :   for (i = 0; i < p->NumCoders; i++)

	mov	eax, DWORD PTR _p$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR [eax+16]
	xor	ecx, ecx
	xor	edx, edx
	xor	esi, esi
	xor	ebx, ebx
	mov	DWORD PTR _result$[ebp], ecx
	cmp	edi, 2
	jl	SHORT $LC9@SzFolder_G

; 49   :     result += p->Coders[i].NumOutStreams;

	mov	eax, DWORD PTR [eax]
	lea	ecx, DWORD PTR [edi-2]
	shr	ecx, 1
	add	eax, 28					; 0000001cH
	inc	ecx
	lea	ebx, DWORD PTR [ecx+ecx]
	npad	5
$LL10@SzFolder_G:
	add	edx, DWORD PTR [eax-24]
	add	esi, DWORD PTR [eax]
	add	eax, 48					; 00000030H
	dec	ecx
	jne	SHORT $LL10@SzFolder_G
	mov	ecx, DWORD PTR _result$[ebp]
	mov	eax, DWORD PTR _p$[ebp]
$LC9@SzFolder_G:

; 46   :   UInt32 result = 0;
; 47   :   UInt32 i;
; 48   :   for (i = 0; i < p->NumCoders; i++)

	cmp	ebx, edi
	jae	SHORT $LN8@SzFolder_G

; 49   :     result += p->Coders[i].NumOutStreams;

	mov	eax, DWORD PTR [eax]
	lea	ecx, DWORD PTR [ebx+ebx*2]
	mov	ecx, DWORD PTR [eax+ecx*8+4]
$LN8@SzFolder_G:
	pop	edi
	lea	eax, DWORD PTR [esi+edx]
	pop	esi
	add	eax, ecx
	pop	ebx

; 50   :   return result;
; 51   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SzFolder_GetNumOutStreams ENDP
_TEXT	ENDS
PUBLIC	_SzFolder_FindBindPairForInStream
; Function compile flags: /Ogtp
;	COMDAT _SzFolder_FindBindPairForInStream
_TEXT	SEGMENT
_p$ = 8							; size = 4
_inStreamIndex$ = 12					; size = 4
_SzFolder_FindBindPairForInStream PROC			; COMDAT

; 54   : {

	push	ebp
	mov	ebp, esp

; 55   :   UInt32 i;
; 56   :   for (i = 0; i < p->NumBindPairs; i++)

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	xor	eax, eax
	push	esi
	test	edx, edx
	je	SHORT $LN2@SzFolder_F@2
	mov	ecx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR _inStreamIndex$[ebp]
$LL4@SzFolder_F@2:

; 57   :     if (p->BindPairs[i].InIndex == inStreamIndex)

	cmp	DWORD PTR [ecx], esi
	je	SHORT $LN5@SzFolder_F@2

; 55   :   UInt32 i;
; 56   :   for (i = 0; i < p->NumBindPairs; i++)

	inc	eax
	add	ecx, 8
	cmp	eax, edx
	jb	SHORT $LL4@SzFolder_F@2
$LN2@SzFolder_F@2:

; 58   :       return i;
; 59   :   return -1;

	or	eax, -1
$LN5@SzFolder_F@2:
	pop	esi

; 60   : }

	pop	ebp
	ret	0
_SzFolder_FindBindPairForInStream ENDP
_TEXT	ENDS
PUBLIC	_SzFolder_FindBindPairForOutStream
; Function compile flags: /Ogtp
;	COMDAT _SzFolder_FindBindPairForOutStream
_TEXT	SEGMENT
_p$ = 8							; size = 4
_outStreamIndex$ = 12					; size = 4
_SzFolder_FindBindPairForOutStream PROC			; COMDAT

; 64   : {

	push	ebp
	mov	ebp, esp

; 65   :   UInt32 i;
; 66   :   for (i = 0; i < p->NumBindPairs; i++)

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	xor	eax, eax
	push	esi
	test	edx, edx
	je	SHORT $LN2@SzFolder_F@3
	mov	ecx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR _outStreamIndex$[ebp]
	add	ecx, 4
	npad	7
$LL4@SzFolder_F@3:

; 67   :     if (p->BindPairs[i].OutIndex == outStreamIndex)

	cmp	DWORD PTR [ecx], esi
	je	SHORT $LN5@SzFolder_F@3

; 65   :   UInt32 i;
; 66   :   for (i = 0; i < p->NumBindPairs; i++)

	inc	eax
	add	ecx, 8
	cmp	eax, edx
	jb	SHORT $LL4@SzFolder_F@3
$LN2@SzFolder_F@3:

; 68   :       return i;
; 69   :   return -1;

	or	eax, -1
$LN5@SzFolder_F@3:
	pop	esi

; 70   : }

	pop	ebp
	ret	0
_SzFolder_FindBindPairForOutStream ENDP
_TEXT	ENDS
PUBLIC	_SzFolder_GetUnpackSize
; Function compile flags: /Ogtp
;	COMDAT _SzFolder_GetUnpackSize
_TEXT	SEGMENT
_p$ = 8							; size = 4
_SzFolder_GetUnpackSize PROC				; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 74   :   int i = (int)SzFolder_GetNumOutStreams(p);

	mov	edi, DWORD PTR _p$[ebp]
	push	edi
	call	_SzFolder_GetNumOutStreams
	mov	esi, eax
	add	esp, 4

; 75   :   if (i == 0)

	test	esi, esi

; 76   :     return 0;

	je	SHORT $LN2@SzFolder_G@2

; 77   :   for (i--; i >= 0; i--)

	dec	esi
	js	SHORT $LN2@SzFolder_G@2
	npad	6
$LL4@SzFolder_G@2:

; 78   :     if (SzFolder_FindBindPairForOutStream(p, i) < 0)

	push	esi
	push	edi
	call	_SzFolder_FindBindPairForOutStream
	add	esp, 8
	test	eax, eax
	js	SHORT $LN9@SzFolder_G@2

; 77   :   for (i--; i >= 0; i--)

	dec	esi
	jns	SHORT $LL4@SzFolder_G@2
$LN2@SzFolder_G@2:
	pop	edi

; 80   :   /* throw 1; */
; 81   :   return 0;

	xor	eax, eax
	xor	edx, edx
	pop	esi

; 82   : }

	pop	ebp
	ret	0
$LN9@SzFolder_G@2:

; 79   :       return p->UnpackSizes[i];

	mov	ecx, DWORD PTR [edi+12]
	mov	eax, DWORD PTR [ecx+esi*8]
	mov	edx, DWORD PTR [ecx+esi*8+4]
	pop	edi
	pop	esi

; 82   : }

	pop	ebp
	ret	0
_SzFolder_GetUnpackSize ENDP
_TEXT	ENDS
PUBLIC	_SzFile_Init
; Function compile flags: /Ogtp
;	COMDAT _SzFile_Init
_TEXT	SEGMENT
_p$ = 8							; size = 4
_SzFile_Init PROC					; COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp

; 86   :   p->HasStream = 1;

	mov	eax, DWORD PTR _p$[ebp]

; 87   :   p->IsDir = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax+24], 1

; 88   :   p->IsAnti = 0;
; 89   :   p->FileCRCDefined = 0;
; 90   :   p->MTimeDefined = 0;

	mov	BYTE PTR [eax+28], cl

; 91   :   p->Name = 0;

	mov	DWORD PTR [eax+16], ecx

; 92   : }

	pop	ebp
	ret	0
_SzFile_Init ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _SzFile_Free
_TEXT	SEGMENT
_SzFile_Free PROC					; COMDAT
; _p$ = esi
; _alloc$ = eax

; 96   :   IAlloc_Free(alloc, p->Name);

	mov	ecx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [eax+4]
	push	ecx
	push	eax
	call	edx

; 97   :   SzFile_Init(p);

	push	esi
	call	_SzFile_Init
	add	esp, 12					; 0000000cH

; 98   : }

	ret	0
_SzFile_Free ENDP
_TEXT	ENDS
PUBLIC	_SzAr_Init
; Function compile flags: /Ogtp
;	COMDAT _SzAr_Init
_TEXT	SEGMENT
_p$ = 8							; size = 4
_SzAr_Init PROC						; COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp

; 102  :   p->PackSizes = 0;

	mov	eax, DWORD PTR _p$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 103  :   p->PackCRCsDefined = 0;

	mov	DWORD PTR [eax+4], ecx

; 104  :   p->PackCRCs = 0;

	mov	DWORD PTR [eax+8], ecx

; 105  :   p->Folders = 0;

	mov	DWORD PTR [eax+12], ecx

; 106  :   p->Files = 0;

	mov	DWORD PTR [eax+16], ecx

; 107  :   p->NumPackStreams = 0;

	mov	DWORD PTR [eax+20], ecx

; 108  :   p->NumFolders = 0;

	mov	DWORD PTR [eax+24], ecx

; 109  :   p->NumFiles = 0;

	mov	DWORD PTR [eax+28], ecx

; 110  : }

	pop	ebp
	ret	0
_SzAr_Init ENDP
_TEXT	ENDS
PUBLIC	_SzAr_Free
; Function compile flags: /Ogtp
;	COMDAT _SzAr_Free
_TEXT	SEGMENT
tv215 = 8						; size = 4
tv206 = 8						; size = 4
_p$ = 8							; size = 4
_i$ = 12						; size = 4
_alloc$ = 12						; size = 4
_SzAr_Free PROC						; COMDAT

; 113  : {

	push	ebp
	mov	ebp, esp
	push	ebx

; 114  :   UInt32 i;
; 115  :   if (p->Folders)

	mov	ebx, DWORD PTR _alloc$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _p$[ebp]
	xor	esi, esi
	cmp	DWORD PTR [edi+12], esi
	je	SHORT $LN5@SzAr_Free

; 116  :     for (i = 0; i < p->NumFolders; i++)

	cmp	DWORD PTR [edi+24], esi
	jbe	SHORT $LN5@SzAr_Free
	mov	DWORD PTR tv206[ebp], esi
	npad	5
$LL16@SzAr_Free:

; 117  :       SzFolder_Free(&p->Folders[i], alloc);

	mov	eax, DWORD PTR [edi+12]
	add	eax, DWORD PTR tv206[ebp]
	push	ebx
	push	eax
	call	_SzFolder_Free
	add	DWORD PTR tv206[ebp], 40		; 00000028H
	inc	esi
	add	esp, 8
	cmp	esi, DWORD PTR [edi+24]
	jb	SHORT $LL16@SzAr_Free

; 116  :     for (i = 0; i < p->NumFolders; i++)

	xor	esi, esi
$LN5@SzAr_Free:

; 118  :   if (p->Files)

	cmp	DWORD PTR [edi+16], esi
	je	SHORT $LN1@SzAr_Free

; 119  :     for (i = 0; i < p->NumFiles; i++)

	mov	DWORD PTR _i$[ebp], esi
	cmp	DWORD PTR [edi+28], esi
	jbe	SHORT $LN1@SzAr_Free
	mov	DWORD PTR tv215[ebp], esi
	npad	4
$LL15@SzAr_Free:
	mov	esi, DWORD PTR [edi+16]
	add	esi, DWORD PTR tv215[ebp]

; 120  :       SzFile_Free(&p->Files[i], alloc);

	mov	eax, ebx
	call	_SzFile_Free
	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv215[ebp], 32		; 00000020H
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [edi+28]
	jb	SHORT $LL15@SzAr_Free
$LN1@SzAr_Free:

; 121  :   IAlloc_Free(alloc, p->PackSizes);

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ebx+4]
	push	ecx
	push	ebx
	call	edx

; 122  :   IAlloc_Free(alloc, p->PackCRCsDefined);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [ebx+4]
	push	eax
	push	ebx
	call	ecx

; 123  :   IAlloc_Free(alloc, p->PackCRCs);

	mov	edx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [ebx+4]
	push	edx
	push	ebx
	call	eax

; 124  :   IAlloc_Free(alloc, p->Folders);

	mov	ecx, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [ebx+4]
	push	ecx
	push	ebx
	call	edx

; 125  :   IAlloc_Free(alloc, p->Files);

	mov	eax, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR [ebx+4]
	push	eax
	push	ebx
	call	ecx

; 126  :   SzAr_Init(p);

	push	edi
	call	_SzAr_Init
	add	esp, 44					; 0000002cH
	pop	edi
	pop	esi
	pop	ebx

; 127  : }

	pop	ebp
	ret	0
_SzAr_Free ENDP
_TEXT	ENDS
END
