; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	H:\MinGW\home\other\meditor2\Libs\7z\Archive\7z\7zIn.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_kUtf8Limits
_DATA	SEGMENT
_kUtf8Limits DB	0c0H
	DB	0e0H
	DB	0f0H
	DB	0f8H
	DB	0fcH
_DATA	ENDS
PUBLIC	_SzArEx_Init
EXTRN	_SzAr_Init:PROC
; Function compile flags: /Ogtp
; File h:\mingw\home\other\meditor2\libs\7z\archive\7z\7zin.c
;	COMDAT _SzArEx_Init
_TEXT	SEGMENT
_p$ = 8							; size = 4
_SzArEx_Init PROC					; COMDAT

; 16   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 17   :   SzAr_Init(&p->db);

	mov	esi, DWORD PTR _p$[ebp]
	push	esi
	call	_SzAr_Init
	add	esp, 4

; 18   :   p->FolderStartPackStreamIndex = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+48], eax

; 19   :   p->PackStreamStartPositions = 0;

	mov	DWORD PTR [esi+52], eax

; 20   :   p->FolderStartFileIndex = 0;

	mov	DWORD PTR [esi+56], eax

; 21   :   p->FileIndexToFolderIndexMap = 0;

	mov	DWORD PTR [esi+60], eax
	pop	esi

; 22   : }

	pop	ebp
	ret	0
_SzArEx_Init ENDP
_TEXT	ENDS
PUBLIC	_SzArEx_Free
EXTRN	_SzAr_Free:PROC
; Function compile flags: /Ogtp
;	COMDAT _SzArEx_Free
_TEXT	SEGMENT
_p$ = 8							; size = 4
_alloc$ = 12						; size = 4
_SzArEx_Free PROC					; COMDAT

; 25   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 26   :   IAlloc_Free(alloc, p->FolderStartPackStreamIndex);

	mov	esi, DWORD PTR _alloc$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edi+48]
	push	eax
	push	esi
	call	ecx

; 27   :   IAlloc_Free(alloc, p->PackStreamStartPositions);

	mov	edx, DWORD PTR [edi+52]
	mov	eax, DWORD PTR [esi+4]
	push	edx
	push	esi
	call	eax

; 28   :   IAlloc_Free(alloc, p->FolderStartFileIndex);

	mov	ecx, DWORD PTR [edi+56]
	mov	edx, DWORD PTR [esi+4]
	push	ecx
	push	esi
	call	edx

; 29   :   IAlloc_Free(alloc, p->FileIndexToFolderIndexMap);

	mov	eax, DWORD PTR [edi+60]
	mov	ecx, DWORD PTR [esi+4]
	push	eax
	push	esi
	call	ecx

; 30   :   SzAr_Free(&p->db, alloc);

	push	esi
	push	edi
	call	_SzAr_Free

; 31   :   SzArEx_Init(p);

	push	edi
	call	_SzArEx_Init
	add	esp, 44					; 0000002cH
	pop	edi
	pop	esi

; 32   : }

	pop	ebp
	ret	0
_SzArEx_Free ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _SzArEx_Fill
_TEXT	SEGMENT
_startPosSize$ = -16					; size = 8
_emptyStream$80145 = -12				; size = 4
tv503 = -8						; size = 4
_indexInFolder$ = -4					; size = 4
_alloc$ = 8						; size = 4
_SzArEx_Fill PROC					; COMDAT
; _p$ = esi

; 57   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 58   :   UInt32 startPos = 0;
; 59   :   UInt64 startPosSize = 0;
; 60   :   UInt32 i;
; 61   :   UInt32 folderIndex = 0;
; 62   :   UInt32 indexInFolder = 0;
; 63   :   MY_ALLOC(UInt32, p->FolderStartPackStreamIndex, p->db.NumFolders, alloc);

	mov	eax, DWORD PTR [esi+24]
	push	ebx
	xor	edx, edx
	push	edi
	xor	ebx, ebx
	xor	edi, edi
	mov	DWORD PTR _startPosSize$[ebp], edx
	mov	DWORD PTR _startPosSize$[ebp+4], edx
	mov	DWORD PTR _indexInFolder$[ebp], edx
	cmp	eax, edx
	jne	SHORT $LN29@SzArEx_Fil
	mov	DWORD PTR [esi+48], edx
	jmp	SHORT $LN27@SzArEx_Fil
$LN29@SzArEx_Fil:
	add	eax, eax
	add	eax, eax
	push	eax
	mov	eax, DWORD PTR _alloc$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	ecx
	add	esp, 8
	mov	DWORD PTR [esi+48], eax
	test	eax, eax
	jne	SHORT $LN41@SzArEx_Fil
$LN48@SzArEx_Fil:
	pop	edi
	mov	eax, 2
	pop	ebx

; 117  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@SzArEx_Fil:

; 58   :   UInt32 startPos = 0;
; 59   :   UInt64 startPosSize = 0;
; 60   :   UInt32 i;
; 61   :   UInt32 folderIndex = 0;
; 62   :   UInt32 indexInFolder = 0;
; 63   :   MY_ALLOC(UInt32, p->FolderStartPackStreamIndex, p->db.NumFolders, alloc);

	mov	edx, DWORD PTR _startPosSize$[ebp]
$LN27@SzArEx_Fil:

; 64   :   for (i = 0; i < p->db.NumFolders; i++)

	xor	eax, eax
	cmp	DWORD PTR [esi+24], eax
	jbe	SHORT $LN24@SzArEx_Fil
	xor	ecx, ecx
$LL26@SzArEx_Fil:

; 65   :   {
; 66   :     p->FolderStartPackStreamIndex[i] = startPos;

	mov	edx, DWORD PTR [esi+48]
	mov	DWORD PTR [edx+eax*4], ebx

; 67   :     startPos += p->db.Folders[i].NumPackStreams;

	mov	edx, DWORD PTR [esi+12]
	add	ebx, DWORD PTR [ecx+edx+24]
	inc	eax
	add	ecx, 40					; 00000028H
	cmp	eax, DWORD PTR [esi+24]
	jb	SHORT $LL26@SzArEx_Fil

; 64   :   for (i = 0; i < p->db.NumFolders; i++)

	mov	edx, DWORD PTR _startPosSize$[ebp]
$LN24@SzArEx_Fil:

; 68   :   }
; 69   : 
; 70   :   MY_ALLOC(UInt64, p->PackStreamStartPositions, p->db.NumPackStreams, alloc);

	mov	eax, DWORD PTR [esi+20]
	mov	ebx, DWORD PTR _alloc$[ebp]
	test	eax, eax
	jne	SHORT $LN23@SzArEx_Fil
	mov	DWORD PTR [esi+52], edi
	jmp	SHORT $LN21@SzArEx_Fil
$LN23@SzArEx_Fil:
	mov	ecx, DWORD PTR [ebx]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ebx
	call	ecx
	add	esp, 8
	mov	DWORD PTR [esi+52], eax
	test	eax, eax
	je	SHORT $LN48@SzArEx_Fil
	mov	edx, DWORD PTR _startPosSize$[ebp]
$LN21@SzArEx_Fil:

; 71   : 
; 72   :   for (i = 0; i < p->db.NumPackStreams; i++)

	xor	eax, eax
	cmp	DWORD PTR [esi+20], eax
	jbe	SHORT $LN18@SzArEx_Fil
	npad	7
$LL20@SzArEx_Fil:

; 73   :   {
; 74   :     p->PackStreamStartPositions[i] = startPosSize;

	mov	ecx, DWORD PTR [esi+52]
	mov	ebx, DWORD PTR _startPosSize$[ebp+4]
	mov	DWORD PTR [ecx+eax*8], edx
	mov	DWORD PTR [ecx+eax*8+4], ebx

; 75   :     startPosSize += p->db.PackSizes[i];

	mov	ecx, DWORD PTR [esi]
	add	edx, DWORD PTR [ecx+eax*8]
	mov	ecx, DWORD PTR [ecx+eax*8+4]
	adc	DWORD PTR _startPosSize$[ebp+4], ecx
	inc	eax
	cmp	eax, DWORD PTR [esi+20]
	jb	SHORT $LL20@SzArEx_Fil

; 71   : 
; 72   :   for (i = 0; i < p->db.NumPackStreams; i++)

	mov	ebx, DWORD PTR _alloc$[ebp]
$LN18@SzArEx_Fil:

; 76   :   }
; 77   : 
; 78   :   MY_ALLOC(UInt32, p->FolderStartFileIndex, p->db.NumFolders, alloc);

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	jne	SHORT $LN17@SzArEx_Fil
	mov	DWORD PTR [esi+56], edi
	jmp	SHORT $LN43@SzArEx_Fil
$LN17@SzArEx_Fil:
	lea	edx, DWORD PTR [eax*4]
	mov	eax, DWORD PTR [ebx]
	push	edx
	push	ebx
	call	eax
	add	esp, 8
	mov	DWORD PTR [esi+56], eax
	test	eax, eax
	je	$LN48@SzArEx_Fil
$LN43@SzArEx_Fil:

; 79   :   MY_ALLOC(UInt32, p->FileIndexToFolderIndexMap, p->db.NumFiles, alloc);

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	jne	SHORT $LN14@SzArEx_Fil
	mov	DWORD PTR [esi+60], edi
	jmp	SHORT $LN44@SzArEx_Fil
$LN14@SzArEx_Fil:
	mov	edx, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [eax*4]
	push	ecx
	push	ebx
	call	edx
	add	esp, 8
	mov	DWORD PTR [esi+60], eax
	test	eax, eax
	je	$LN48@SzArEx_Fil
$LN44@SzArEx_Fil:

; 80   : 
; 81   :   for (i = 0; i < p->db.NumFiles; i++)

	xor	ecx, ecx
	cmp	DWORD PTR [esi+28], ecx
	jbe	$LN9@SzArEx_Fil
	mov	DWORD PTR tv503[ebp], ecx
	npad	2
$LL11@SzArEx_Fil:

; 82   :   {
; 83   :     CSzFileItem *file = p->db.Files + i;
; 84   :     int emptyStream = !file->HasStream;

	mov	eax, DWORD PTR [esi+16]
	mov	ebx, DWORD PTR tv503[ebp]
	xor	edx, edx
	cmp	BYTE PTR [eax+ebx+24], dl
	sete	dl
	mov	eax, edx

; 85   :     if (emptyStream && indexInFolder == 0)

	mov	edx, DWORD PTR _indexInFolder$[ebp]
	mov	DWORD PTR _emptyStream$80145[ebp], eax
	test	eax, eax
	je	SHORT $LN8@SzArEx_Fil
	test	edx, edx
	jne	SHORT $LN37@SzArEx_Fil

; 86   :     {
; 87   :       p->FileIndexToFolderIndexMap[i] = (UInt32)-1;

	mov	eax, DWORD PTR [esi+60]
	mov	DWORD PTR [eax+ecx*4], -1

; 88   :       continue;

	jmp	SHORT $LN10@SzArEx_Fil
$LN8@SzArEx_Fil:

; 89   :     }
; 90   :     if (indexInFolder == 0)

	test	edx, edx
	jne	SHORT $LN37@SzArEx_Fil
	lea	eax, DWORD PTR [edi+edi*4]
	add	eax, eax
	add	eax, eax
	add	eax, eax
$LL6@SzArEx_Fil:

; 91   :     {
; 92   :       /*
; 93   :       v3.13 incorrectly worked with empty folders
; 94   :       v4.07: Loop for skipping empty folders
; 95   :       */
; 96   :       for (;;)
; 97   :       {
; 98   :         if (folderIndex >= p->db.NumFolders)

	cmp	edi, DWORD PTR [esi+24]
	jae	SHORT $LN36@SzArEx_Fil

; 100  :         p->FolderStartFileIndex[folderIndex] = i;

	mov	ebx, DWORD PTR [esi+56]
	mov	DWORD PTR [ebx+edi*4], ecx

; 101  :         if (p->db.Folders[folderIndex].NumUnpackStreams != 0)

	mov	ebx, DWORD PTR [esi+12]
	cmp	DWORD PTR [ebx+eax+36], 0
	jne	SHORT $LN47@SzArEx_Fil

; 102  :           break;
; 103  :         folderIndex++;

	inc	edi
	add	eax, 40					; 00000028H

; 104  :       }

	jmp	SHORT $LL6@SzArEx_Fil
$LN47@SzArEx_Fil:
	mov	eax, DWORD PTR _emptyStream$80145[ebp]
$LN37@SzArEx_Fil:

; 105  :     }
; 106  :     p->FileIndexToFolderIndexMap[i] = folderIndex;

	mov	ebx, DWORD PTR [esi+60]
	mov	DWORD PTR [ebx+ecx*4], edi

; 107  :     if (emptyStream)

	test	eax, eax
	jne	SHORT $LN10@SzArEx_Fil

; 108  :       continue;
; 109  :     indexInFolder++;
; 110  :     if (indexInFolder >= p->db.Folders[folderIndex].NumUnpackStreams)

	mov	ebx, DWORD PTR [esi+12]
	inc	edx
	lea	eax, DWORD PTR [edi+edi*4]
	mov	DWORD PTR _indexInFolder$[ebp], edx
	cmp	edx, DWORD PTR [ebx+eax*8+36]
	jb	SHORT $LN10@SzArEx_Fil

; 111  :     {
; 112  :       folderIndex++;

	inc	edi

; 113  :       indexInFolder = 0;

	mov	DWORD PTR _indexInFolder$[ebp], 0
$LN10@SzArEx_Fil:

; 80   : 
; 81   :   for (i = 0; i < p->db.NumFiles; i++)

	add	DWORD PTR tv503[ebp], 32		; 00000020H
	inc	ecx
	cmp	ecx, DWORD PTR [esi+28]
	jb	$LL11@SzArEx_Fil
$LN9@SzArEx_Fil:
	pop	edi

; 114  :     }
; 115  :   }
; 116  :   return SZ_OK;

	xor	eax, eax
	pop	ebx

; 117  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN36@SzArEx_Fil:
	pop	edi

; 99   :           return SZ_ERROR_ARCHIVE;

	mov	eax, 16					; 00000010H
	pop	ebx

; 117  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SzArEx_Fill ENDP
_TEXT	ENDS
PUBLIC	_SzArEx_GetFolderStreamPos
; Function compile flags: /Ogtp
;	COMDAT _SzArEx_GetFolderStreamPos
_TEXT	SEGMENT
_p$ = 8							; size = 4
_folderIndex$ = 12					; size = 4
_indexInFolder$ = 16					; size = 4
_SzArEx_GetFolderStreamPos PROC				; COMDAT

; 121  : {

	push	ebp
	mov	ebp, esp

; 122  :   return p->dataPos +
; 123  :     p->PackStreamStartPositions[p->FolderStartPackStreamIndex[folderIndex] + indexInFolder];

	mov	ecx, DWORD PTR _folderIndex$[ebp]
	push	esi
	mov	esi, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [eax+ecx*4]
	add	ecx, DWORD PTR _indexInFolder$[ebp]
	mov	edx, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [edx+ecx*8]
	add	eax, DWORD PTR [esi+40]
	mov	edx, DWORD PTR [edx+ecx*8+4]
	adc	edx, DWORD PTR [esi+44]
	pop	esi

; 124  : }

	pop	ebp
	ret	0
_SzArEx_GetFolderStreamPos ENDP
_TEXT	ENDS
PUBLIC	_SzArEx_GetFolderFullPackSize
; Function compile flags: /Ogtp
;	COMDAT _SzArEx_GetFolderFullPackSize
_TEXT	SEGMENT
$T81212 = 8						; size = 4
_p$ = 8							; size = 4
_folderIndex$ = 12					; size = 4
_resSize$ = 16						; size = 4
_SzArEx_GetFolderFullPackSize PROC			; COMDAT

; 127  : {

	push	ebp
	mov	ebp, esp

; 128  :   UInt32 packStreamIndex = p->FolderStartPackStreamIndex[folderIndex];

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _folderIndex$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR [edx+eax*4]

; 129  :   CSzFolder *folder = p->db.Folders + folderIndex;

	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	eax, DWORD PTR [eax+24]

; 130  :   UInt64 size = 0;

	xor	esi, esi
	xor	edx, edx

; 131  :   UInt32 i;
; 132  :   for (i = 0; i < folder->NumPackStreams; i++)

	xor	ebx, ebx

; 137  :     size = t;

	mov	DWORD PTR $T81212[ebp], eax
	test	eax, eax
	je	SHORT $LN2@SzArEx_Get

; 128  :   UInt32 packStreamIndex = p->FolderStartPackStreamIndex[folderIndex];

	mov	eax, DWORD PTR [ecx]
	lea	edi, DWORD PTR [eax+edi*8]
$LL4@SzArEx_Get:

; 133  :   {
; 134  :     UInt64 t = size + p->db.PackSizes[packStreamIndex + i];

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edi+4]
	add	ecx, esi
	adc	eax, edx

; 135  :     if (t < size) /* check it */

	cmp	eax, edx
	jb	SHORT $LN8@SzArEx_Get
	ja	SHORT $LN10@SzArEx_Get
	cmp	ecx, esi
	jb	SHORT $LN8@SzArEx_Get
$LN10@SzArEx_Get:

; 131  :   UInt32 i;
; 132  :   for (i = 0; i < folder->NumPackStreams; i++)

	inc	ebx
	add	edi, 8

; 137  :     size = t;

	mov	esi, ecx
	mov	edx, eax
	cmp	ebx, DWORD PTR $T81212[ebp]
	jb	SHORT $LL4@SzArEx_Get
$LN2@SzArEx_Get:

; 138  :   }
; 139  :   *resSize = size;

	mov	eax, DWORD PTR _resSize$[ebp]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi
	mov	DWORD PTR [eax+4], edx

; 140  :   return SZ_OK;

	xor	eax, eax
	pop	ebx

; 141  : }

	pop	ebp
	ret	0
$LN8@SzArEx_Get:
	pop	edi
	pop	esi

; 136  :       return SZ_ERROR_FAIL;

	mov	eax, 11					; 0000000bH
	pop	ebx

; 141  : }

	pop	ebp
	ret	0
_SzArEx_GetFolderFullPackSize ENDP
_TEXT	ENDS
EXTRN	_k7zSignature:FWORD
; Function compile flags: /Ogtp
;	COMDAT _TestSignatureCandidate
_TEXT	SEGMENT
_TestSignatureCandidate PROC				; COMDAT
; _testBytes$ = ecx

; 180  :   size_t i;
; 181  :   for (i = 0; i < k7zSignatureSize; i++)

	xor	eax, eax
	sub	ecx, OFFSET _k7zSignature
	npad	8
$LL4@TestSignat:

; 182  :     if (testBytes[i] != k7zSignature[i])

	mov	dl, BYTE PTR _k7zSignature[ecx+eax]
	cmp	dl, BYTE PTR _k7zSignature[eax]
	jne	SHORT $LN8@TestSignat

; 180  :   size_t i;
; 181  :   for (i = 0; i < k7zSignatureSize; i++)

	inc	eax
	cmp	eax, 6
	jb	SHORT $LL4@TestSignat

; 184  :   return 1;

	mov	eax, 1

; 185  : }

	ret	0
$LN8@TestSignat:

; 183  :       return 0;

	xor	eax, eax

; 185  : }

	ret	0
_TestSignatureCandidate ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _SzReadByte
_TEXT	SEGMENT
_b$ = 8							; size = 4
_SzReadByte PROC					; COMDAT
; _sd$ = eax

; 194  : {

	push	ebp
	mov	ebp, esp

; 195  :   if (sd->Size == 0)

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN1@SzReadByte

; 196  :     return SZ_ERROR_ARCHIVE;

	mov	eax, 16					; 00000010H

; 200  : }

	pop	ebp
	ret	0
$LN1@SzReadByte:

; 197  :   sd->Size--;

	dec	ecx
	mov	DWORD PTR [eax+4], ecx

; 198  :   *b = *sd->Data++;

	mov	ecx, DWORD PTR [eax]
	mov	dl, BYTE PTR [ecx]
	mov	ecx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [ecx], dl
	inc	DWORD PTR [eax]

; 199  :   return SZ_OK;

	xor	eax, eax

; 200  : }

	pop	ebp
	ret	0
_SzReadByte ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _SzReadBytes
_TEXT	SEGMENT
_size$ = 8						; size = 4
_SzReadBytes PROC					; COMDAT
; _sd$ = ebx
; _data$ = edi

; 203  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 204  :   size_t i;
; 205  :   for (i = 0; i < size; i++)

	xor	esi, esi
	cmp	DWORD PTR _size$[ebp], esi
	jbe	SHORT $LN2@SzReadByte@2
	npad	5
$LL4@SzReadByte@2:

; 206  :   {
; 207  :     RINOK(SzReadByte(sd, data + i));

	lea	eax, DWORD PTR [esi+edi]
	push	eax
	mov	eax, ebx
	call	_SzReadByte
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@SzReadByte@2

; 204  :   size_t i;
; 205  :   for (i = 0; i < size; i++)

	inc	esi
	cmp	esi, DWORD PTR _size$[ebp]
	jb	SHORT $LL4@SzReadByte@2
$LN2@SzReadByte@2:

; 208  :   }
; 209  :   return SZ_OK;

	xor	eax, eax
$LN5@SzReadByte@2:
	pop	esi

; 210  : }

	pop	ebp
	ret	0
_SzReadBytes ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _SzReadUInt32
_TEXT	SEGMENT
_b$80223 = -1						; size = 1
_SzReadUInt32 PROC					; COMDAT
; _sd$ = ebx
; _value$ = edi

; 213  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 214  :   int i;
; 215  :   *value = 0;

	mov	DWORD PTR [edi], 0
	xor	esi, esi
	npad	3
$LL4@SzReadUInt:

; 216  :   for (i = 0; i < 4; i++)
; 217  :   {
; 218  :     Byte b;
; 219  :     RINOK(SzReadByte(sd, &b));

	lea	eax, DWORD PTR _b$80223[ebp]
	push	eax
	mov	eax, ebx
	call	_SzReadByte
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@SzReadUInt

; 220  :     *value |= ((UInt32)(b) << (8 * i));

	movzx	edx, BYTE PTR _b$80223[ebp]
	mov	ecx, esi
	shl	edx, cl
	add	esi, 8
	or	DWORD PTR [edi], edx
	cmp	esi, 32					; 00000020H
	jl	SHORT $LL4@SzReadUInt
$LN5@SzReadUInt:
	pop	esi

; 221  :   }
; 222  :   return SZ_OK;
; 223  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SzReadUInt32 ENDP
_TEXT	ENDS
EXTRN	__allshl:PROC
; Function compile flags: /Ogtp
;	COMDAT _SzReadNumber
_TEXT	SEGMENT
_i$ = -8						; size = 4
_b$80241 = -2						; size = 1
_firstByte$ = -1					; size = 1
_sd$ = 8						; size = 4
_SzReadNumber PROC					; COMDAT
; _value$ = esi

; 226  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 227  :   Byte firstByte;
; 228  :   Byte mask = 0x80;
; 229  :   int i;
; 230  :   RINOK(SzReadByte(sd, &firstByte));

	lea	eax, DWORD PTR _firstByte$[ebp]
	push	edi
	push	eax
	mov	eax, DWORD PTR _sd$[ebp]
	mov	bl, 128					; 00000080H
	call	_SzReadByte
	xor	edi, edi
	add	esp, 4
	cmp	eax, edi
	jne	SHORT $LN7@SzReadNumb

; 231  :   *value = 0;

	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], edi

; 232  :   for (i = 0; i < 8; i++)

	mov	DWORD PTR _i$[ebp], edi
$LL13@SzReadNumb:

; 233  :   {
; 234  :     Byte b;
; 235  :     if ((firstByte & mask) == 0)

	mov	cl, BYTE PTR _firstByte$[ebp]
	test	cl, bl
	je	SHORT $LN10@SzReadNumb

; 239  :       return SZ_OK;
; 240  :     }
; 241  :     RINOK(SzReadByte(sd, &b));

	mov	eax, DWORD PTR _sd$[ebp]
	lea	ecx, DWORD PTR _b$80241[ebp]
	push	ecx
	call	_SzReadByte
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN7@SzReadNumb

; 242  :     *value |= ((UInt64)b << (8 * i));

	movzx	eax, BYTE PTR _b$80241[ebp]
	cdq
	mov	ecx, edi
	call	__allshl
	or	DWORD PTR [esi], eax
	or	DWORD PTR [esi+4], edx
	inc	DWORD PTR _i$[ebp]
	add	edi, 8

; 243  :     mask >>= 1;

	shr	bl, 1
	cmp	edi, 64					; 00000040H
	jl	SHORT $LL13@SzReadNumb

; 244  :   }
; 245  :   return SZ_OK;

	pop	edi
	xor	eax, eax
	pop	ebx

; 246  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@SzReadNumb:

; 236  :     {
; 237  :       UInt64 highPart = firstByte & (mask - 1);
; 238  :       *value += (highPart << (8 * i));

	movzx	edx, cl
	mov	ecx, DWORD PTR _i$[ebp]
	movzx	eax, bl
	dec	eax
	add	ecx, ecx
	and	eax, edx
	add	ecx, ecx
	cdq
	add	ecx, ecx
	call	__allshl
	add	DWORD PTR [esi], eax
	adc	DWORD PTR [esi+4], edx

; 244  :   }
; 245  :   return SZ_OK;

	xor	eax, eax
$LN7@SzReadNumb:
	pop	edi
	pop	ebx

; 246  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SzReadNumber ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _SzReadNumber32
_TEXT	SEGMENT
_value64$ = -8						; size = 8
_value$ = 8						; size = 4
_SzReadNumber32 PROC					; COMDAT
; _sd$ = eax

; 249  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 250  :   UInt64 value64;
; 251  :   RINOK(SzReadNumber(sd, &value64));

	push	eax
	lea	esi, DWORD PTR _value64$[ebp]
	call	_SzReadNumber
	add	esp, 4
	pop	esi
	test	eax, eax
	jne	SHORT $LN4@SzReadNumb@2

; 252  :   if (value64 >= 0x80000000)

	mov	eax, DWORD PTR _value64$[ebp+4]
	test	eax, eax
	jne	SHORT $LN6@SzReadNumb@2
	mov	ecx, DWORD PTR _value64$[ebp]
	cmp	ecx, -2147483648			; 80000000H
	jb	SHORT $LN2@SzReadNumb@2
$LN6@SzReadNumb@2:

; 253  :     return SZ_ERROR_UNSUPPORTED;

	mov	eax, 4

; 257  :   return SZ_OK;
; 258  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@SzReadNumb@2:

; 254  :   if (value64 >= ((UInt64)(1) << ((sizeof(size_t) - 1) * 8 + 2)))

	test	eax, eax
	jne	SHORT $LN6@SzReadNumb@2
	cmp	ecx, 67108864				; 04000000H

; 255  :     return SZ_ERROR_UNSUPPORTED;

	jae	SHORT $LN6@SzReadNumb@2

; 256  :   *value = (UInt32)value64;

	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [edx], ecx
$LN4@SzReadNumb@2:

; 257  :   return SZ_OK;
; 258  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SzReadNumber32 ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _SzReadID
_TEXT	SEGMENT
_SzReadID PROC						; COMDAT
; _sd$ = eax
; _value$ = esi

; 262  :   return SzReadNumber(sd, value);

	push	eax
	call	_SzReadNumber
	add	esp, 4

; 263  : }

	ret	0
_SzReadID ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _SzSkeepDataSize
_TEXT	SEGMENT
_size$ = 8						; size = 8
_SzSkeepDataSize PROC					; COMDAT
; _sd$ = ecx

; 266  : {

	push	ebp
	mov	ebp, esp

; 267  :   if (size > sd->Size)

	mov	eax, DWORD PTR [ecx+4]
	xor	edx, edx
	cmp	DWORD PTR _size$[ebp+4], edx
	mov	edx, DWORD PTR _size$[ebp]
	push	esi
	pop	esi
	jb	SHORT $LN1@SzSkeepDat
	ja	SHORT $LN4@SzSkeepDat
	cmp	edx, eax
	jbe	SHORT $LN1@SzSkeepDat
$LN4@SzSkeepDat:

; 268  :     return SZ_ERROR_ARCHIVE;

	mov	eax, 16					; 00000010H

; 272  : }

	pop	ebp
	ret	0
$LN1@SzSkeepDat:

; 269  :   sd->Size -= (size_t)size;
; 270  :   sd->Data += (size_t)size;

	add	DWORD PTR [ecx], edx
	sub	eax, edx
	mov	DWORD PTR [ecx+4], eax

; 271  :   return SZ_OK;

	xor	eax, eax

; 272  : }

	pop	ebp
	ret	0
_SzSkeepDataSize ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _SzSkeepData
_TEXT	SEGMENT
_size$ = -8						; size = 8
_SzSkeepData PROC					; COMDAT
; _sd$ = edi

; 275  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 276  :   UInt64 size;
; 277  :   RINOK(SzReadNumber(sd, &size));

	push	edi
	lea	esi, DWORD PTR _size$[ebp]
	call	_SzReadNumber
	add	esp, 4
	pop	esi
	test	eax, eax
	jne	SHORT $LN2@SzSkeepDat@2

; 278  :   return SzSkeepDataSize(sd, size);

	mov	eax, DWORD PTR _size$[ebp+4]
	mov	ecx, DWORD PTR _size$[ebp]
	push	eax
	push	ecx
	mov	ecx, edi
	call	_SzSkeepDataSize
	add	esp, 8
$LN2@SzSkeepDat@2:

; 279  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SzSkeepData ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _SzReadArchiveProperties
_TEXT	SEGMENT
_type$80290 = -8					; size = 8
_SzReadArchiveProperties PROC				; COMDAT
; _sd$ = eax

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	edi

; 283  :   for (;;)
; 284  :   {
; 285  :     UInt64 type;
; 286  :     RINOK(SzReadID(sd, &type));

	lea	esi, DWORD PTR _type$80290[ebp]
	mov	edi, eax
	call	_SzReadID
	test	eax, eax
	jne	SHORT $LN5@SzReadArch
$LL4@SzReadArch:

; 287  :     if (type == k7zIdEnd)

	mov	eax, DWORD PTR _type$80290[ebp]
	or	eax, DWORD PTR _type$80290[ebp+4]
	je	SHORT $LN10@SzReadArch

; 288  :       break;
; 289  :     SzSkeepData(sd);

	call	_SzSkeepData
	lea	esi, DWORD PTR _type$80290[ebp]
	mov	eax, edi
	call	_SzReadID
	test	eax, eax
	je	SHORT $LL4@SzReadArch
	pop	edi
	pop	esi

; 292  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@SzReadArch:

; 290  :   }
; 291  :   return SZ_OK;

	xor	eax, eax
$LN5@SzReadArch:
	pop	edi
	pop	esi

; 292  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SzReadArchiveProperties ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _SzWaitAttribute
_TEXT	SEGMENT
_type$80303 = -8					; size = 8
_attribute$ = 8						; size = 8
_SzWaitAttribute PROC					; COMDAT
; _sd$ = eax

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi

; 296  :   for (;;)
; 297  :   {
; 298  :     UInt64 type;
; 299  :     RINOK(SzReadID(sd, &type));

	lea	esi, DWORD PTR _type$80303[ebp]
	mov	edi, eax
	call	_SzReadID
	test	eax, eax
	jne	SHORT $LN5@SzWaitAttr
	mov	ebx, DWORD PTR _attribute$[ebp]
	npad	6
$LL6@SzWaitAttr:

; 300  :     if (type == attribute)

	mov	eax, DWORD PTR _type$80303[ebp]
	mov	ecx, DWORD PTR _type$80303[ebp+4]
	cmp	eax, ebx
	jne	SHORT $LN15@SzWaitAttr
	cmp	ecx, DWORD PTR _attribute$[ebp+4]
	je	SHORT $LN12@SzWaitAttr
$LN15@SzWaitAttr:

; 302  :     if (type == k7zIdEnd)

	or	eax, ecx
	je	SHORT $LN13@SzWaitAttr

; 304  :     RINOK(SzSkeepData(sd));

	call	_SzSkeepData
	test	eax, eax
	jne	SHORT $LN5@SzWaitAttr

; 296  :   for (;;)
; 297  :   {
; 298  :     UInt64 type;
; 299  :     RINOK(SzReadID(sd, &type));

	lea	esi, DWORD PTR _type$80303[ebp]
	mov	eax, edi
	call	_SzReadID
	test	eax, eax
	je	SHORT $LL6@SzWaitAttr
	pop	edi
	pop	esi
	pop	ebx

; 305  :   }
; 306  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@SzWaitAttr:
	pop	edi
	pop	esi

; 301  :       return SZ_OK;

	xor	eax, eax
	pop	ebx

; 305  :   }
; 306  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@SzWaitAttr:

; 303  :       return SZ_ERROR_ARCHIVE;

	mov	eax, 16					; 00000010H
$LN5@SzWaitAttr:
	pop	edi
	pop	esi
	pop	ebx

; 305  :   }
; 306  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SzWaitAttribute ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _SzReadBoolVector
_TEXT	SEGMENT
_b$ = -1						; size = 1
_sd$ = 8						; size = 4
_v$ = 12						; size = 4
_SzReadBoolVector PROC					; COMDAT
; _numItems$ = edi
; _alloc$ = eax

; 309  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 310  :   Byte b = 0;
; 311  :   Byte mask = 0;

	xor	bl, bl
	mov	BYTE PTR _b$[ebp], 0

; 312  :   size_t i;
; 313  :   MY_ALLOC(Byte, *v, numItems, alloc);

	test	edi, edi
	jne	SHORT $LN8@SzReadBool
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax], edi
$LN14@SzReadBool:

; 314  :   for (i = 0; i < numItems; i++)

	push	esi
	xor	esi, esi
	test	edi, edi
	je	SHORT $LN3@SzReadBool
	npad	5
$LL5@SzReadBool:

; 315  :   {
; 316  :     if (mask == 0)

	test	bl, bl
	jne	SHORT $LN2@SzReadBool

; 317  :     {
; 318  :       RINOK(SzReadByte(sd, &b));

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	eax, DWORD PTR _sd$[ebp]
	call	_SzReadByte
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN15@SzReadBool

; 319  :       mask = 0x80;

	mov	bl, 128					; 00000080H
$LN2@SzReadBool:

; 320  :     }
; 321  :     (*v)[i] = (Byte)(((b & mask) != 0) ? 1 : 0);

	test	bl, BYTE PTR _b$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	setne	dl
	mov	BYTE PTR [esi+ecx], dl
	inc	esi

; 322  :     mask >>= 1;

	shr	bl, 1
	cmp	esi, edi
	jb	SHORT $LL5@SzReadBool
$LN3@SzReadBool:

; 323  :   }
; 324  :   return SZ_OK;

	xor	eax, eax
$LN15@SzReadBool:
	pop	esi
	pop	ebx

; 325  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@SzReadBool:

; 312  :   size_t i;
; 313  :   MY_ALLOC(Byte, *v, numItems, alloc);

	mov	ecx, DWORD PTR [eax]
	push	edi
	push	eax
	call	ecx
	mov	edx, DWORD PTR _v$[ebp]
	add	esp, 8
	mov	DWORD PTR [edx], eax
	test	eax, eax
	jne	SHORT $LN14@SzReadBool
	mov	eax, 2
	pop	ebx

; 325  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SzReadBoolVector ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _SzReadBoolVector2
_TEXT	SEGMENT
_allAreDefined$ = -1					; size = 1
_sd$ = 8						; size = 4
_SzReadBoolVector2 PROC					; COMDAT
; _numItems$ = eax
; _v$ = esi
; _alloc$ = ebx

; 328  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	edi
	mov	edi, eax

; 329  :   Byte allAreDefined;
; 330  :   size_t i;
; 331  :   RINOK(SzReadByte(sd, &allAreDefined));

	lea	eax, DWORD PTR _allAreDefined$[ebp]
	push	eax
	mov	eax, DWORD PTR _sd$[ebp]
	call	_SzReadByte
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN9@SzReadBool@2

; 332  :   if (allAreDefined == 0)

	cmp	BYTE PTR _allAreDefined$[ebp], al
	jne	SHORT $LN7@SzReadBool@2

; 333  :     return SzReadBoolVector(sd, numItems, v, alloc);

	mov	ecx, DWORD PTR _sd$[ebp]
	push	esi
	push	ecx
	mov	eax, ebx
	call	_SzReadBoolVector
	add	esp, 8
	pop	edi

; 338  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@SzReadBool@2:

; 334  :   MY_ALLOC(Byte, *v, numItems, alloc);

	test	edi, edi
	jne	SHORT $LN6@SzReadBool@2
	mov	DWORD PTR [esi], edi
$LN13@SzReadBool@2:

; 335  :   for (i = 0; i < numItems; i++)

	xor	eax, eax
	test	edi, edi
	je	SHORT $LN1@SzReadBool@2
	npad	1
$LL3@SzReadBool@2:

; 336  :     (*v)[i] = 1;

	mov	ecx, DWORD PTR [esi]
	mov	BYTE PTR [eax+ecx], 1
	inc	eax
	cmp	eax, edi
	jb	SHORT $LL3@SzReadBool@2
$LN1@SzReadBool@2:

; 337  :   return SZ_OK;

	xor	eax, eax
$LN9@SzReadBool@2:
	pop	edi

; 338  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@SzReadBool@2:

; 334  :   MY_ALLOC(Byte, *v, numItems, alloc);

	mov	edx, DWORD PTR [ebx]
	push	edi
	push	ebx
	call	edx
	add	esp, 8
	mov	DWORD PTR [esi], eax
	test	eax, eax
	jne	SHORT $LN13@SzReadBool@2
	mov	eax, 2
	pop	edi

; 338  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SzReadBoolVector2 ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _SzReadHashDigests
_TEXT	SEGMENT
_sd$ = 8						; size = 4
_numItems$ = 12						; size = 4
_digestsDefined$ = 16					; size = 4
_digests$ = 20						; size = 4
_SzReadHashDigests PROC					; COMDAT
; _alloc$ = eax

; 346  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 347  :   size_t i;
; 348  :   RINOK(SzReadBoolVector2(sd, numItems, digestsDefined, alloc));

	mov	esi, DWORD PTR _digestsDefined$[ebp]
	mov	ebx, eax
	mov	eax, DWORD PTR _sd$[ebp]
	push	edi
	mov	edi, DWORD PTR _numItems$[ebp]
	push	eax
	mov	eax, edi
	call	_SzReadBoolVector2
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN10@SzReadHash

; 349  :   MY_ALLOC(UInt32, *digests, numItems, alloc);

	test	edi, edi
	jne	SHORT $LN8@SzReadHash
	mov	ecx, DWORD PTR _digests$[ebp]
	mov	DWORD PTR [ecx], eax
$LN15@SzReadHash:

; 350  :   for (i = 0; i < numItems; i++)

	xor	esi, esi
	test	edi, edi
	je	SHORT $LN3@SzReadHash
	npad	1
$LL5@SzReadHash:

; 351  :     if ((*digestsDefined)[i])

	mov	edx, DWORD PTR _digestsDefined$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [esi+eax], 0
	je	SHORT $LN4@SzReadHash

; 350  :   for (i = 0; i < numItems; i++)

	mov	ecx, DWORD PTR _digests$[ebp]
	mov	edx, DWORD PTR [ecx]

; 352  :     {
; 353  :       RINOK(SzReadUInt32(sd, (*digests) + i));

	mov	ebx, DWORD PTR _sd$[ebp]
	lea	edi, DWORD PTR [edx+esi*4]
	call	_SzReadUInt32
	test	eax, eax
	jne	SHORT $LN10@SzReadHash
	mov	edi, DWORD PTR _numItems$[ebp]
$LN4@SzReadHash:

; 350  :   for (i = 0; i < numItems; i++)

	inc	esi
	cmp	esi, edi
	jb	SHORT $LL5@SzReadHash
$LN3@SzReadHash:

; 354  :     }
; 355  :   return SZ_OK;

	xor	eax, eax
$LN10@SzReadHash:
	pop	edi
	pop	esi
	pop	ebx

; 356  : }

	pop	ebp
	ret	0
$LN8@SzReadHash:

; 349  :   MY_ALLOC(UInt32, *digests, numItems, alloc);

	mov	eax, DWORD PTR [ebx]
	lea	edx, DWORD PTR [edi*4]
	push	edx
	push	ebx
	call	eax
	mov	ecx, DWORD PTR _digests$[ebp]
	add	esp, 8
	mov	DWORD PTR [ecx], eax
	test	eax, eax
	jne	SHORT $LN15@SzReadHash
	pop	edi
	pop	esi
	mov	eax, 2
	pop	ebx

; 356  : }

	pop	ebp
	ret	0
_SzReadHashDigests ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _SzReadPackInfo
_TEXT	SEGMENT
_type$80422 = -8					; size = 8
_numPackStreams$ = 8					; size = 4
_packSizes$ = 12					; size = 4
_packCRCsDefined$ = 16					; size = 4
_packCRCs$ = 20						; size = 4
_alloc$ = 24						; size = 4
_SzReadPackInfo PROC					; COMDAT
; _sd$ = eax
; _dataOffset$ = ecx

; 366  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	edi, eax

; 367  :   UInt32 i;
; 368  :   RINOK(SzReadNumber(sd, dataOffset));

	push	edi
	mov	esi, ecx
	call	_SzReadNumber
	add	esp, 4
	test	eax, eax
	jne	$LN28@SzReadPack

; 369  :   RINOK(SzReadNumber32(sd, numPackStreams));

	mov	esi, DWORD PTR _numPackStreams$[ebp]
	push	esi
	mov	eax, edi
	call	_SzReadNumber32
	add	esp, 4
	test	eax, eax
	jne	$LN28@SzReadPack

; 370  : 
; 371  :   RINOK(SzWaitAttribute(sd, k7zIdSize));

	push	eax
	push	9
	mov	eax, edi
	call	_SzWaitAttribute
	add	esp, 8
	test	eax, eax
	jne	$LN28@SzReadPack

; 372  : 
; 373  :   MY_ALLOC(UInt64, *packSizes, (size_t)*numPackStreams, alloc);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN24@SzReadPack
	mov	eax, DWORD PTR _packSizes$[ebp]
	mov	DWORD PTR [eax], 0
$LN42@SzReadPack:

; 374  : 
; 375  :   for (i = 0; i < *numPackStreams; i++)

	push	ebx
	xor	ebx, ebx
	cmp	DWORD PTR [esi], ebx
	jbe	SHORT $LN33@SzReadPack
	npad	2
$LL43@SzReadPack:
	mov	edx, DWORD PTR _packSizes$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	esi, DWORD PTR [eax+ebx*8]

; 376  :   {
; 377  :     RINOK(SzReadNumber(sd, (*packSizes) + i));

	push	edi
	call	_SzReadNumber
	add	esp, 4
	test	eax, eax
	jne	$LN47@SzReadPack

; 374  : 
; 375  :   for (i = 0; i < *numPackStreams; i++)

	mov	ecx, DWORD PTR _numPackStreams$[ebp]
	inc	ebx
	cmp	ebx, DWORD PTR [ecx]
	jb	SHORT $LL43@SzReadPack
$LN33@SzReadPack:

; 378  :   }
; 379  : 
; 380  :   for (;;)
; 381  :   {
; 382  :     UInt64 type;
; 383  :     RINOK(SzReadID(sd, &type));

	lea	esi, DWORD PTR _type$80422[ebp]
	mov	eax, edi
	call	_SzReadID
	test	eax, eax
	jne	$LN47@SzReadPack
$LL17@SzReadPack:

; 384  :     if (type == k7zIdEnd)

	mov	eax, DWORD PTR _type$80422[ebp]
	mov	ecx, DWORD PTR _type$80422[ebp+4]
	mov	edx, eax
	or	edx, ecx
	je	SHORT $LN37@SzReadPack

; 385  :       break;
; 386  :     if (type == k7zIdCRC)

	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN46@SzReadPack
	test	ecx, ecx
	jne	SHORT $LN46@SzReadPack

; 387  :     {
; 388  :       RINOK(SzReadHashDigests(sd, (size_t)*numPackStreams, packCRCsDefined, packCRCs, alloc));

	mov	eax, DWORD PTR _packCRCs$[ebp]
	mov	ecx, DWORD PTR _packCRCsDefined$[ebp]
	mov	edx, DWORD PTR _numPackStreams$[ebp]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	ecx
	push	eax
	mov	eax, DWORD PTR _alloc$[ebp]
	push	edi
	call	_SzReadHashDigests
	add	esp, 16					; 00000010H

; 389  :       continue;

	jmp	SHORT $LN50@SzReadPack
$LN24@SzReadPack:

; 372  : 
; 373  :   MY_ALLOC(UInt64, *packSizes, (size_t)*numPackStreams, alloc);

	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR _alloc$[ebp]
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	eax
	call	edx
	mov	ecx, DWORD PTR _packSizes$[ebp]
	add	esp, 8
	mov	DWORD PTR [ecx], eax
	test	eax, eax
	jne	$LN42@SzReadPack
	pop	edi
	mov	eax, 2
	pop	esi

; 404  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@SzReadPack:

; 390  :     }
; 391  :     RINOK(SzSkeepData(sd));

	call	_SzSkeepData
$LN50@SzReadPack:
	test	eax, eax
	jne	SHORT $LN47@SzReadPack

; 378  :   }
; 379  : 
; 380  :   for (;;)
; 381  :   {
; 382  :     UInt64 type;
; 383  :     RINOK(SzReadID(sd, &type));

	lea	esi, DWORD PTR _type$80422[ebp]
	mov	eax, edi
	call	_SzReadID
	test	eax, eax
	je	SHORT $LL17@SzReadPack
	pop	ebx
	pop	edi
	pop	esi

; 404  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@SzReadPack:

; 392  :   }
; 393  :   if (*packCRCsDefined == 0)

	mov	edi, DWORD PTR _packCRCsDefined$[ebp]
	cmp	DWORD PTR [edi], 0
	jne	SHORT $LN1@SzReadPack

; 394  :   {
; 395  :     MY_ALLOC(Byte, *packCRCsDefined, (size_t)*numPackStreams, alloc);

	mov	ebx, DWORD PTR _numPackStreams$[ebp]
	mov	eax, DWORD PTR [ebx]
	mov	esi, DWORD PTR _alloc$[ebp]
	test	eax, eax
	jne	SHORT $LN9@SzReadPack
	mov	DWORD PTR [edi], eax
	jmp	SHORT $LN7@SzReadPack
$LN9@SzReadPack:
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	esi
	call	ecx
	add	esp, 8
	mov	DWORD PTR [edi], eax
	test	eax, eax
	je	SHORT $LN48@SzReadPack
$LN7@SzReadPack:

; 396  :     MY_ALLOC(UInt32, *packCRCs, (size_t)*numPackStreams, alloc);

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	jne	SHORT $LN6@SzReadPack
	mov	ecx, DWORD PTR _packCRCs$[ebp]
	mov	DWORD PTR [ecx], eax
$LN4@SzReadPack:

; 397  :     for (i = 0; i < *numPackStreams; i++)

	xor	eax, eax
	cmp	DWORD PTR [ebx], eax
	jbe	SHORT $LN1@SzReadPack
$LL3@SzReadPack:

; 398  :     {
; 399  :       (*packCRCsDefined)[i] = 0;

	mov	edx, DWORD PTR [edi]
	mov	BYTE PTR [eax+edx], 0

; 400  :       (*packCRCs)[i] = 0;

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+eax*4], 0
	inc	eax
	cmp	eax, DWORD PTR [ebx]
	jb	SHORT $LL3@SzReadPack
$LN1@SzReadPack:

; 401  :     }
; 402  :   }
; 403  :   return SZ_OK;

	xor	eax, eax
$LN47@SzReadPack:
	pop	ebx
$LN28@SzReadPack:
	pop	edi
	pop	esi

; 404  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@SzReadPack:

; 396  :     MY_ALLOC(UInt32, *packCRCs, (size_t)*numPackStreams, alloc);

	lea	edx, DWORD PTR [eax*4]
	mov	eax, DWORD PTR [esi]
	push	edx
	push	esi
	call	eax
	mov	ecx, DWORD PTR _packCRCs$[ebp]
	add	esp, 8
	mov	DWORD PTR [ecx], eax
	test	eax, eax
	jne	SHORT $LN4@SzReadPack
$LN48@SzReadPack:
	pop	ebx
	pop	edi
	mov	eax, 2
	pop	esi

; 404  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SzReadPackInfo ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _SzReadSwitch
_TEXT	SEGMENT
_external$ = -1						; size = 1
_sd$ = 8						; size = 4
_SzReadSwitch PROC					; COMDAT

; 407  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 408  :   Byte external;
; 409  :   RINOK(SzReadByte(sd, &external));

	lea	eax, DWORD PTR _external$[ebp]
	push	eax
	mov	eax, DWORD PTR _sd$[ebp]
	call	_SzReadByte
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@SzReadSwit

; 410  :   return (external == 0) ? SZ_OK: SZ_ERROR_UNSUPPORTED;

	movzx	eax, BYTE PTR _external$[ebp]
	neg	eax
	sbb	eax, eax
	and	eax, 4
$LN2@SzReadSwit:

; 411  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SzReadSwitch ENDP
_TEXT	ENDS
PUBLIC	_alloc$GSCopy$
PUBLIC	_folder$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	_SzFolder_FindBindPairForInStream:PROC
EXTRN	_Buf_Create:PROC
EXTRN	_SzCoderInfo_Init:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtp
;	COMDAT _SzGetNextFolderItem
_TEXT	SEGMENT
_propertiesSize$80511 = -80				; size = 8
_propertiesSize$80533 = -72				; size = 8
_numCoders$ = -64					; size = 4
_coder$80488 = -60					; size = 4
_alloc$GSCopy$ = -56					; size = 4
_folder$GSCopy$ = -52					; size = 4
tv354 = -48						; size = 4
_n$80527 = -48						; size = 4
_idSize$80489 = -48					; size = 4
tv729 = -44						; size = 4
tv215 = -44						; size = 4
_numBindPairs$ = -40					; size = 4
_numOutStreams$ = -40					; size = 4
tv641 = -36						; size = 4
tv424 = -36						; size = 4
_numInStreams$ = -32					; size = 4
_i$ = -28						; size = 4
_mainByte$80487 = -21					; size = 1
_longID$80491 = -20					; size = 15
__$ArrayPad$ = -4					; size = 4
_folder$ = 8						; size = 4
_SzGetNextFolderItem PROC				; COMDAT
; _sd$ = ecx
; _alloc$ = edx

; 414  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 424  : 
; 425  :   for (i = 0; i < numCoders; i++)

	mov	eax, DWORD PTR _folder$[ebp]
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi
	lea	ecx, DWORD PTR _numCoders$[ebp]
	mov	DWORD PTR _folder$GSCopy$[ebp], eax
	mov	esi, edx
	xor	edi, edi
	push	ecx
	mov	eax, ebx
	mov	DWORD PTR _alloc$GSCopy$[ebp], esi
	mov	DWORD PTR _numInStreams$[ebp], edi
	mov	DWORD PTR _numOutStreams$[ebp], edi
	call	_SzReadNumber32
	add	esp, 4
	cmp	eax, edi
	jne	$LN62@SzGetNextF

; 415  :   UInt32 numCoders, numBindPairs, numPackStreams, i;
; 416  :   UInt32 numInStreams = 0, numOutStreams = 0;
; 417  :   
; 418  :   RINOK(SzReadNumber32(sd, &numCoders));
; 419  :   if (numCoders > NUM_FOLDER_CODERS_MAX)

	mov	edi, DWORD PTR _numCoders$[ebp]
	cmp	edi, 32					; 00000020H
	jbe	SHORT $LN60@SzGetNextF
$LN79@SzGetNextF:
	pop	edi
	pop	esi

; 420  :     return SZ_ERROR_UNSUPPORTED;

	mov	eax, 4
	pop	ebx

; 521  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN60@SzGetNextF:

; 421  :   folder->NumCoders = numCoders;

	mov	eax, DWORD PTR _folder$GSCopy$[ebp]
	mov	DWORD PTR [eax+16], edi

; 422  :   
; 423  :   MY_ALLOC(CSzCoderInfo, folder->Coders, (size_t)numCoders, alloc);

	test	edi, edi
	jne	$LN59@SzGetNextF
	mov	DWORD PTR [eax], edi
$LN98@SzGetNextF:

; 424  : 
; 425  :   for (i = 0; i < numCoders; i++)

	test	edi, edi
	je	SHORT $LN54@SzGetNextF
	xor	esi, esi
	mov	DWORD PTR tv215[ebp], edi
$LL56@SzGetNextF:

; 426  :     SzCoderInfo_Init(folder->Coders + i);

	mov	edx, DWORD PTR _folder$GSCopy$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, esi
	push	eax
	call	_SzCoderInfo_Init
	add	esp, 4
	add	esi, 24					; 00000018H
	dec	DWORD PTR tv215[ebp]
	jne	SHORT $LL56@SzGetNextF
$LN54@SzGetNextF:

; 427  : 
; 428  :   for (i = 0; i < numCoders; i++)

	xor	eax, eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	edi, eax
	jbe	SHORT $LN79@SzGetNextF
	mov	DWORD PTR tv729[ebp], eax
	npad	7
$LL53@SzGetNextF:

; 429  :   {
; 430  :     Byte mainByte;
; 431  :     CSzCoderInfo *coder = folder->Coders + i;

	mov	ecx, DWORD PTR _folder$GSCopy$[ebp]
	mov	esi, DWORD PTR [ecx]
	add	esi, DWORD PTR tv729[ebp]

; 432  :     {
; 433  :       unsigned idSize, j;
; 434  :       Byte longID[15];
; 435  :       RINOK(SzReadByte(sd, &mainByte));

	lea	edx, DWORD PTR _mainByte$80487[ebp]
	push	edx
	mov	eax, ebx
	mov	DWORD PTR _coder$80488[ebp], esi
	call	_SzReadByte
	add	esp, 4
	test	eax, eax
	jne	$LN62@SzGetNextF

; 436  :       idSize = (unsigned)(mainByte & 0xF);

	movzx	eax, BYTE PTR _mainByte$80487[ebp]
	and	eax, 15					; 0000000fH

; 437  :       RINOK(SzReadBytes(sd, longID, idSize));

	push	eax
	lea	edi, DWORD PTR _longID$80491[ebp]
	mov	DWORD PTR _idSize$80489[ebp], eax
	call	_SzReadBytes
	add	esp, 4
	test	eax, eax
	jne	$LN62@SzGetNextF

; 438  :       if (idSize > sizeof(coder->MethodID))

	mov	eax, DWORD PTR _idSize$80489[ebp]
	cmp	eax, 8
	ja	$LN79@SzGetNextF

; 439  :         return SZ_ERROR_UNSUPPORTED;
; 440  :       coder->MethodID = 0;

	xor	ecx, ecx
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+12], ecx

; 441  :       for (j = 0; j < idSize; j++)

	cmp	eax, ecx
	jbe	SHORT $LN45@SzGetNextF

; 439  :         return SZ_ERROR_UNSUPPORTED;
; 440  :       coder->MethodID = 0;

	mov	DWORD PTR tv641[ebp], ecx
	lea	edi, DWORD PTR _longID$80491[ebp+eax-1]
	mov	DWORD PTR tv354[ebp], eax
$LL47@SzGetNextF:

; 442  :         coder->MethodID |= (UInt64)longID[idSize - 1 - j] << (8 * j);

	movzx	eax, BYTE PTR [edi]
	mov	ecx, DWORD PTR tv641[ebp]
	cdq
	call	__allshl
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx
	add	DWORD PTR tv641[ebp], 8
	dec	edi
	dec	DWORD PTR tv354[ebp]
	jne	SHORT $LL47@SzGetNextF
$LN45@SzGetNextF:

; 443  : 
; 444  :       if ((mainByte & 0x10) != 0)

	test	BYTE PTR _mainByte$80487[ebp], 16	; 00000010H
	je	SHORT $LN44@SzGetNextF

; 445  :       {
; 446  :         RINOK(SzReadNumber32(sd, &coder->NumInStreams));

	push	esi
	mov	eax, ebx
	call	_SzReadNumber32
	add	esp, 4
	test	eax, eax
	jne	$LN62@SzGetNextF

; 447  :         RINOK(SzReadNumber32(sd, &coder->NumOutStreams));

	lea	edi, DWORD PTR [esi+4]
	push	edi
	mov	eax, ebx
	mov	DWORD PTR tv424[ebp], edi
	call	_SzReadNumber32
	add	esp, 4
	test	eax, eax
	jne	$LN62@SzGetNextF

; 448  :         if (coder->NumInStreams > NUM_CODER_STREAMS_MAX ||
; 449  :             coder->NumOutStreams > NUM_CODER_STREAMS_MAX)

	cmp	DWORD PTR [esi], 32			; 00000020H
	ja	$LN79@SzGetNextF
	cmp	DWORD PTR [edi], 32			; 00000020H
	ja	$LN79@SzGetNextF

; 450  :           return SZ_ERROR_UNSUPPORTED;
; 451  :       }
; 452  :       else

	jmp	SHORT $LN39@SzGetNextF
$LN59@SzGetNextF:

; 422  :   
; 423  :   MY_ALLOC(CSzCoderInfo, folder->Coders, (size_t)numCoders, alloc);

	mov	eax, DWORD PTR [esi]
	lea	edx, DWORD PTR [edi+edi*2]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	push	esi
	call	eax
	mov	ecx, DWORD PTR _folder$GSCopy$[ebp]
	add	esp, 8
	mov	DWORD PTR [ecx], eax
	test	eax, eax
	jne	$LN98@SzGetNextF
$LN84@SzGetNextF:
	pop	edi
	pop	esi
	mov	eax, 2
	pop	ebx

; 521  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@SzGetNextF:

; 453  :       {
; 454  :         coder->NumInStreams = 1;
; 455  :         coder->NumOutStreams = 1;

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR tv424[ebp], eax
	mov	DWORD PTR [eax], 1
	mov	edi, eax
$LN39@SzGetNextF:

; 456  :       }
; 457  :       if ((mainByte & 0x20) != 0)

	test	BYTE PTR _mainByte$80487[ebp], 32	; 00000020H
	je	SHORT $LN99@SzGetNextF

; 458  :       {
; 459  :         UInt64 propertiesSize = 0;

	xor	eax, eax

; 460  :         RINOK(SzReadNumber(sd, &propertiesSize));

	push	ebx
	lea	esi, DWORD PTR _propertiesSize$80511[ebp]
	mov	DWORD PTR _propertiesSize$80511[ebp], eax
	mov	DWORD PTR _propertiesSize$80511[ebp+4], eax
	call	_SzReadNumber
	add	esp, 4
	test	eax, eax
	jne	$LN62@SzGetNextF

; 461  :         if (!Buf_Create(&coder->Props, (size_t)propertiesSize, alloc))

	mov	eax, DWORD PTR _alloc$GSCopy$[ebp]
	mov	esi, DWORD PTR _coder$80488[ebp]
	mov	edi, DWORD PTR _propertiesSize$80511[ebp]
	push	eax
	add	esi, 16					; 00000010H
	push	edi
	push	esi
	call	_Buf_Create
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN84@SzGetNextF

; 462  :           return SZ_ERROR_MEM;
; 463  :         RINOK(SzReadBytes(sd, coder->Props.data, (size_t)propertiesSize));

	push	edi
	mov	edi, DWORD PTR [esi]
	call	_SzReadBytes
	add	esp, 4
	test	eax, eax
	jne	$LN62@SzGetNextF
	mov	esi, DWORD PTR _coder$80488[ebp]
	mov	edi, DWORD PTR tv424[ebp]
$LN99@SzGetNextF:

; 464  :       }
; 465  :     }
; 466  :     while ((mainByte & 0x80) != 0)

	test	BYTE PTR _mainByte$80487[ebp], 128	; 00000080H
	je	$LN33@SzGetNextF
	npad	4
$LL34@SzGetNextF:

; 467  :     {
; 468  :       RINOK(SzReadByte(sd, &mainByte));

	lea	ecx, DWORD PTR _mainByte$80487[ebp]
	push	ecx
	mov	eax, ebx
	call	_SzReadByte
	add	esp, 4
	test	eax, eax
	jne	$LN62@SzGetNextF

; 469  :       RINOK(SzSkeepDataSize(sd, (mainByte & 0xF)));

	mov	dl, BYTE PTR _mainByte$80487[ebp]
	and	dl, 15					; 0000000fH
	movzx	eax, dl
	cdq
	push	edx
	push	eax
	mov	ecx, ebx
	call	_SzSkeepDataSize
	add	esp, 8
	test	eax, eax
	jne	$LN62@SzGetNextF

; 470  :       if ((mainByte & 0x10) != 0)

	test	BYTE PTR _mainByte$80487[ebp], 16	; 00000010H
	je	SHORT $LN28@SzGetNextF

; 471  :       {
; 472  :         UInt32 n;
; 473  :         RINOK(SzReadNumber32(sd, &n));

	lea	eax, DWORD PTR _n$80527[ebp]
	push	eax
	mov	eax, ebx
	call	_SzReadNumber32
	add	esp, 4
	test	eax, eax
	jne	$LN62@SzGetNextF

; 474  :         RINOK(SzReadNumber32(sd, &n));

	lea	ecx, DWORD PTR _n$80527[ebp]
	push	ecx
	mov	eax, ebx
	call	_SzReadNumber32
	add	esp, 4
	test	eax, eax
	jne	$LN62@SzGetNextF
$LN28@SzGetNextF:

; 475  :       }
; 476  :       if ((mainByte & 0x20) != 0)

	test	BYTE PTR _mainByte$80487[ebp], 32	; 00000020H
	je	SHORT $LN25@SzGetNextF

; 477  :       {
; 478  :         UInt64 propertiesSize = 0;

	xor	eax, eax

; 479  :         RINOK(SzReadNumber(sd, &propertiesSize));

	push	ebx
	lea	esi, DWORD PTR _propertiesSize$80533[ebp]
	mov	DWORD PTR _propertiesSize$80533[ebp], eax
	mov	DWORD PTR _propertiesSize$80533[ebp+4], eax
	call	_SzReadNumber
	add	esp, 4
	test	eax, eax
	jne	$LN62@SzGetNextF

; 480  :         RINOK(SzSkeepDataSize(sd, propertiesSize));

	mov	edx, DWORD PTR _propertiesSize$80533[ebp+4]
	mov	eax, DWORD PTR _propertiesSize$80533[ebp]
	push	edx
	push	eax
	mov	ecx, ebx
	call	_SzSkeepDataSize
	add	esp, 8
	test	eax, eax
	jne	$LN62@SzGetNextF
	mov	esi, DWORD PTR _coder$80488[ebp]
$LN25@SzGetNextF:

; 464  :       }
; 465  :     }
; 466  :     while ((mainByte & 0x80) != 0)

	test	BYTE PTR _mainByte$80487[ebp], 128	; 00000080H
	jne	$LL34@SzGetNextF
$LN33@SzGetNextF:

; 427  : 
; 428  :   for (i = 0; i < numCoders; i++)

	mov	eax, DWORD PTR _i$[ebp]

; 481  :       }
; 482  :     }
; 483  :     numInStreams += coder->NumInStreams;

	mov	ecx, DWORD PTR [esi]

; 484  :     numOutStreams += coder->NumOutStreams;

	mov	edx, DWORD PTR [edi]
	add	DWORD PTR _numInStreams$[ebp], ecx
	add	DWORD PTR _numOutStreams$[ebp], edx
	add	DWORD PTR tv729[ebp], 24		; 00000018H
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _numCoders$[ebp]
	jb	$LL53@SzGetNextF

; 485  :   }
; 486  : 
; 487  :   if (numOutStreams == 0)

	mov	edi, DWORD PTR _numOutStreams$[ebp]
	test	edi, edi

; 488  :     return SZ_ERROR_UNSUPPORTED;

	je	$LN79@SzGetNextF

; 489  : 
; 490  :   folder->NumBindPairs = numBindPairs = numOutStreams - 1;

	mov	esi, DWORD PTR _folder$GSCopy$[ebp]
	dec	edi
	mov	DWORD PTR _numBindPairs$[ebp], edi
	mov	DWORD PTR [esi+20], edi

; 491  :   MY_ALLOC(CBindPair, folder->BindPairs, (size_t)numBindPairs, alloc);

	jne	SHORT $LN23@SzGetNextF
	mov	DWORD PTR [esi+4], 0
	jmp	SHORT $LN97@SzGetNextF
$LN23@SzGetNextF:
	lea	eax, DWORD PTR [edi*8]
	push	eax
	mov	eax, DWORD PTR _alloc$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	ecx
	add	esp, 8
	mov	DWORD PTR [esi+4], eax
	test	eax, eax
	je	$LN84@SzGetNextF
$LN97@SzGetNextF:

; 492  : 
; 493  :   for (i = 0; i < numBindPairs; i++)

	mov	DWORD PTR _i$[ebp], 0
	test	edi, edi
	je	SHORT $LN18@SzGetNextF
$LL20@SzGetNextF:
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR _i$[ebp]
	lea	edi, DWORD PTR [edx+eax*8]

; 494  :   {
; 495  :     CBindPair *bp = folder->BindPairs + i;
; 496  :     RINOK(SzReadNumber32(sd, &bp->InIndex));

	push	edi
	mov	eax, ebx
	call	_SzReadNumber32
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN62@SzGetNextF

; 497  :     RINOK(SzReadNumber32(sd, &bp->OutIndex));

	add	edi, 4
	push	edi
	mov	eax, ebx
	call	_SzReadNumber32
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN62@SzGetNextF

; 492  : 
; 493  :   for (i = 0; i < numBindPairs; i++)

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _numBindPairs$[ebp]
	jb	SHORT $LL20@SzGetNextF

; 517  :     {
; 518  :       RINOK(SzReadNumber32(sd, folder->PackStreams + i));

	mov	edi, DWORD PTR _numBindPairs$[ebp]
$LN18@SzGetNextF:

; 498  :   }
; 499  : 
; 500  :   if (numInStreams < numBindPairs)

	cmp	DWORD PTR _numInStreams$[ebp], edi

; 501  :     return SZ_ERROR_UNSUPPORTED;

	jb	$LN79@SzGetNextF

; 502  : 
; 503  :   folder->NumPackStreams = numPackStreams = numInStreams - numBindPairs;

	mov	edi, DWORD PTR _numInStreams$[ebp]
	sub	edi, DWORD PTR _numBindPairs$[ebp]
	mov	DWORD PTR [esi+24], edi

; 504  :   MY_ALLOC(UInt32, folder->PackStreams, (size_t)numPackStreams, alloc);

	jne	SHORT $LN14@SzGetNextF
	mov	DWORD PTR [esi+8], 0
$LN11@SzGetNextF:

; 514  :   }
; 515  :   else
; 516  :     for (i = 0; i < numPackStreams; i++)

	mov	DWORD PTR _i$[ebp], 0
	test	edi, edi
	je	SHORT $LN2@SzGetNextF
$LL4@SzGetNextF:
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 517  :     {
; 518  :       RINOK(SzReadNumber32(sd, folder->PackStreams + i));

	push	eax
	mov	eax, ebx
	call	_SzReadNumber32
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN62@SzGetNextF

; 514  :   }
; 515  :   else
; 516  :     for (i = 0; i < numPackStreams; i++)

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, edi
	jb	SHORT $LL4@SzGetNextF
$LN2@SzGetNextF:

; 519  :     }
; 520  :   return SZ_OK;

	xor	eax, eax
$LN62@SzGetNextF:
	pop	edi
	pop	esi
	pop	ebx

; 521  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@SzGetNextF:

; 504  :   MY_ALLOC(UInt32, folder->PackStreams, (size_t)numPackStreams, alloc);

	mov	eax, DWORD PTR _alloc$GSCopy$[ebp]
	mov	edx, DWORD PTR [eax]
	lea	ecx, DWORD PTR [edi*4]
	push	ecx
	push	eax
	call	edx
	add	esp, 8
	mov	DWORD PTR [esi+8], eax
	test	eax, eax
	je	$LN84@SzGetNextF

; 505  : 
; 506  :   if (numPackStreams == 1)

	cmp	edi, 1
	jne	SHORT $LN11@SzGetNextF

; 507  :   {
; 508  :     for (i = 0; i < numInStreams ; i++)

	xor	edi, edi
	cmp	edi, DWORD PTR _numInStreams$[ebp]
	jae	SHORT $LN100@SzGetNextF
	mov	ebx, DWORD PTR _numInStreams$[ebp]
$LL10@SzGetNextF:

; 509  :       if (SzFolder_FindBindPairForInStream(folder, i) < 0)

	push	edi
	push	esi
	call	_SzFolder_FindBindPairForInStream
	add	esp, 8
	test	eax, eax
	js	SHORT $LN88@SzGetNextF

; 507  :   {
; 508  :     for (i = 0; i < numInStreams ; i++)

	inc	edi
	cmp	edi, ebx
	jb	SHORT $LL10@SzGetNextF
$LN88@SzGetNextF:

; 510  :         break;
; 511  :     if (i == numInStreams)

	cmp	edi, DWORD PTR _numInStreams$[ebp]
$LN100@SzGetNextF:

; 512  :       return SZ_ERROR_UNSUPPORTED;

	je	$LN79@SzGetNextF

; 513  :     folder->PackStreams[0] = i;

	mov	eax, DWORD PTR [esi+8]

; 521  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	DWORD PTR [eax], edi
	pop	edi
	pop	esi
	xor	ecx, ebp
	xor	eax, eax
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SzGetNextFolderItem ENDP
_TEXT	ENDS
EXTRN	_SzFolder_GetNumOutStreams:PROC
EXTRN	_SzFolder_Init:PROC
; Function compile flags: /Ogtp
;	COMDAT _SzReadUnpackInfo
_TEXT	SEGMENT
_type$80631 = -20					; size = 8
_res$80636 = -12					; size = 4
_numOutStreams$80615 = -12				; size = 4
tv379 = -8						; size = 4
_crcs$80638 = -8					; size = 4
_crcsDefined$80637 = -4					; size = 4
_i$ = -4						; size = 4
_sd$ = 8						; size = 4
_numFolders$ = 12					; size = 4
_folders$ = 16						; size = 4
_alloc$ = 20						; size = 4
_allocTemp$ = 24					; size = 4
_SzReadUnpackInfo PROC					; COMDAT

; 529  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	edi

; 530  :   UInt32 i;
; 531  :   RINOK(SzWaitAttribute(sd, k7zIdFolder));

	mov	edi, DWORD PTR _sd$[ebp]
	push	0
	push	11					; 0000000bH
	mov	eax, edi
	call	_SzWaitAttribute
	add	esp, 8
	test	eax, eax
	jne	$LN10@SzReadUnpa

; 532  :   RINOK(SzReadNumber32(sd, numFolders));

	push	ebx
	mov	ebx, DWORD PTR _numFolders$[ebp]
	push	ebx
	mov	eax, edi
	call	_SzReadNumber32
	add	esp, 4
	test	eax, eax
	jne	$LN64@SzReadUnpa

; 533  :   {
; 534  :     RINOK(SzReadSwitch(sd));

	push	edi
	call	_SzReadSwitch
	add	esp, 4
	test	eax, eax
	jne	$LN64@SzReadUnpa

; 535  : 
; 536  :     MY_ALLOC(CSzFolder, *folders, (size_t)*numFolders, alloc);

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	jne	$LN32@SzReadUnpa
	mov	eax, DWORD PTR _folders$[ebp]
	mov	DWORD PTR [eax], 0
$LN58@SzReadUnpa:

; 537  : 
; 538  :     for (i = 0; i < *numFolders; i++)

	push	esi
	xor	esi, esi
	cmp	DWORD PTR [ebx], esi
	jbe	SHORT $LN27@SzReadUnpa
	xor	edi, edi
$LL62@SzReadUnpa:

; 539  :       SzFolder_Init((*folders) + i);

	mov	edx, DWORD PTR _folders$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, edi
	push	eax
	call	_SzFolder_Init
	inc	esi
	add	esp, 4
	add	edi, 40					; 00000028H
	cmp	esi, DWORD PTR [ebx]
	jb	SHORT $LL62@SzReadUnpa

; 537  : 
; 538  :     for (i = 0; i < *numFolders; i++)

	mov	edi, DWORD PTR _sd$[ebp]
$LN27@SzReadUnpa:

; 540  : 
; 541  :     for (i = 0; i < *numFolders; i++)

	xor	esi, esi
	mov	DWORD PTR _i$[ebp], esi
	cmp	DWORD PTR [ebx], esi
	jbe	SHORT $LN24@SzReadUnpa
$LL63@SzReadUnpa:

; 542  :     {
; 543  :       RINOK(SzGetNextFolderItem(sd, (*folders) + i, alloc));

	mov	ecx, DWORD PTR _folders$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, esi
	push	edx
	mov	edx, DWORD PTR _alloc$[ebp]
	mov	ecx, edi
	call	_SzGetNextFolderItem
	add	esp, 4
	test	eax, eax
	jne	$LN65@SzReadUnpa

; 540  : 
; 541  :     for (i = 0; i < *numFolders; i++)

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	esi, 40					; 00000028H
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [ebx]
	jb	SHORT $LL63@SzReadUnpa
$LN24@SzReadUnpa:

; 544  :     }
; 545  :   }
; 546  : 
; 547  :   RINOK(SzWaitAttribute(sd, k7zIdCodersUnpackSize));

	push	0
	push	12					; 0000000cH
	mov	eax, edi
	call	_SzWaitAttribute
	xor	ecx, ecx
	add	esp, 8
	cmp	eax, ecx
	jne	$LN65@SzReadUnpa

; 548  : 
; 549  :   for (i = 0; i < *numFolders; i++)

	mov	DWORD PTR _i$[ebp], ecx
	cmp	DWORD PTR [ebx], ecx
	jbe	$LN44@SzReadUnpa
	mov	DWORD PTR tv379[ebp], ecx
	npad	7
$LL59@SzReadUnpa:

; 550  :   {
; 551  :     UInt32 j;
; 552  :     CSzFolder *folder = (*folders) + i;

	mov	eax, DWORD PTR _folders$[ebp]
	mov	edi, DWORD PTR [eax]
	add	edi, DWORD PTR tv379[ebp]

; 553  :     UInt32 numOutStreams = SzFolder_GetNumOutStreams(folder);

	push	edi
	call	_SzFolder_GetNumOutStreams
	mov	esi, eax

; 554  : 
; 555  :     MY_ALLOC(UInt64, folder->UnpackSizes, (size_t)numOutStreams, alloc);

	xor	ebx, ebx
	add	esp, 4
	mov	DWORD PTR _numOutStreams$80615[ebp], esi
	cmp	esi, ebx
	jne	SHORT $LN18@SzReadUnpa
	mov	DWORD PTR [edi+12], ebx
	jmp	SHORT $LN16@SzReadUnpa
$LN32@SzReadUnpa:

; 535  : 
; 536  :     MY_ALLOC(CSzFolder, *folders, (size_t)*numFolders, alloc);

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _alloc$[ebp]
	mov	edx, DWORD PTR [eax]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	eax
	call	edx
	mov	ecx, DWORD PTR _folders$[ebp]
	add	esp, 8
	mov	DWORD PTR [ecx], eax
	test	eax, eax
	jne	$LN58@SzReadUnpa
	pop	ebx
	mov	eax, 2
	pop	edi

; 590  :   }
; 591  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@SzReadUnpa:

; 554  : 
; 555  :     MY_ALLOC(UInt64, folder->UnpackSizes, (size_t)numOutStreams, alloc);

	mov	eax, DWORD PTR _alloc$[ebp]
	mov	edx, DWORD PTR [eax]
	lea	ecx, DWORD PTR [esi*8]
	push	ecx
	push	eax
	call	edx
	add	esp, 8
	mov	DWORD PTR [edi+12], eax
	cmp	eax, ebx
	je	SHORT $LN48@SzReadUnpa
$LN16@SzReadUnpa:

; 556  : 
; 557  :     for (j = 0; j < numOutStreams; j++)

	test	esi, esi
	je	SHORT $LN20@SzReadUnpa
	npad	4
$LL15@SzReadUnpa:
	mov	eax, DWORD PTR [edi+12]

; 558  :     {
; 559  :       RINOK(SzReadNumber(sd, folder->UnpackSizes + j));

	mov	ecx, DWORD PTR _sd$[ebp]
	lea	esi, DWORD PTR [eax+ebx*8]
	push	ecx
	call	_SzReadNumber
	add	esp, 4
	test	eax, eax
	jne	$LN65@SzReadUnpa

; 556  : 
; 557  :     for (j = 0; j < numOutStreams; j++)

	inc	ebx
	cmp	ebx, DWORD PTR _numOutStreams$80615[ebp]
	jb	SHORT $LL15@SzReadUnpa
$LN20@SzReadUnpa:

; 548  : 
; 549  :   for (i = 0; i < *numFolders; i++)

	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _numFolders$[ebp]
	add	DWORD PTR tv379[ebp], 40		; 00000028H
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [edx]
	jb	$LL59@SzReadUnpa

; 588  :     }
; 589  :     RINOK(SzSkeepData(sd));

	mov	edi, DWORD PTR _sd$[ebp]
	mov	ebx, edx
$LN44@SzReadUnpa:

; 560  :     }
; 561  :   }
; 562  : 
; 563  :   for (;;)
; 564  :   {
; 565  :     UInt64 type;
; 566  :     RINOK(SzReadID(sd, &type));

	lea	esi, DWORD PTR _type$80631[ebp]
	mov	eax, edi
	call	_SzReadID
	xor	ecx, ecx
	cmp	eax, ecx
	jne	$LN65@SzReadUnpa
	jmp	SHORT $LN11@SzReadUnpa
$LN48@SzReadUnpa:
	pop	esi
	pop	ebx

; 554  : 
; 555  :     MY_ALLOC(UInt64, folder->UnpackSizes, (size_t)numOutStreams, alloc);

	mov	eax, 2
	pop	edi

; 590  :   }
; 591  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LL61@SzReadUnpa:

; 560  :     }
; 561  :   }
; 562  : 
; 563  :   for (;;)
; 564  :   {
; 565  :     UInt64 type;
; 566  :     RINOK(SzReadID(sd, &type));

	mov	edi, DWORD PTR _sd$[ebp]
	xor	ecx, ecx
$LN11@SzReadUnpa:

; 567  :     if (type == k7zIdEnd)

	mov	eax, DWORD PTR _type$80631[ebp]
	mov	edx, DWORD PTR _type$80631[ebp+4]
	mov	esi, eax
	or	esi, edx
	je	$LN50@SzReadUnpa

; 569  :     if (type == k7zIdCRC)

	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN7@SzReadUnpa
	cmp	edx, ecx
	jne	SHORT $LN7@SzReadUnpa

; 570  :     {
; 571  :       SRes res;
; 572  :       Byte *crcsDefined = 0;
; 573  :       UInt32 *crcs = 0;
; 574  :       res = SzReadHashDigests(sd, *numFolders, &crcsDefined, &crcs, allocTemp);

	mov	edx, DWORD PTR [ebx]
	lea	eax, DWORD PTR _crcs$80638[ebp]
	push	eax
	mov	DWORD PTR _crcsDefined$80637[ebp], ecx
	mov	DWORD PTR _crcs$80638[ebp], ecx
	lea	ecx, DWORD PTR _crcsDefined$80637[ebp]
	push	ecx
	push	edx
	push	edi
	mov	edi, DWORD PTR _allocTemp$[ebp]
	mov	eax, edi
	call	_SzReadHashDigests

; 575  :       if (res == SZ_OK)

	mov	esi, DWORD PTR _crcsDefined$80637[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _res$80636[ebp], eax
	test	eax, eax
	jne	SHORT $LN3@SzReadUnpa

; 576  :       {
; 577  :         for (i = 0; i < *numFolders; i++)

	xor	ecx, ecx
	cmp	DWORD PTR [ebx], ecx
	jbe	SHORT $LN3@SzReadUnpa
	xor	edx, edx
	npad	1
$LL60@SzReadUnpa:

; 578  :         {
; 579  :           CSzFolder *folder = (*folders) + i;
; 580  :           folder->UnpackCRCDefined = crcsDefined[i];

	movzx	edi, BYTE PTR [esi+ecx]
	mov	eax, DWORD PTR _folders$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+edx+28], edi

; 581  :           folder->UnpackCRC = crcs[i];

	mov	edi, DWORD PTR _crcs$80638[ebp]
	mov	edi, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR [eax+edx+32], edi
	inc	ecx
	add	edx, 40					; 00000028H
	cmp	ecx, DWORD PTR [ebx]
	jb	SHORT $LL60@SzReadUnpa

; 576  :       {
; 577  :         for (i = 0; i < *numFolders; i++)

	mov	edi, DWORD PTR _allocTemp$[ebp]
$LN3@SzReadUnpa:

; 582  :         }
; 583  :       }
; 584  :       IAlloc_Free(allocTemp, crcs);

	mov	ecx, DWORD PTR _crcs$80638[ebp]
	mov	edx, DWORD PTR [edi+4]
	push	ecx
	push	edi
	call	edx

; 585  :       IAlloc_Free(allocTemp, crcsDefined);

	mov	eax, DWORD PTR [edi+4]
	push	esi
	push	edi
	call	eax

; 586  :       RINOK(res);

	mov	eax, DWORD PTR _res$80636[ebp]
	add	esp, 16					; 00000010H

; 587  :       continue;

	jmp	SHORT $LN67@SzReadUnpa
$LN7@SzReadUnpa:

; 588  :     }
; 589  :     RINOK(SzSkeepData(sd));

	call	_SzSkeepData
$LN67@SzReadUnpa:
	test	eax, eax
	jne	SHORT $LN65@SzReadUnpa

; 560  :     }
; 561  :   }
; 562  : 
; 563  :   for (;;)
; 564  :   {
; 565  :     UInt64 type;
; 566  :     RINOK(SzReadID(sd, &type));

	mov	eax, DWORD PTR _sd$[ebp]
	lea	esi, DWORD PTR _type$80631[ebp]
	call	_SzReadID
	test	eax, eax
	je	$LL61@SzReadUnpa
	pop	esi
	pop	ebx
	pop	edi

; 590  :   }
; 591  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@SzReadUnpa:

; 568  :       return SZ_OK;

	xor	eax, eax
$LN65@SzReadUnpa:
	pop	esi
$LN64@SzReadUnpa:
	pop	ebx
$LN10@SzReadUnpa:
	pop	edi

; 590  :   }
; 591  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SzReadUnpackInfo ENDP
_TEXT	ENDS
EXTRN	_SzFolder_GetUnpackSize:PROC
; Function compile flags: /Ogtp
;	COMDAT _SzReadSubStreamsInfo
_TEXT	SEGMENT
_size$80715 = -40					; size = 8
_sum$80707 = -32					; size = 8
_type$ = -24						; size = 8
_res$80737 = -16					; size = 4
_numSubstreams$80709 = -16				; size = 4
tv892 = -12						; size = 4
tv650 = -12						; size = 4
_digestsDefined2$80735 = -12				; size = 4
_numStreams$80682 = -12					; size = 4
tv947 = -8						; size = 4
_i$ = -8						; size = 4
_numDigests$ = -4					; size = 4
_sd$ = 8						; size = 4
_numFolders$ = 12					; size = 4
_folders$ = 16						; size = 4
_digests2$80736 = 20					; size = 4
_numUnpackStreams$ = 20					; size = 4
_unpackSizes$ = 24					; size = 4
_digestsDefined$ = 28					; size = 4
_digests$ = 32						; size = 4
_allocTemp$ = 36					; size = 4
_SzReadSubStreamsInfo PROC				; COMDAT

; 602  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 604  :   UInt32 i;
; 605  :   UInt32 si = 0;
; 606  :   UInt32 numDigests = 0;
; 607  : 
; 608  :   for (i = 0; i < numFolders; i++)

	mov	edx, DWORD PTR _numFolders$[ebp]
	push	ebx
	xor	ebx, ebx
	push	esi
	push	edi
	mov	DWORD PTR _type$[ebp], ebx
	mov	DWORD PTR _type$[ebp+4], ebx
	mov	DWORD PTR _numDigests$[ebp], ebx
	cmp	edx, ebx
	jbe	SHORT $LN94@SzReadSubS

; 603  :   UInt64 type = 0;

	mov	eax, DWORD PTR _folders$[ebp]
	add	eax, 36					; 00000024H
	mov	ecx, edx
$LL57@SzReadSubS:

; 609  :     folders[i].NumUnpackStreams = 1;

	mov	DWORD PTR [eax], 1
	add	eax, 40					; 00000028H
	dec	ecx
	jne	SHORT $LL57@SzReadSubS
$LN94@SzReadSubS:

; 610  :   *numUnpackStreams = numFolders;

	mov	edi, DWORD PTR _numUnpackStreams$[ebp]

; 611  : 
; 612  :   for (;;)
; 613  :   {
; 614  :     RINOK(SzReadID(sd, &type));

	mov	eax, DWORD PTR _sd$[ebp]
	lea	esi, DWORD PTR _type$[ebp]
	mov	DWORD PTR [edi], edx
	call	_SzReadID
	test	eax, eax
	jne	$LN17@SzReadSubS
$LL54@SzReadSubS:

; 615  :     if (type == k7zIdNumUnpackStream)

	mov	esi, DWORD PTR _type$[ebp]
	cmp	esi, 13					; 0000000dH
	jne	SHORT $LN102@SzReadSubS
	cmp	DWORD PTR _type$[ebp+4], ebx
	jne	SHORT $LN102@SzReadSubS

; 618  :       for (i = 0; i < numFolders; i++)

	xor	esi, esi
	mov	DWORD PTR [edi], ebx
	cmp	DWORD PTR _numFolders$[ebp], ebx
	jbe	SHORT $LN43@SzReadSubS

; 616  :     {
; 617  :       *numUnpackStreams = 0;

	mov	edi, DWORD PTR _folders$[ebp]
	add	edi, 36					; 00000024H
$LL50@SzReadSubS:

; 619  :       {
; 620  :         UInt32 numStreams;
; 621  :         RINOK(SzReadNumber32(sd, &numStreams));

	lea	eax, DWORD PTR _numStreams$80682[ebp]
	push	eax
	mov	eax, DWORD PTR _sd$[ebp]
	call	_SzReadNumber32
	add	esp, 4
	test	eax, eax
	jne	$LN17@SzReadSubS

; 622  :         folders[i].NumUnpackStreams = numStreams;

	mov	eax, DWORD PTR _numStreams$80682[ebp]

; 623  :         *numUnpackStreams += numStreams;

	mov	ecx, DWORD PTR _numUnpackStreams$[ebp]
	mov	DWORD PTR [edi], eax
	add	DWORD PTR [ecx], eax
	inc	esi
	add	edi, 40					; 00000028H
	cmp	esi, DWORD PTR _numFolders$[ebp]
	jb	SHORT $LL50@SzReadSubS

; 624  :       }
; 625  :       continue;

	mov	edi, ecx
	jmp	SHORT $LN43@SzReadSubS
$LN102@SzReadSubS:

; 626  :     }
; 627  :     if (type == k7zIdCRC || type == k7zIdSize)

	mov	eax, DWORD PTR _type$[ebp+4]
	cmp	esi, 10					; 0000000aH
	jne	SHORT $LN91@SzReadSubS
	test	eax, eax
	je	SHORT $LN100@SzReadSubS
$LN91@SzReadSubS:
	cmp	esi, 9
	jne	SHORT $LN110@SzReadSubS
	test	eax, eax
	je	SHORT $LN100@SzReadSubS
$LN110@SzReadSubS:

; 628  :       break;
; 629  :     if (type == k7zIdEnd)

	mov	ecx, esi
	or	ecx, eax
	je	SHORT $LN100@SzReadSubS

; 630  :       break;
; 631  :     RINOK(SzSkeepData(sd));

	mov	edi, DWORD PTR _sd$[ebp]
	call	_SzSkeepData
	test	eax, eax
	jne	$LN17@SzReadSubS
	mov	edi, DWORD PTR _numUnpackStreams$[ebp]
$LN43@SzReadSubS:

; 611  : 
; 612  :   for (;;)
; 613  :   {
; 614  :     RINOK(SzReadID(sd, &type));

	mov	eax, DWORD PTR _sd$[ebp]
	lea	esi, DWORD PTR _type$[ebp]
	call	_SzReadID
	test	eax, eax
	je	$LL54@SzReadSubS
	pop	edi
	pop	esi
	pop	ebx

; 736  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN100@SzReadSubS:

; 632  :   }
; 633  : 
; 634  :   if (*numUnpackStreams == 0)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jne	SHORT $LN42@SzReadSubS

; 635  :   {
; 636  :     *unpackSizes = 0;

	mov	edx, DWORD PTR _unpackSizes$[ebp]

; 637  :     *digestsDefined = 0;

	mov	eax, DWORD PTR _digestsDefined$[ebp]

; 638  :     *digests = 0;

	mov	ecx, DWORD PTR _digests$[ebp]
	mov	DWORD PTR [edx], ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [ecx], ebx

; 639  :   }
; 640  :   else

	jmp	SHORT $LN38@SzReadSubS
$LN42@SzReadSubS:

; 641  :   {
; 642  :     *unpackSizes = (UInt64 *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(UInt64));

	mov	esi, DWORD PTR _allocTemp$[ebp]
	lea	edx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR [esi]
	push	edx
	push	esi
	call	eax
	mov	ecx, DWORD PTR _unpackSizes$[ebp]
	add	esp, 8
	mov	DWORD PTR [ecx], eax

; 643  :     RINOM(*unpackSizes);

	test	eax, eax
	jne	SHORT $LN40@SzReadSubS
$LN112@SzReadSubS:
	pop	edi
	pop	esi
	mov	eax, 2
	pop	ebx

; 736  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@SzReadSubS:

; 644  :     *digestsDefined = (Byte *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(Byte));

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [esi]
	push	edx
	push	esi
	call	eax
	mov	ecx, DWORD PTR _digestsDefined$[ebp]
	add	esp, 8
	mov	DWORD PTR [ecx], eax

; 645  :     RINOM(*digestsDefined);

	test	eax, eax
	je	SHORT $LN112@SzReadSubS

; 646  :     *digests = (UInt32 *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(UInt32));

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [esi]
	add	edx, edx
	add	edx, edx
	push	edx
	push	esi
	call	eax
	mov	ecx, DWORD PTR _digests$[ebp]
	add	esp, 8
	mov	DWORD PTR [ecx], eax

; 647  :     RINOM(*digests);

	test	eax, eax
	je	SHORT $LN112@SzReadSubS
	mov	esi, DWORD PTR _type$[ebp]
$LN38@SzReadSubS:

; 648  :   }
; 649  : 
; 650  :   for (i = 0; i < numFolders; i++)

	mov	edx, DWORD PTR _numFolders$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	edx, ecx
	jbe	$LN104@SzReadSubS
	mov	esi, DWORD PTR _folders$[ebp]
	mov	DWORD PTR tv650[ebp], esi
	npad	3
$LL37@SzReadSubS:

; 651  :   {
; 652  :     /*
; 653  :     v3.13 incorrectly worked with empty folders
; 654  :     v4.07: we check that folder is empty
; 655  :     */
; 656  :     UInt64 sum = 0;
; 657  :     UInt32 j;
; 658  :     UInt32 numSubstreams = folders[i].NumUnpackStreams;

	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR _sum$80707[ebp], ecx
	mov	DWORD PTR _sum$80707[ebp+4], ecx
	mov	DWORD PTR _numSubstreams$80709[ebp], eax

; 659  :     if (numSubstreams == 0)

	cmp	eax, ecx
	je	SHORT $LN36@SzReadSubS

; 660  :       continue;
; 661  :     if (type == k7zIdSize)

	cmp	DWORD PTR _type$[ebp], 9
	jne	SHORT $LN30@SzReadSubS
	cmp	DWORD PTR _type$[ebp+4], ecx
	jne	SHORT $LN30@SzReadSubS

; 662  :     for (j = 1; j < numSubstreams; j++)

	cmp	eax, 1
	jbe	SHORT $LN30@SzReadSubS
	mov	edi, 1
$LL32@SzReadSubS:

; 663  :     {
; 664  :       UInt64 size;
; 665  :       RINOK(SzReadNumber(sd, &size));

	mov	edx, DWORD PTR _sd$[ebp]
	push	edx
	lea	esi, DWORD PTR _size$80715[ebp]
	call	_SzReadNumber
	add	esp, 4
	test	eax, eax
	jne	$LN17@SzReadSubS

; 666  :       (*unpackSizes)[si++] = size;

	mov	eax, DWORD PTR _unpackSizes$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR _size$80715[ebp]
	mov	edx, DWORD PTR _size$80715[ebp+4]
	mov	DWORD PTR [eax+ebx*8], ecx
	mov	DWORD PTR [eax+ebx*8+4], edx
	inc	ebx
	inc	edi

; 667  :       sum += size;

	add	DWORD PTR _sum$80707[ebp], ecx
	adc	DWORD PTR _sum$80707[ebp+4], edx
	cmp	edi, DWORD PTR _numSubstreams$80709[ebp]
	jb	SHORT $LL32@SzReadSubS

; 662  :     for (j = 1; j < numSubstreams; j++)

	mov	esi, DWORD PTR tv650[ebp]
	mov	edi, DWORD PTR _numUnpackStreams$[ebp]
$LN30@SzReadSubS:

; 668  :     }
; 669  :     (*unpackSizes)[si++] = SzFolder_GetUnpackSize(folders + i) - sum;

	push	esi
	call	_SzFolder_GetUnpackSize
	mov	ecx, eax
	mov	eax, DWORD PTR _unpackSizes$[ebp]
	mov	eax, DWORD PTR [eax]
	add	esp, 4
	sub	ecx, DWORD PTR _sum$80707[ebp]
	sbb	edx, DWORD PTR _sum$80707[ebp+4]
	mov	DWORD PTR [eax+ebx*8], ecx
	mov	DWORD PTR [eax+ebx*8+4], edx
	mov	edx, DWORD PTR _numFolders$[ebp]
	inc	ebx
$LN36@SzReadSubS:

; 648  :   }
; 649  : 
; 650  :   for (i = 0; i < numFolders; i++)

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	esi, 40					; 00000028H

; 733  :     }
; 734  :     RINOK(SzReadID(sd, &type));

	xor	ecx, ecx
	mov	DWORD PTR _i$[ebp], eax
	mov	DWORD PTR tv650[ebp], esi
	cmp	eax, edx
	jb	$LL37@SzReadSubS
	mov	esi, DWORD PTR _type$[ebp]
$LN104@SzReadSubS:

; 670  :   }
; 671  :   if (type == k7zIdSize)

	cmp	esi, 9
	jne	SHORT $LN27@SzReadSubS
	cmp	DWORD PTR _type$[ebp+4], ecx
	jne	SHORT $LN27@SzReadSubS

; 672  :   {
; 673  :     RINOK(SzReadID(sd, &type));

	mov	eax, DWORD PTR _sd$[ebp]
	lea	esi, DWORD PTR _type$[ebp]
	call	_SzReadID
	test	eax, eax
	jne	$LN17@SzReadSubS
	mov	edx, DWORD PTR _numFolders$[ebp]
	mov	esi, DWORD PTR _type$[ebp]
$LN27@SzReadSubS:

; 674  :   }
; 675  : 
; 676  :   for (i = 0; i < *numUnpackStreams; i++)

	xor	eax, eax
	cmp	DWORD PTR [edi], eax
	jbe	SHORT $LN24@SzReadSubS
	mov	ecx, DWORD PTR _digests$[ebp]
	npad	8
$LL107@SzReadSubS:

; 677  :   {
; 678  :     (*digestsDefined)[i] = 0;

	mov	ebx, DWORD PTR _digestsDefined$[ebp]
	mov	ebx, DWORD PTR [ebx]
	mov	BYTE PTR [eax+ebx], 0

; 679  :     (*digests)[i] = 0;

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [ebx+eax*4], 0
	inc	eax
	cmp	eax, DWORD PTR [edi]
	jb	SHORT $LL107@SzReadSubS
$LN24@SzReadSubS:

; 680  :   }
; 681  : 
; 682  : 
; 683  :   for (i = 0; i < numFolders; i++)

	test	edx, edx
	je	SHORT $LN98@SzReadSubS
	mov	eax, DWORD PTR _folders$[ebp]
	add	eax, 28					; 0000001cH
$LL23@SzReadSubS:

; 684  :   {
; 685  :     UInt32 numSubstreams = folders[i].NumUnpackStreams;

	mov	ecx, DWORD PTR [eax+8]

; 686  :     if (numSubstreams != 1 || !folders[i].UnpackCRCDefined)

	cmp	ecx, 1
	jne	SHORT $LN19@SzReadSubS
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN22@SzReadSubS
$LN19@SzReadSubS:

; 687  :       numDigests += numSubstreams;

	add	DWORD PTR _numDigests$[ebp], ecx
$LN22@SzReadSubS:

; 680  :   }
; 681  : 
; 682  : 
; 683  :   for (i = 0; i < numFolders; i++)

	add	eax, 40					; 00000028H
	dec	edx
	jne	SHORT $LL23@SzReadSubS
$LN98@SzReadSubS:

; 688  :   }
; 689  : 
; 690  :  
; 691  :   si = 0;

	xor	ebx, ebx
	npad	7
$LL18@SzReadSubS:

; 692  :   for (;;)
; 693  :   {
; 694  :     if (type == k7zIdCRC)

	cmp	esi, 10					; 0000000aH
	jne	$LN16@SzReadSubS
	xor	esi, esi
	cmp	DWORD PTR _type$[ebp+4], esi
	jne	$LN105@SzReadSubS

; 695  :     {
; 696  :       int digestIndex = 0;
; 697  :       Byte *digestsDefined2 = 0;
; 698  :       UInt32 *digests2 = 0;
; 699  :       SRes res = SzReadHashDigests(sd, numDigests, &digestsDefined2, &digests2, allocTemp);

	mov	eax, DWORD PTR _numDigests$[ebp]
	lea	ecx, DWORD PTR _digests2$80736[ebp]
	push	ecx
	mov	ecx, DWORD PTR _sd$[ebp]
	lea	edx, DWORD PTR _digestsDefined2$80735[ebp]
	push	edx
	push	eax
	mov	eax, DWORD PTR _allocTemp$[ebp]
	push	ecx
	mov	DWORD PTR _digestsDefined2$80735[ebp], esi
	mov	DWORD PTR _digests2$80736[ebp], esi
	call	_SzReadHashDigests

; 700  :       if (res == SZ_OK)

	mov	edi, DWORD PTR _digestsDefined2$80735[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _res$80737[ebp], eax
	cmp	eax, esi
	jne	SHORT $LN12@SzReadSubS

; 701  :       {
; 702  :         for (i = 0; i < numFolders; i++)

	mov	eax, DWORD PTR _numFolders$[ebp]
	test	eax, eax
	je	SHORT $LN12@SzReadSubS
	mov	ecx, DWORD PTR _folders$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR tv892[ebp], ecx
	mov	DWORD PTR tv947[ebp], eax
$LL109@SzReadSubS:

; 703  :         {
; 704  :           CSzFolder *folder = folders + i;
; 705  :           UInt32 numSubstreams = folder->NumUnpackStreams;

	mov	eax, DWORD PTR [ecx+8]

; 706  :           if (numSubstreams == 1 && folder->UnpackCRCDefined)

	cmp	eax, 1
	jne	SHORT $LN11@SzReadSubS
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LL90@SzReadSubS

; 707  :           {
; 708  :             (*digestsDefined)[si] = 1;

	mov	edx, DWORD PTR _digestsDefined$[ebp]
	mov	eax, DWORD PTR [edx]

; 709  :             (*digests)[si] = folder->UnpackCRC;

	mov	edx, DWORD PTR _digests$[ebp]
	mov	BYTE PTR [ebx+eax], 1
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+ebx*4], edx

; 710  :             si++;

	inc	ebx

; 711  :           }
; 712  :           else

	jmp	SHORT $LN13@SzReadSubS
$LN11@SzReadSubS:

; 713  :           {
; 714  :             UInt32 j;
; 715  :             for (j = 0; j < numSubstreams; j++, digestIndex++)

	test	eax, eax
	je	SHORT $LN13@SzReadSubS
	npad	6
$LL90@SzReadSubS:

; 716  :             {
; 717  :               (*digestsDefined)[si] = digestsDefined2[digestIndex];

	mov	ecx, DWORD PTR _digestsDefined$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	cl, BYTE PTR [edi+esi]
	mov	BYTE PTR [ebx+edx], cl

; 718  :               (*digests)[si] = digests2[digestIndex];

	mov	edx, DWORD PTR _digests$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _digests2$80736[ebp]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	DWORD PTR [ecx+ebx*4], edx

; 719  :               si++;

	inc	ebx
	inc	esi
	dec	eax
	jne	SHORT $LL90@SzReadSubS

; 713  :           {
; 714  :             UInt32 j;
; 715  :             for (j = 0; j < numSubstreams; j++, digestIndex++)

	mov	ecx, DWORD PTR tv892[ebp]
$LN13@SzReadSubS:

; 701  :       {
; 702  :         for (i = 0; i < numFolders; i++)

	add	ecx, 40					; 00000028H
	dec	DWORD PTR tv947[ebp]
	mov	DWORD PTR tv892[ebp], ecx
	jne	SHORT $LL109@SzReadSubS
$LN12@SzReadSubS:

; 720  :             }
; 721  :           }
; 722  :         }
; 723  :       }
; 724  :       IAlloc_Free(allocTemp, digestsDefined2);

	mov	esi, DWORD PTR _allocTemp$[ebp]
	mov	eax, DWORD PTR [esi+4]
	push	edi
	push	esi
	call	eax

; 725  :       IAlloc_Free(allocTemp, digests2);

	mov	ecx, DWORD PTR _digests2$80736[ebp]
	mov	edx, DWORD PTR [esi+4]
	push	ecx
	push	esi
	call	edx

; 726  :       RINOK(res);

	mov	eax, DWORD PTR _res$80737[ebp]
	add	esp, 16					; 00000010H

; 727  :     }
; 728  :     else if (type == k7zIdEnd)

	jmp	SHORT $LN114@SzReadSubS
$LN105@SzReadSubS:
	mov	esi, DWORD PTR _type$[ebp]
$LN16@SzReadSubS:
	or	esi, DWORD PTR _type$[ebp+4]
	je	SHORT $LN79@SzReadSubS

; 730  :     else
; 731  :     {
; 732  :       RINOK(SzSkeepData(sd));

	mov	edi, DWORD PTR _sd$[ebp]
	call	_SzSkeepData
$LN114@SzReadSubS:
	test	eax, eax
	jne	SHORT $LN17@SzReadSubS

; 733  :     }
; 734  :     RINOK(SzReadID(sd, &type));

	mov	eax, DWORD PTR _sd$[ebp]
	lea	esi, DWORD PTR _type$[ebp]
	call	_SzReadID
	test	eax, eax
	jne	SHORT $LN17@SzReadSubS

; 735  :   }

	mov	esi, DWORD PTR _type$[ebp]
	jmp	$LL18@SzReadSubS
$LN79@SzReadSubS:

; 729  :       return SZ_OK;

	xor	eax, eax
$LN17@SzReadSubS:
	pop	edi
	pop	esi
	pop	ebx

; 736  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SzReadSubStreamsInfo ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _SzReadStreamsInfo
_TEXT	SEGMENT
_type$80782 = -8					; size = 8
_dataOffset$ = 8					; size = 4
_numUnpackStreams$ = 12					; size = 4
_unpackSizes$ = 16					; size = 4
_digestsDefined$ = 20					; size = 4
_digests$ = 24						; size = 4
_alloc$ = 28						; size = 4
_allocTemp$ = 32					; size = 4
_SzReadStreamsInfo PROC					; COMDAT
; _sd$ = ebx
; _p$ = edi

; 749  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 750  :   for (;;)
; 751  :   {
; 752  :     UInt64 type;
; 753  :     RINOK(SzReadID(sd, &type));

	lea	esi, DWORD PTR _type$80782[ebp]
	mov	eax, ebx
	call	_SzReadID
	test	eax, eax
	jne	$LN13@SzReadStre
	npad	7
$LL14@SzReadStre:

; 754  :     if ((UInt64)(int)type != type)

	mov	ecx, DWORD PTR _type$80782[ebp]
	mov	eax, ecx
	cdq
	cmp	eax, ecx
	jne	$LN1@SzReadStre
	cmp	edx, DWORD PTR _type$80782[ebp+4]
	jne	$LN1@SzReadStre

; 755  :       return SZ_ERROR_UNSUPPORTED;
; 756  :     switch((int)type)

	cmp	ecx, 8
	ja	$LN1@SzReadStre
	jmp	DWORD PTR $LN26@SzReadStre[ecx*4]
$LN7@SzReadStre:

; 760  :       case k7zIdPackInfo:
; 761  :       {
; 762  :         RINOK(SzReadPackInfo(sd, dataOffset, &p->NumPackStreams,
; 763  :             &p->PackSizes, &p->PackCRCsDefined, &p->PackCRCs, alloc));

	mov	eax, DWORD PTR _alloc$[ebp]
	push	eax
	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, DWORD PTR _dataOffset$[ebp]
	lea	edx, DWORD PTR [edi+4]
	push	edx
	lea	eax, DWORD PTR [edi+20]
	push	edi
	push	eax
	mov	eax, ebx
	call	_SzReadPackInfo
	add	esp, 20					; 00000014H

; 764  :         break;

	jmp	SHORT $LN25@SzReadStre
$LN5@SzReadStre:

; 765  :       }
; 766  :       case k7zIdUnpackInfo:
; 767  :       {
; 768  :         RINOK(SzReadUnpackInfo(sd, &p->NumFolders, &p->Folders, alloc, allocTemp));

	mov	ecx, DWORD PTR _allocTemp$[ebp]
	mov	edx, DWORD PTR _alloc$[ebp]
	push	ecx
	push	edx
	lea	eax, DWORD PTR [edi+12]
	push	eax
	lea	ecx, DWORD PTR [edi+24]
	push	ecx
	push	ebx
	call	_SzReadUnpackInfo
	add	esp, 20					; 00000014H

; 769  :         break;

	jmp	SHORT $LN25@SzReadStre
$LN3@SzReadStre:

; 770  :       }
; 771  :       case k7zIdSubStreamsInfo:
; 772  :       {
; 773  :         RINOK(SzReadSubStreamsInfo(sd, p->NumFolders, p->Folders,
; 774  :             numUnpackStreams, unpackSizes, digestsDefined, digests, allocTemp));

	mov	edx, DWORD PTR _allocTemp$[ebp]
	mov	eax, DWORD PTR _digests$[ebp]
	mov	ecx, DWORD PTR _digestsDefined$[ebp]
	push	edx
	mov	edx, DWORD PTR _unpackSizes$[ebp]
	push	eax
	mov	eax, DWORD PTR _numUnpackStreams$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [edi+12]
	push	edx
	mov	edx, DWORD PTR [edi+24]
	push	eax
	push	ecx
	push	edx
	push	ebx
	call	_SzReadSubStreamsInfo
	add	esp, 32					; 00000020H
$LN25@SzReadStre:
	test	eax, eax
	jne	SHORT $LN13@SzReadStre

; 750  :   for (;;)
; 751  :   {
; 752  :     UInt64 type;
; 753  :     RINOK(SzReadID(sd, &type));

	lea	esi, DWORD PTR _type$80782[ebp]
	mov	eax, ebx
	call	_SzReadID
	test	eax, eax
	je	$LL14@SzReadStre
	pop	esi

; 779  :     }
; 780  :   }
; 781  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@SzReadStre:

; 757  :     {
; 758  :       case k7zIdEnd:
; 759  :         return SZ_OK;

	xor	eax, eax
	pop	esi

; 779  :     }
; 780  :   }
; 781  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@SzReadStre:

; 775  :         break;
; 776  :       }
; 777  :       default:
; 778  :         return SZ_ERROR_UNSUPPORTED;

	mov	eax, 4
$LN13@SzReadStre:
	pop	esi

; 779  :     }
; 780  :   }
; 781  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN26@SzReadStre:
	DD	$LN8@SzReadStre
	DD	$LN1@SzReadStre
	DD	$LN1@SzReadStre
	DD	$LN1@SzReadStre
	DD	$LN1@SzReadStre
	DD	$LN1@SzReadStre
	DD	$LN7@SzReadStre
	DD	$LN5@SzReadStre
	DD	$LN3@SzReadStre
_SzReadStreamsInfo ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _SzReadFileNames
_TEXT	SEGMENT
_len$80819 = -20					; size = 4
_i$ = -16						; size = 4
tv293 = -12						; size = 4
tv480 = -8						; size = 4
tv557 = -4						; size = 4
_sd$ = 8						; size = 4
_numFiles$ = 12						; size = 4
_alloc$ = 16						; size = 4
_SzReadFileNames PROC					; COMDAT
; _files$ = eax

; 786  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 787  :   UInt32 i;
; 788  :   for (i = 0; i < numFiles; i++)

	cmp	DWORD PTR _numFiles$[ebp], 0
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _i$[ebp], 0
	jbe	$LN29@SzReadFile
	mov	DWORD PTR tv557[ebp], eax
	npad	3
$LL65@SzReadFile:

; 791  :     UInt32 pos = 0;
; 792  :     CSzFileItem *file = files + i;
; 793  :     while (pos + 2 <= sd->Size)

	mov	esi, DWORD PTR _sd$[ebp]
	mov	eax, DWORD PTR [esi+4]
	xor	ecx, ecx
	mov	DWORD PTR tv293[ebp], eax
	cmp	eax, 2
	jb	$LN56@SzReadFile

; 789  :   {
; 790  :     UInt32 len = 0;

	mov	edx, DWORD PTR [esi]
	lea	ebx, DWORD PTR [ecx+2]
	lea	edi, DWORD PTR [edx+1]
	npad	4
$LL28@SzReadFile:

; 794  :     {
; 795  :       int numAdds;
; 796  :       UInt32 value = (UInt32)(sd->Data[pos] | (((UInt32)sd->Data[pos + 1]) << 8));

	movzx	eax, BYTE PTR [edi]
	movzx	esi, BYTE PTR [edx]
	shl	eax, 8

; 797  :       pos += 2;

	add	ebx, 2

; 798  :       len++;

	inc	ecx
	add	edi, 2
	add	edx, 2
	or	eax, esi
	mov	DWORD PTR tv480[ebp], ebx
	mov	DWORD PTR _len$80819[ebp], ecx

; 799  :       if (value == 0)

	je	$LN59@SzReadFile

; 800  :         break;
; 801  :       if (value < 0x80)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN58@SzReadFile

; 802  :         continue;
; 803  :       if (value >= 0xD800 && value < 0xE000)

	lea	ecx, DWORD PTR [eax-55296]
	cmp	ecx, 2047				; 000007ffH
	ja	SHORT $LN24@SzReadFile

; 804  :       {
; 805  :         UInt32 c2;
; 806  :         if (value >= 0xDC00)

	cmp	eax, 56320				; 0000dc00H
	jae	$LN44@SzReadFile

; 808  :         if (pos + 2 > sd->Size)

	cmp	ebx, DWORD PTR tv293[ebp]
	ja	$LN44@SzReadFile

; 809  :           return SZ_ERROR_ARCHIVE;
; 810  :         c2 = (UInt32)(sd->Data[pos] | (((UInt32)sd->Data[pos + 1]) << 8));

	movzx	eax, BYTE PTR [edi]
	movzx	esi, BYTE PTR [edx]
	shl	eax, 8
	or	eax, esi

; 811  :         pos += 2;

	add	ebx, 2

; 812  :         if (c2 < 0xDC00 || c2 >= 0xE000)

	add	eax, -56320				; ffff2400H
	add	edi, 2
	add	edx, 2
	mov	DWORD PTR tv480[ebp], ebx
	cmp	eax, 1023				; 000003ffH
	ja	$LN44@SzReadFile

; 813  :           return SZ_ERROR_ARCHIVE;
; 814  :         value = ((value - 0xD800) << 10) | (c2 - 0xDC00);

	shl	ecx, 10					; 0000000aH
	or	eax, ecx
$LN24@SzReadFile:

; 815  :       }
; 816  :       for (numAdds = 1; numAdds < 5; numAdds++)

	mov	ebx, 1
	mov	ecx, 11					; 0000000bH
$LL19@SzReadFile:

; 817  :         if (value < (((UInt32)1) << (numAdds * 5 + 6)))

	mov	esi, 1
	shl	esi, cl
	cmp	eax, esi
	jb	SHORT $LN57@SzReadFile

; 815  :       }
; 816  :       for (numAdds = 1; numAdds < 5; numAdds++)

	add	ecx, 5
	inc	ebx
	cmp	ecx, 31					; 0000001fH
	jl	SHORT $LL19@SzReadFile
$LN57@SzReadFile:

; 818  :           break;
; 819  :       len += numAdds;

	mov	ecx, DWORD PTR _len$80819[ebp]
	add	ecx, ebx
	mov	ebx, DWORD PTR tv480[ebp]
$LN58@SzReadFile:
	mov	esi, DWORD PTR _sd$[ebp]
	cmp	ebx, DWORD PTR tv293[ebp]
	jbe	$LL28@SzReadFile

; 791  :     UInt32 pos = 0;
; 792  :     CSzFileItem *file = files + i;
; 793  :     while (pos + 2 <= sd->Size)

	jmp	SHORT $LN43@SzReadFile
$LN59@SzReadFile:
	mov	esi, DWORD PTR _sd$[ebp]
$LN43@SzReadFile:

; 820  :     }
; 821  : 
; 822  :     MY_ALLOC(char, file->Name, (size_t)len, alloc);

	test	ecx, ecx
	jne	SHORT $LN15@SzReadFile
$LN56@SzReadFile:
	mov	ecx, DWORD PTR tv557[ebp]
	mov	DWORD PTR [ecx+16], 0
	jmp	SHORT $LN13@SzReadFile
$LN15@SzReadFile:
	mov	eax, DWORD PTR _alloc$[ebp]
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	eax
	call	edx
	mov	ecx, DWORD PTR tv557[ebp]
	add	esp, 8
	mov	DWORD PTR [ecx+16], eax
	test	eax, eax
	je	$LN49@SzReadFile
$LN13@SzReadFile:

; 823  : 
; 824  :     len = 0;

	xor	edi, edi

; 825  :     while (2 <= sd->Size)

	cmp	DWORD PTR [esi+4], 2
	jb	$LN30@SzReadFile
$LL12@SzReadFile:

; 826  :     {
; 827  :       int numAdds;
; 828  :       UInt32 value = (UInt32)(sd->Data[0] | (((UInt32)sd->Data[1]) << 8));

	mov	eax, DWORD PTR [esi]
	movzx	ebx, BYTE PTR [eax+1]
	movzx	edx, BYTE PTR [eax]

; 829  :       SzSkeepDataSize(sd, 2);

	push	0
	shl	ebx, 8
	push	2
	mov	ecx, esi
	or	ebx, edx
	call	_SzSkeepDataSize
	add	esp, 8

; 830  :       if (value < 0x80)

	cmp	ebx, 128				; 00000080H
	jae	SHORT $LN10@SzReadFile

; 831  :       {
; 832  :         file->Name[len++] = (char)value;

	mov	eax, DWORD PTR tv557[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	BYTE PTR [edi+ecx], bl
	inc	edi

; 833  :         if (value == 0)

	test	ebx, ebx
	je	$LN30@SzReadFile

; 834  :           break;
; 835  :         continue;

	jmp	$LN53@SzReadFile
$LN10@SzReadFile:

; 836  :       }
; 837  :       if (value >= 0xD800 && value < 0xE000)

	lea	esi, DWORD PTR [ebx-55296]
	cmp	esi, 2047				; 000007ffH
	ja	SHORT $LN8@SzReadFile

; 838  :       {
; 839  :         UInt32 c2 = (UInt32)(sd->Data[0] | (((UInt32)sd->Data[1]) << 8));

	mov	ecx, DWORD PTR _sd$[ebp]
	mov	eax, DWORD PTR [ecx]
	movzx	ebx, BYTE PTR [eax+1]
	movzx	edx, BYTE PTR [eax]

; 840  :         SzSkeepDataSize(sd, 2);

	push	0
	shl	ebx, 8
	push	2
	or	ebx, edx
	call	_SzSkeepDataSize

; 841  :         value = ((value - 0xD800) << 10) | (c2 - 0xDC00);

	add	ebx, -56320				; ffff2400H
	shl	esi, 10					; 0000000aH
	add	esp, 8
	or	ebx, esi
$LN8@SzReadFile:

; 842  :       }
; 843  :       for (numAdds = 1; numAdds < 5; numAdds++)

	mov	esi, 1
	mov	ecx, 11					; 0000000bH
	npad	2
$LL7@SzReadFile:

; 844  :         if (value < (((UInt32)1) << (numAdds * 5 + 6)))

	mov	eax, 1
	shl	eax, cl
	cmp	ebx, eax
	jb	SHORT $LN47@SzReadFile

; 842  :       }
; 843  :       for (numAdds = 1; numAdds < 5; numAdds++)

	add	ecx, 5
	inc	esi
	cmp	ecx, 31					; 0000001fH
	jl	SHORT $LL7@SzReadFile
$LN47@SzReadFile:

; 845  :           break;
; 846  :       file->Name[len++] = (char)(kUtf8Limits[numAdds - 1] + (value >> (6 * numAdds)));

	mov	eax, DWORD PTR tv557[ebp]
	mov	eax, DWORD PTR [eax+16]
	lea	ecx, DWORD PTR [esi+esi*2]
	add	ecx, ecx
	mov	edx, ebx
	shr	edx, cl
	add	dl, BYTE PTR _kUtf8Limits[esi-1]
	inc	edi
	mov	BYTE PTR [edi+eax-1], dl
	npad	2
$LL3@SzReadFile:

; 847  :       do
; 848  :       {
; 849  :         numAdds--;
; 850  :         file->Name[len++] = (char)(0x80 + ((value >> (6 * numAdds)) & 0x3F));

	mov	eax, DWORD PTR tv557[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	ecx, 6
	mov	edx, ebx
	shr	edx, cl
	dec	esi
	inc	edi
	and	dl, 63					; 0000003fH
	add	dl, -128				; ffffff80H
	mov	BYTE PTR [edi+eax-1], dl

; 851  :       }
; 852  :       while (numAdds > 0);

	test	esi, esi
	jg	SHORT $LL3@SzReadFile

; 853  : 
; 854  :       len += numAdds;

	add	edi, esi
	mov	esi, DWORD PTR _sd$[ebp]
$LN53@SzReadFile:

; 825  :     while (2 <= sd->Size)

	cmp	DWORD PTR [esi+4], 2
	jae	$LL12@SzReadFile
$LN30@SzReadFile:

; 787  :   UInt32 i;
; 788  :   for (i = 0; i < numFiles; i++)

	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv557[ebp], 32		; 00000020H
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _numFiles$[ebp]
	jb	$LL65@SzReadFile
$LN29@SzReadFile:
	pop	edi
	pop	esi

; 855  :     }
; 856  :   }
; 857  :   return SZ_OK;

	xor	eax, eax
	pop	ebx

; 858  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@SzReadFile:
	pop	edi
	pop	esi

; 807  :           return SZ_ERROR_ARCHIVE;

	mov	eax, 16					; 00000010H
	pop	ebx

; 858  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN49@SzReadFile:
	pop	edi
	pop	esi

; 820  :     }
; 821  : 
; 822  :     MY_ALLOC(char, file->Name, (size_t)len, alloc);

	mov	eax, 2
	pop	ebx

; 858  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SzReadFileNames ENDP
_TEXT	ENDS
EXTRN	_SzFile_Init:PROC
; Function compile flags: /Ogtp
;	COMDAT _SzReadHeader2
_TEXT	SEGMENT
_type$80932 = -36					; size = 8
_size$80933 = -28					; size = 8
_i$ = -20						; size = 4
_numUnpackStreams$ = -20				; size = 4
_numEmptyStreams$ = -16					; size = 4
_type$ = -12						; size = 8
_files$ = -8						; size = 4
_numFiles$ = -4						; size = 4
_p$ = 8							; size = 4
_sd$ = 12						; size = 4
_unpackSizes$ = 16					; size = 4
_digestsDefined$ = 20					; size = 4
_digests$ = 24						; size = 4
_emptyStreamVector$ = 28				; size = 4
_emptyFileVector$ = 32					; size = 4
_lwtVector$ = 36					; size = 4
_allocMain$ = 40					; size = 4
_allocTemp$ = 44					; size = 4
_SzReadHeader2 PROC					; COMDAT

; 871  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx

; 872  :   UInt64 type;
; 873  :   UInt32 numUnpackStreams = 0;
; 874  :   UInt32 numFiles = 0;
; 875  :   CSzFileItem *files = 0;
; 876  :   UInt32 numEmptyStreams = 0;
; 877  :   UInt32 i;
; 878  : 
; 879  :   RINOK(SzReadID(sd, &type));

	mov	ebx, DWORD PTR _sd$[ebp]
	push	esi
	push	edi
	xor	edi, edi
	lea	esi, DWORD PTR _type$[ebp]
	mov	eax, ebx
	mov	DWORD PTR _numUnpackStreams$[ebp], edi
	mov	DWORD PTR _numFiles$[ebp], edi
	mov	DWORD PTR _numEmptyStreams$[ebp], edi
	call	_SzReadID
	cmp	eax, edi
	jne	$LN58@SzReadHead

; 880  : 
; 881  :   if (type == k7zIdArchiveProperties)

	mov	eax, DWORD PTR _type$[ebp]
	cmp	eax, 2
	jne	SHORT $LN87@SzReadHead
	cmp	DWORD PTR _type$[ebp+4], edi
	jne	SHORT $LN87@SzReadHead

; 882  :   {
; 883  :     RINOK(SzReadArchiveProperties(sd));

	mov	eax, ebx
	call	_SzReadArchiveProperties
	cmp	eax, edi
	jne	$LN58@SzReadHead

; 884  :     RINOK(SzReadID(sd, &type));

	mov	eax, ebx
	call	_SzReadID
	cmp	eax, edi
	jne	$LN58@SzReadHead
	mov	eax, DWORD PTR _type$[ebp]
$LN87@SzReadHead:

; 885  :   }
; 886  :  
; 887  :  
; 888  :   if (type == k7zIdMainStreamsInfo)

	cmp	eax, 4
	jne	SHORT $LN51@SzReadHead
	cmp	DWORD PTR _type$[ebp+4], edi
	jne	SHORT $LN51@SzReadHead

; 889  :   {
; 890  :     RINOK(SzReadStreamsInfo(sd,
; 891  :         &p->dataPos,
; 892  :         &p->db,
; 893  :         &numUnpackStreams,
; 894  :         unpackSizes,
; 895  :         digestsDefined,
; 896  :         digests, allocMain, allocTemp));

	mov	eax, DWORD PTR _allocTemp$[ebp]
	mov	ecx, DWORD PTR _allocMain$[ebp]
	mov	edx, DWORD PTR _digests$[ebp]
	mov	edi, DWORD PTR _p$[ebp]
	push	eax
	mov	eax, DWORD PTR _digestsDefined$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _unpackSizes$[ebp]
	push	edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR _numUnpackStreams$[ebp]
	push	edx
	lea	esi, DWORD PTR [edi+40]
	push	esi
	call	_SzReadStreamsInfo
	add	esp, 28					; 0000001cH
	test	eax, eax
	jne	$LN58@SzReadHead

; 897  :     p->dataPos += p->startPosAfterHeader;

	mov	eax, DWORD PTR [edi+32]
	add	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [edi+36]

; 898  :     RINOK(SzReadID(sd, &type));

	mov	eax, ebx
	adc	DWORD PTR [esi+4], ecx
	lea	esi, DWORD PTR _type$[ebp]
	call	_SzReadID
	test	eax, eax
	jne	$LN58@SzReadHead
	mov	eax, DWORD PTR _type$[ebp]
	xor	edi, edi
$LN51@SzReadHead:

; 899  :   }
; 900  : 
; 901  :   if (type == k7zIdEnd)

	mov	ecx, DWORD PTR _type$[ebp+4]
	mov	edx, eax
	or	edx, ecx
	jne	SHORT $LN50@SzReadHead

; 902  :     return SZ_OK;

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 1008 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@SzReadHead:

; 903  :   if (type != k7zIdFilesInfo)

	cmp	eax, 5
	jne	SHORT $LN84@SzReadHead
	cmp	ecx, edi
	je	SHORT $LN49@SzReadHead
$LN84@SzReadHead:
	pop	edi
	pop	esi

; 904  :     return SZ_ERROR_ARCHIVE;

	mov	eax, 16					; 00000010H
	pop	ebx

; 1008 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN49@SzReadHead:

; 905  :   
; 906  :   RINOK(SzReadNumber32(sd, &numFiles));

	lea	eax, DWORD PTR _numFiles$[ebp]
	push	eax
	mov	eax, ebx
	call	_SzReadNumber32
	add	esp, 4
	cmp	eax, edi
	jne	$LN58@SzReadHead

; 907  :   p->db.NumFiles = numFiles;

	mov	edi, DWORD PTR _numFiles$[ebp]
	mov	esi, DWORD PTR _p$[ebp]
	mov	DWORD PTR [esi+28], edi

; 908  : 
; 909  :   MY_ALLOC(CSzFileItem, files, (size_t)numFiles, allocMain);

	test	edi, edi
	jne	SHORT $LN47@SzReadHead
	xor	eax, eax
	mov	DWORD PTR _files$[ebp], eax
	jmp	SHORT $LN45@SzReadHead
$LN47@SzReadHead:
	mov	eax, DWORD PTR _allocMain$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, edi
	shl	ecx, 5
	push	ecx
	push	eax
	call	edx
	add	esp, 8
	mov	DWORD PTR _files$[ebp], eax
	test	eax, eax
	jne	SHORT $LN89@SzReadHead
	pop	edi
	pop	esi
	mov	eax, 2
	pop	ebx

; 1008 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN89@SzReadHead:

; 908  : 
; 909  :   MY_ALLOC(CSzFileItem, files, (size_t)numFiles, allocMain);

	mov	eax, DWORD PTR _files$[ebp]
$LN45@SzReadHead:

; 910  : 
; 911  :   p->db.Files = files;

	mov	DWORD PTR [esi+16], eax

; 912  :   for (i = 0; i < numFiles; i++)

	test	edi, edi
	je	SHORT $LN62@SzReadHead

; 910  : 
; 911  :   p->db.Files = files;

	mov	esi, eax
$LL44@SzReadHead:

; 913  :     SzFile_Init(files + i);

	push	esi
	call	_SzFile_Init
	add	esp, 4
	add	esi, 32					; 00000020H
	dec	edi
	jne	SHORT $LL44@SzReadHead
$LN62@SzReadHead:

; 914  : 
; 915  :   for (;;)
; 916  :   {
; 917  :     UInt64 type;
; 918  :     UInt64 size;
; 919  :     RINOK(SzReadID(sd, &type));

	lea	esi, DWORD PTR _type$80932[ebp]
	mov	eax, ebx
	call	_SzReadID
	test	eax, eax
	jne	$LN58@SzReadHead
$LL41@SzReadHead:

; 920  :     if (type == k7zIdEnd)

	mov	edi, DWORD PTR _type$80932[ebp]
	mov	eax, edi
	or	eax, DWORD PTR _type$80932[ebp+4]
	je	$LN69@SzReadHead

; 921  :       break;
; 922  :     RINOK(SzReadNumber(sd, &size));

	push	ebx
	lea	esi, DWORD PTR _size$80933[ebp]
	call	_SzReadNumber
	add	esp, 4
	test	eax, eax
	jne	$LN58@SzReadHead

; 923  : 
; 924  :     if ((UInt64)(int)type != type)

	mov	eax, edi
	cdq
	cmp	eax, edi
	jne	SHORT $LN85@SzReadHead
	cmp	edx, DWORD PTR _type$80932[ebp+4]
	je	SHORT $LN36@SzReadHead
$LN85@SzReadHead:

; 925  :     {
; 926  :       RINOK(SzSkeepDataSize(sd, size));

	mov	ecx, DWORD PTR _size$80933[ebp+4]
	mov	edx, DWORD PTR _size$80933[ebp]
	push	ecx
	push	edx
	mov	ecx, ebx
	call	_SzSkeepDataSize
	add	esp, 8
	test	eax, eax
	jne	$LN58@SzReadHead

; 927  :     }
; 928  :     else

	jmp	$LN10@SzReadHead
$LN36@SzReadHead:

; 929  :     switch((int)type)

	add	edi, -14				; fffffff2H
	cmp	edi, 6
	ja	SHORT $LN85@SzReadHead
	jmp	DWORD PTR $LN94@SzReadHead[edi*4]
$LN31@SzReadHead:

; 930  :     {
; 931  :       case k7zIdName:
; 932  :       {
; 933  :         RINOK(SzReadSwitch(sd));

	push	ebx
	call	_SzReadSwitch
	add	esp, 4
	test	eax, eax
	jne	$LN58@SzReadHead

; 934  :         RINOK(SzReadFileNames(sd, numFiles, files, allocMain))

	mov	eax, DWORD PTR _allocMain$[ebp]
	mov	ecx, DWORD PTR _numFiles$[ebp]
	push	eax
	mov	eax, DWORD PTR _files$[ebp]
	push	ecx
	push	ebx
	call	_SzReadFileNames
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN58@SzReadHead

; 935  :         break;

	jmp	$LN10@SzReadHead
$LN28@SzReadHead:

; 936  :       }
; 937  :       case k7zIdEmptyStream:
; 938  :       {
; 939  :         RINOK(SzReadBoolVector(sd, numFiles, emptyStreamVector, allocTemp));

	mov	esi, DWORD PTR _emptyStreamVector$[ebp]
	mov	eax, DWORD PTR _allocTemp$[ebp]
	mov	edi, DWORD PTR _numFiles$[ebp]
	push	esi
	push	ebx
	call	_SzReadBoolVector
	add	esp, 8
	test	eax, eax
	jne	$LN58@SzReadHead

; 940  :         numEmptyStreams = 0;
; 941  :         for (i = 0; i < numFiles; i++)

	mov	ecx, edi
	mov	DWORD PTR _numEmptyStreams$[ebp], eax
	test	ecx, ecx
	je	$LN10@SzReadHead
	mov	esi, DWORD PTR [esi]
	npad	4
$LL26@SzReadHead:

; 942  :           if ((*emptyStreamVector)[i])

	cmp	BYTE PTR [esi+eax], 0
	je	SHORT $LN25@SzReadHead

; 943  :             numEmptyStreams++;

	inc	DWORD PTR _numEmptyStreams$[ebp]
$LN25@SzReadHead:

; 940  :         numEmptyStreams = 0;
; 941  :         for (i = 0; i < numFiles; i++)

	inc	eax
	cmp	eax, ecx
	jb	SHORT $LL26@SzReadHead

; 944  :         break;

	jmp	$LN10@SzReadHead
$LN22@SzReadHead:

; 945  :       }
; 946  :       case k7zIdEmptyFile:
; 947  :       {
; 948  :         RINOK(SzReadBoolVector(sd, numEmptyStreams, emptyFileVector, allocTemp));

	mov	edx, DWORD PTR _emptyFileVector$[ebp]
	mov	eax, DWORD PTR _allocTemp$[ebp]
	mov	edi, DWORD PTR _numEmptyStreams$[ebp]
	push	edx
	push	ebx
	call	_SzReadBoolVector
	add	esp, 8
	test	eax, eax
	jne	$LN58@SzReadHead

; 949  :         break;

	jmp	$LN10@SzReadHead
$LN20@SzReadHead:

; 950  :       }
; 951  :       case k7zIdMTime:
; 952  :       {
; 953  :         RINOK(SzReadBoolVector2(sd, numFiles, lwtVector, allocTemp));

	mov	edi, DWORD PTR _numFiles$[ebp]
	mov	esi, DWORD PTR _lwtVector$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _allocTemp$[ebp]
	mov	eax, edi
	call	_SzReadBoolVector2
	add	esp, 4
	test	eax, eax
	jne	$LN58@SzReadHead

; 954  :         RINOK(SzReadSwitch(sd));

	mov	eax, DWORD PTR _sd$[ebp]
	push	eax
	call	_SzReadSwitch
	add	esp, 4
	test	eax, eax
	jne	$LN58@SzReadHead

; 955  :         for (i = 0; i < numFiles; i++)

	xor	ecx, ecx
	mov	DWORD PTR _i$[ebp], ecx
	test	edi, edi
	je	SHORT $LN92@SzReadHead
	mov	esi, DWORD PTR _files$[ebp]
	add	esi, 4
$LL93@SzReadHead:

; 956  :         {
; 957  :           CSzFileItem *f = &files[i];
; 958  :           Byte defined = (*lwtVector)[i];

	mov	edx, DWORD PTR _lwtVector$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	al, BYTE PTR [ecx+eax]

; 959  :           f->MTimeDefined = defined;
; 960  :           f->MTime.Low = f->MTime.High = 0;

	lea	edi, DWORD PTR [esi-4]
	mov	BYTE PTR [esi+24], al
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [edi], 0

; 961  :           if (defined)

	test	al, al
	je	SHORT $LN16@SzReadHead

; 962  :           {
; 963  :             RINOK(SzReadUInt32(sd, &f->MTime.Low));

	mov	ebx, DWORD PTR _sd$[ebp]
	call	_SzReadUInt32
	test	eax, eax
	jne	$LN58@SzReadHead

; 964  :             RINOK(SzReadUInt32(sd, &f->MTime.High));

	mov	edi, esi
	call	_SzReadUInt32
	test	eax, eax
	jne	$LN58@SzReadHead
	mov	ecx, DWORD PTR _i$[ebp]
$LN16@SzReadHead:

; 955  :         for (i = 0; i < numFiles; i++)

	inc	ecx
	add	esi, 32					; 00000020H
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, DWORD PTR _numFiles$[ebp]
	jb	SHORT $LL93@SzReadHead
$LN92@SzReadHead:

; 965  :           }
; 966  :         }
; 967  :         break;

	mov	ebx, DWORD PTR _sd$[ebp]
$LN10@SzReadHead:

; 914  : 
; 915  :   for (;;)
; 916  :   {
; 917  :     UInt64 type;
; 918  :     UInt64 size;
; 919  :     RINOK(SzReadID(sd, &type));

	lea	esi, DWORD PTR _type$80932[ebp]
	mov	eax, ebx
	call	_SzReadID
	test	eax, eax
	je	$LL41@SzReadHead
	pop	edi
	pop	esi
	pop	ebx

; 1008 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN69@SzReadHead:

; 968  :       }
; 969  :       default:
; 970  :       {
; 971  :         RINOK(SzSkeepDataSize(sd, size));
; 972  :       }
; 973  :     }
; 974  :   }
; 975  : 
; 976  :   {
; 977  :     UInt32 emptyFileIndex = 0;

	xor	ebx, ebx
	xor	edi, edi

; 978  :     UInt32 sizeIndex = 0;

	xor	ecx, ecx

; 979  :     for (i = 0; i < numFiles; i++)

	xor	esi, esi
	cmp	DWORD PTR _numFiles$[ebp], ebx
	jbe	$LN7@SzReadHead

; 968  :       }
; 969  :       default:
; 970  :       {
; 971  :         RINOK(SzSkeepDataSize(sd, size));
; 972  :       }
; 973  :     }
; 974  :   }
; 975  : 
; 976  :   {
; 977  :     UInt32 emptyFileIndex = 0;

	mov	eax, DWORD PTR _files$[ebp]
	add	eax, 24					; 00000018H
$LL9@SzReadHead:

; 980  :     {
; 981  :       CSzFileItem *file = files + i;
; 982  :       file->IsAnti = 0;
; 983  :       if (*emptyStreamVector == 0)

	mov	edx, DWORD PTR _emptyStreamVector$[ebp]
	mov	BYTE PTR [eax+2], 0
	mov	edx, DWORD PTR [edx]
	cmp	edx, ebx
	jne	SHORT $LN6@SzReadHead

; 984  :         file->HasStream = 1;

	mov	BYTE PTR [eax], 1

; 985  :       else

	jmp	SHORT $LN83@SzReadHead
$LN6@SzReadHead:

; 986  :         file->HasStream = (Byte)((*emptyStreamVector)[i] ? 0 : 1);

	cmp	BYTE PTR [edx+esi], 0
	sete	dl
	mov	BYTE PTR [eax], dl

; 987  :       if (file->HasStream)

	test	dl, dl
	je	SHORT $LN4@SzReadHead
$LN83@SzReadHead:

; 988  :       {
; 989  :         file->IsDir = 0;
; 990  :         file->Size = (*unpackSizes)[sizeIndex];

	mov	edx, DWORD PTR _unpackSizes$[ebp]
	mov	BYTE PTR [eax+1], 0
	mov	edx, DWORD PTR [edx]
	mov	ebx, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR [eax-16], ebx
	mov	edx, DWORD PTR [edx+ecx*8+4]
	mov	DWORD PTR [eax-12], edx

; 991  :         file->FileCRC = (*digests)[sizeIndex];

	mov	edx, DWORD PTR _digests$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax-4], edx

; 992  :         file->FileCRCDefined = (Byte)(*digestsDefined)[sizeIndex];

	mov	edx, DWORD PTR _digestsDefined$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	dl, BYTE PTR [ecx+edx]

; 993  :         sizeIndex++;

	inc	ecx
	mov	BYTE PTR [eax+3], dl

; 994  :       }
; 995  :       else

	xor	ebx, ebx
	jmp	SHORT $LN8@SzReadHead
$LN4@SzReadHead:

; 996  :       {
; 997  :         if (*emptyFileVector == 0)

	mov	edx, DWORD PTR _emptyFileVector$[ebp]
	mov	edx, DWORD PTR [edx]
	cmp	edx, ebx
	jne	SHORT $LN2@SzReadHead

; 998  :           file->IsDir = 1;

	mov	BYTE PTR [eax+1], 1

; 999  :         else

	jmp	SHORT $LN1@SzReadHead
$LN2@SzReadHead:

; 1000 :           file->IsDir = (Byte)((*emptyFileVector)[emptyFileIndex] ? 0 : 1);

	cmp	BYTE PTR [edx+edi], 0
	sete	dl
	mov	BYTE PTR [eax+1], dl
$LN1@SzReadHead:

; 1001 :         emptyFileIndex++;

	inc	edi

; 1002 :         file->Size = 0;

	mov	DWORD PTR [eax-16], ebx
	mov	DWORD PTR [eax-12], ebx

; 1003 :         file->FileCRCDefined = 0;

	mov	BYTE PTR [eax+3], 0
$LN8@SzReadHead:

; 979  :     for (i = 0; i < numFiles; i++)

	inc	esi
	add	eax, 32					; 00000020H
	cmp	esi, DWORD PTR _numFiles$[ebp]
	jb	SHORT $LL9@SzReadHead
$LN7@SzReadHead:

; 1004 :       }
; 1005 :     }
; 1006 :   }
; 1007 :   return SzArEx_Fill(p, allocMain);

	mov	eax, DWORD PTR _allocMain$[ebp]
	mov	esi, DWORD PTR _p$[ebp]
	push	eax
	call	_SzArEx_Fill
	add	esp, 4
$LN58@SzReadHead:
	pop	edi
	pop	esi
	pop	ebx

; 1008 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN94@SzReadHead:
	DD	$LN28@SzReadHead
	DD	$LN22@SzReadHead
	DD	$LN85@SzReadHead
	DD	$LN31@SzReadHead
	DD	$LN85@SzReadHead
	DD	$LN85@SzReadHead
	DD	$LN20@SzReadHead
_SzReadHeader2 ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _SzReadHeader
_TEXT	SEGMENT
_lwtVector$ = -24					; size = 4
_emptyFileVector$ = -20					; size = 4
_emptyStreamVector$ = -16				; size = 4
_digests$ = -12						; size = 4
_digestsDefined$ = -8					; size = 4
_unpackSizes$ = -4					; size = 4
_p$ = 8							; size = 4
_sd$ = 12						; size = 4
_allocMain$ = 16					; size = 4
_SzReadHeader PROC					; COMDAT
; _allocTemp$ = esi

; 1015 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1016 :   UInt64 *unpackSizes = 0;

	xor	eax, eax
	push	edi

; 1017 :   Byte *digestsDefined = 0;
; 1018 :   UInt32 *digests = 0;
; 1019 :   Byte *emptyStreamVector = 0;
; 1020 :   Byte *emptyFileVector = 0;
; 1021 :   Byte *lwtVector = 0;
; 1022 :   SRes res = SzReadHeader2(p, sd,
; 1023 :       &unpackSizes, &digestsDefined, &digests,
; 1024 :       &emptyStreamVector, &emptyFileVector, &lwtVector,
; 1025 :       allocMain, allocTemp);

	push	esi
	mov	DWORD PTR _unpackSizes$[ebp], eax
	mov	DWORD PTR _digestsDefined$[ebp], eax
	mov	DWORD PTR _digests$[ebp], eax
	mov	DWORD PTR _emptyStreamVector$[ebp], eax
	mov	DWORD PTR _emptyFileVector$[ebp], eax
	mov	DWORD PTR _lwtVector$[ebp], eax
	mov	eax, DWORD PTR _allocMain$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lwtVector$[ebp]
	push	ecx
	lea	edx, DWORD PTR _emptyFileVector$[ebp]
	push	edx
	lea	eax, DWORD PTR _emptyStreamVector$[ebp]
	push	eax
	lea	ecx, DWORD PTR _digests$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _sd$[ebp]
	lea	edx, DWORD PTR _digestsDefined$[ebp]
	push	edx
	mov	edx, DWORD PTR _p$[ebp]
	lea	eax, DWORD PTR _unpackSizes$[ebp]
	push	eax
	push	ecx
	push	edx
	call	_SzReadHeader2

; 1026 :   IAlloc_Free(allocTemp, unpackSizes);

	mov	ecx, DWORD PTR [esi+4]
	mov	edi, eax
	mov	eax, DWORD PTR _unpackSizes$[ebp]
	push	eax
	push	esi
	call	ecx

; 1027 :   IAlloc_Free(allocTemp, digestsDefined);

	mov	edx, DWORD PTR _digestsDefined$[ebp]
	mov	eax, DWORD PTR [esi+4]
	push	edx
	push	esi
	call	eax

; 1028 :   IAlloc_Free(allocTemp, digests);

	mov	ecx, DWORD PTR _digests$[ebp]
	mov	edx, DWORD PTR [esi+4]
	push	ecx
	push	esi
	call	edx

; 1029 :   IAlloc_Free(allocTemp, emptyStreamVector);

	mov	eax, DWORD PTR _emptyStreamVector$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	add	esp, 64					; 00000040H
	push	eax
	push	esi
	call	ecx

; 1030 :   IAlloc_Free(allocTemp, emptyFileVector);

	mov	edx, DWORD PTR _emptyFileVector$[ebp]
	mov	eax, DWORD PTR [esi+4]
	push	edx
	push	esi
	call	eax

; 1031 :   IAlloc_Free(allocTemp, lwtVector);

	mov	ecx, DWORD PTR _lwtVector$[ebp]
	mov	edx, DWORD PTR [esi+4]
	push	ecx
	push	esi
	call	edx
	add	esp, 24					; 00000018H

; 1032 :   return res;

	mov	eax, edi
	pop	edi

; 1033 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SzReadHeader ENDP
_TEXT	ENDS
EXTRN	@CrcCalc@8:PROC
EXTRN	_SzDecode:PROC
EXTRN	_LookInStream_SeekTo:PROC
; Function compile flags: /Ogtp
;	COMDAT _SzReadAndDecodePackedStreams2
_TEXT	SEGMENT
_dataStartPos$ = -16					; size = 8
_unpackSize$ = -8					; size = 8
_numUnpackStreams$ = -4					; size = 4
_inStream$ = 8						; size = 4
_sd$ = 12						; size = 4
_outBuffer$ = 16					; size = 4
_baseOffset$ = 20					; size = 8
_p$ = 28						; size = 4
_allocTemp$ = 32					; size = 4
_SzReadAndDecodePackedStreams2 PROC			; COMDAT
; _unpackSizes$ = edx
; _digestsDefined$ = ecx
; _digests$ = eax

; 1045 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx

; 1046 : 
; 1047 :   UInt32 numUnpackStreams = 0;
; 1048 :   UInt64 dataStartPos;
; 1049 :   CSzFolder *folder;
; 1050 :   UInt64 unpackSize;
; 1051 :   SRes res;
; 1052 : 
; 1053 :   RINOK(SzReadStreamsInfo(sd, &dataStartPos, p,
; 1054 :       &numUnpackStreams,  unpackSizes, digestsDefined, digests,
; 1055 :       allocTemp, allocTemp));

	mov	ebx, DWORD PTR _sd$[ebp]
	push	esi
	mov	esi, DWORD PTR _allocTemp$[ebp]
	push	edi
	mov	edi, DWORD PTR _p$[ebp]
	push	esi
	push	esi
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR _numUnpackStreams$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dataStartPos$[ebp]
	push	ecx
	mov	DWORD PTR _numUnpackStreams$[ebp], 0
	call	_SzReadStreamsInfo
	add	esp, 28					; 0000001cH
	test	eax, eax
	jne	$LN8@SzReadAndD

; 1056 :   
; 1057 :   dataStartPos += baseOffset;

	mov	edx, DWORD PTR _baseOffset$[ebp]
	add	DWORD PTR _dataStartPos$[ebp], edx
	mov	eax, DWORD PTR _baseOffset$[ebp+4]
	adc	DWORD PTR _dataStartPos$[ebp+4], eax

; 1058 :   if (p->NumFolders != 1)

	cmp	DWORD PTR [edi+24], 1
	je	SHORT $LN6@SzReadAndD

; 1059 :     return SZ_ERROR_ARCHIVE;

	pop	edi
	pop	esi
	mov	eax, 16					; 00000010H
	pop	ebx

; 1077 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@SzReadAndD:

; 1060 : 
; 1061 :   folder = p->Folders;

	mov	ebx, DWORD PTR [edi+12]

; 1062 :   unpackSize = SzFolder_GetUnpackSize(folder);

	push	ebx
	call	_SzFolder_GetUnpackSize

; 1063 :   
; 1064 :   RINOK(LookInStream_SeekTo(inStream, dataStartPos));

	mov	ecx, DWORD PTR _dataStartPos$[ebp+4]
	mov	DWORD PTR _unpackSize$[ebp+4], edx
	mov	edx, DWORD PTR _dataStartPos$[ebp]
	push	ecx
	mov	DWORD PTR _unpackSize$[ebp], eax
	mov	eax, DWORD PTR _inStream$[ebp]
	push	edx
	push	eax
	call	_LookInStream_SeekTo
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN8@SzReadAndD

; 1065 : 
; 1066 :   if (!Buf_Create(outBuffer, (size_t)unpackSize, allocTemp))

	mov	ecx, DWORD PTR _unpackSize$[ebp]
	mov	edx, DWORD PTR _outBuffer$[ebp]
	push	esi
	push	ecx
	push	edx
	call	_Buf_Create
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@SzReadAndD

; 1067 :     return SZ_ERROR_MEM;

	pop	edi
	pop	esi
	mov	eax, 2
	pop	ebx

; 1077 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@SzReadAndD:

; 1068 :   
; 1069 :   res = SzDecode(p->PackSizes, folder,
; 1070 :           inStream, dataStartPos,
; 1071 :           outBuffer->data, (size_t)unpackSize, allocTemp);

	mov	eax, DWORD PTR _outBuffer$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _dataStartPos$[ebp+4]
	mov	eax, DWORD PTR _dataStartPos$[ebp]
	push	esi
	mov	esi, DWORD PTR _unpackSize$[ebp]
	push	esi
	push	ecx
	mov	ecx, DWORD PTR _inStream$[ebp]
	push	edx
	mov	edx, DWORD PTR [edi]
	push	eax
	push	ecx
	push	ebx
	push	edx
	call	_SzDecode
	add	esp, 32					; 00000020H

; 1072 :   RINOK(res);

	test	eax, eax
	jne	SHORT $LN8@SzReadAndD

; 1073 :   if (folder->UnpackCRCDefined)

	cmp	DWORD PTR [ebx+28], eax
	je	SHORT $LN1@SzReadAndD

; 1074 :     if (CrcCalc(outBuffer->data, (size_t)unpackSize) != folder->UnpackCRC)

	mov	eax, DWORD PTR _outBuffer$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, esi
	call	@CrcCalc@8
	cmp	eax, DWORD PTR [ebx+32]
	je	SHORT $LN1@SzReadAndD

; 1075 :       return SZ_ERROR_CRC;

	pop	edi
	pop	esi
	mov	eax, 3
	pop	ebx

; 1077 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@SzReadAndD:

; 1076 :   return SZ_OK;

	xor	eax, eax
$LN8@SzReadAndD:
	pop	edi
	pop	esi
	pop	ebx

; 1077 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SzReadAndDecodePackedStreams2 ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _SzReadAndDecodePackedStreams
_TEXT	SEGMENT
_p$ = -44						; size = 32
_digests$ = -12						; size = 4
_digestsDefined$ = -8					; size = 4
_unpackSizes$ = -4					; size = 4
_inStream$ = 8						; size = 4
_sd$ = 12						; size = 4
_outBuffer$ = 16					; size = 4
_baseOffset$ = 20					; size = 8
_SzReadAndDecodePackedStreams PROC			; COMDAT
; _allocTemp$ = esi

; 1085 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 1086 :   CSzAr p;
; 1087 :   UInt64 *unpackSizes = 0;

	xor	eax, eax
	mov	DWORD PTR _unpackSizes$[ebp], eax

; 1088 :   Byte *digestsDefined = 0;

	mov	DWORD PTR _digestsDefined$[ebp], eax

; 1089 :   UInt32 *digests = 0;

	mov	DWORD PTR _digests$[ebp], eax

; 1090 :   SRes res;
; 1091 :   SzAr_Init(&p);

	lea	eax, DWORD PTR _p$[ebp]
	push	edi
	push	eax
	call	_SzAr_Init

; 1092 :   res = SzReadAndDecodePackedStreams2(inStream, sd, outBuffer, baseOffset,
; 1093 :     &p, &unpackSizes, &digestsDefined, &digests,
; 1094 :     allocTemp);

	mov	edx, DWORD PTR _baseOffset$[ebp+4]
	mov	eax, DWORD PTR _baseOffset$[ebp]
	push	esi
	lea	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _outBuffer$[ebp]
	push	edx
	mov	edx, DWORD PTR _sd$[ebp]
	push	eax
	mov	eax, DWORD PTR _inStream$[ebp]
	push	ecx
	push	edx
	push	eax
	lea	eax, DWORD PTR _digests$[ebp]
	lea	ecx, DWORD PTR _digestsDefined$[ebp]
	lea	edx, DWORD PTR _unpackSizes$[ebp]
	call	_SzReadAndDecodePackedStreams2

; 1095 :   SzAr_Free(&p, allocTemp);

	lea	ecx, DWORD PTR _p$[ebp]
	push	esi
	push	ecx
	mov	edi, eax
	call	_SzAr_Free

; 1096 :   IAlloc_Free(allocTemp, unpackSizes);

	mov	edx, DWORD PTR _unpackSizes$[ebp]
	mov	eax, DWORD PTR [esi+4]
	push	edx
	push	esi
	call	eax

; 1097 :   IAlloc_Free(allocTemp, digestsDefined);

	mov	ecx, DWORD PTR _digestsDefined$[ebp]
	mov	edx, DWORD PTR [esi+4]
	push	ecx
	push	esi
	call	edx

; 1098 :   IAlloc_Free(allocTemp, digests);

	mov	eax, DWORD PTR _digests$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	push	eax
	push	esi
	call	ecx
	add	esp, 64					; 00000040H

; 1099 :   return res;

	mov	eax, edi
	pop	edi

; 1100 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SzReadAndDecodePackedStreams ENDP
_TEXT	ENDS
PUBLIC	_allocTemp$GSCopy$
PUBLIC	_inStream$GSCopy$
PUBLIC	_p$GSCopy$
PUBLIC	_allocMain$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	_Buf_Free:PROC
EXTRN	_Buf_Init:PROC
EXTRN	_LookInStream_Read:PROC
EXTRN	_LookInStream_Read2:PROC
; Function compile flags: /Ogtp
;	COMDAT _SzArEx_Open2
_TEXT	SEGMENT
_inStream$GSCopy$ = -96					; size = 4
tv236 = -92						; size = 8
_nextHeaderSize$ = -84					; size = 8
_allocMain$GSCopy$ = -76				; size = 4
_type$81115 = -72					; size = 8
_allocTemp$GSCopy$ = -68				; size = 4
_p$GSCopy$ = -64					; size = 4
_buffer$ = -60						; size = 8
_outBuffer$81118 = -52					; size = 8
_pos$81101 = -52					; size = 8
_sd$81114 = -44						; size = 8
_nextHeaderCRC$ = -40					; size = 4
_header$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
_inStream$ = 12						; size = 4
_SzArEx_Open2 PROC					; COMDAT
; _allocMain$ = ecx
; _allocTemp$ = edx

; 1107 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _p$[ebp]

; 1108 :   Byte header[k7zStartHeaderSize];
; 1109 :   UInt64 nextHeaderOffset, nextHeaderSize;
; 1110 :   size_t nextHeaderSizeT;
; 1111 :   UInt32 nextHeaderCRC;
; 1112 :   CBuf buffer;
; 1113 :   SRes res;
; 1114 : 
; 1115 :   RINOK(LookInStream_Read2(inStream, header, k7zStartHeaderSize, SZ_ERROR_NO_ARCHIVE));

	push	17					; 00000011H

; 1136 :   if (nextHeaderOffset > nextHeaderOffset + nextHeaderSize ||
; 1137 :       nextHeaderOffset > nextHeaderOffset + nextHeaderSize + k7zStartHeaderSize)

	mov	DWORD PTR _allocMain$GSCopy$[ebp], ecx
	push	32					; 00000020H
	lea	ecx, DWORD PTR _header$[ebp]
	mov	DWORD PTR _p$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _inStream$[ebp]
	push	ecx
	push	eax
	mov	DWORD PTR _inStream$GSCopy$[ebp], eax
	mov	DWORD PTR _allocTemp$GSCopy$[ebp], edx
	call	_LookInStream_Read2
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$LN23@SzArEx_Ope

; 1116 : 
; 1117 :   if (!TestSignatureCandidate(header))

	lea	ecx, DWORD PTR _header$[ebp]
	call	_TestSignatureCandidate
	test	eax, eax
	jne	SHORT $LN21@SzArEx_Ope

; 1118 :     return SZ_ERROR_NO_ARCHIVE;

	mov	eax, 17					; 00000011H

; 1196 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@SzArEx_Ope:

; 1119 :   if (header[6] != k7zMajorVersion)

	cmp	BYTE PTR _header$[ebp+6], 0
	je	SHORT $LN20@SzArEx_Ope

; 1120 :     return SZ_ERROR_UNSUPPORTED;

	mov	eax, 4

; 1196 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@SzArEx_Ope:

; 1121 : 
; 1122 :   nextHeaderOffset = GetUi64(header + 12);
; 1123 :   nextHeaderSize = GetUi64(header + 20);
; 1124 :   nextHeaderCRC = GetUi32(header + 28);

	mov	eax, DWORD PTR _header$[ebp+28]
	mov	edx, DWORD PTR _header$[ebp+20]
	push	ebx
	mov	ebx, DWORD PTR _header$[ebp+24]
	push	esi
	mov	esi, DWORD PTR _header$[ebp+16]
	mov	DWORD PTR _nextHeaderCRC$[ebp], eax

; 1125 : 
; 1126 :   p->startPosAfterHeader = k7zStartHeaderSize;

	mov	eax, DWORD PTR _p$GSCopy$[ebp]
	mov	DWORD PTR _nextHeaderSize$[ebp], edx
	push	edi
	mov	edi, DWORD PTR _header$[ebp+12]

; 1127 :   
; 1128 :   if (CrcCalc(header + 12, 20) != GetUi32(header + 8))

	mov	edx, 20					; 00000014H
	lea	ecx, DWORD PTR _header$[ebp+12]
	mov	DWORD PTR [eax+32], 32			; 00000020H
	mov	DWORD PTR [eax+36], 0
	call	@CrcCalc@8
	cmp	eax, DWORD PTR _header$[ebp+8]
	je	SHORT $LN19@SzArEx_Ope

; 1129 :     return SZ_ERROR_CRC;

	pop	edi
	pop	esi
	mov	eax, 3
	pop	ebx

; 1196 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@SzArEx_Ope:

; 1130 : 
; 1131 :   nextHeaderSizeT = (size_t)nextHeaderSize;
; 1132 :   if (nextHeaderSizeT != nextHeaderSize)

	mov	eax, DWORD PTR _nextHeaderSize$[ebp]
	xor	edx, edx
	xor	ecx, ecx
	cmp	eax, eax
	jne	$LN26@SzArEx_Ope
	cmp	ecx, ebx

; 1133 :     return SZ_ERROR_MEM;

	jne	$LN26@SzArEx_Ope

; 1134 :   if (nextHeaderSizeT == 0)

	cmp	eax, edx
	jne	SHORT $LN17@SzArEx_Ope

; 1135 :     return SZ_OK;

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 1196 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@SzArEx_Ope:

; 1136 :   if (nextHeaderOffset > nextHeaderOffset + nextHeaderSize ||
; 1137 :       nextHeaderOffset > nextHeaderOffset + nextHeaderSize + k7zStartHeaderSize)

	add	eax, edi
	adc	ebx, esi
	mov	ecx, ebx
	cmp	esi, ecx
	ja	$LN15@SzArEx_Ope
	jb	SHORT $LN27@SzArEx_Ope
	cmp	edi, eax
	ja	$LN15@SzArEx_Ope
$LN27@SzArEx_Ope:
	add	eax, 32					; 00000020H
	adc	ecx, edx
	mov	DWORD PTR tv236[ebp], eax
	mov	DWORD PTR tv236[ebp+4], ecx
	cmp	esi, ecx
	ja	$LN15@SzArEx_Ope
	jb	SHORT $LN28@SzArEx_Ope
	cmp	edi, eax
	ja	$LN15@SzArEx_Ope
$LN28@SzArEx_Ope:

; 1139 : 
; 1140 :   {
; 1141 :     Int64 pos = 0;
; 1142 :     RINOK(inStream->Seek(inStream, &pos, SZ_SEEK_END));

	mov	ebx, DWORD PTR _inStream$GSCopy$[ebp]
	push	2
	lea	ecx, DWORD PTR _pos$81101[ebp]
	push	ecx
	mov	DWORD PTR _pos$81101[ebp], edx
	mov	DWORD PTR _pos$81101[ebp+4], edx
	mov	edx, DWORD PTR [ebx+12]
	push	ebx
	call	edx
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN35@SzArEx_Ope

; 1143 :     if ((UInt64)pos < nextHeaderOffset ||
; 1144 :         (UInt64)pos < k7zStartHeaderSize + nextHeaderOffset ||
; 1145 :         (UInt64)pos < k7zStartHeaderSize + nextHeaderOffset + nextHeaderSize)

	mov	eax, DWORD PTR _pos$81101[ebp+4]
	cmp	eax, esi
	jb	$LN12@SzArEx_Ope
	mov	ecx, DWORD PTR _pos$81101[ebp]
	ja	SHORT $LN29@SzArEx_Ope
	cmp	ecx, edi
	jb	$LN12@SzArEx_Ope
$LN29@SzArEx_Ope:
	add	edi, 32					; 00000020H
	adc	esi, 0
	cmp	eax, esi
	jb	$LN12@SzArEx_Ope
	ja	SHORT $LN30@SzArEx_Ope
	cmp	ecx, edi
	jb	$LN12@SzArEx_Ope
$LN30@SzArEx_Ope:
	cmp	eax, DWORD PTR tv236[ebp+4]
	jb	$LN12@SzArEx_Ope
	ja	SHORT $LN31@SzArEx_Ope
	cmp	ecx, DWORD PTR tv236[ebp]
	jb	$LN12@SzArEx_Ope
$LN31@SzArEx_Ope:

; 1147 :   }
; 1148 : 
; 1149 :   RINOK(LookInStream_SeekTo(inStream, k7zStartHeaderSize + nextHeaderOffset));

	push	esi
	push	edi
	push	ebx
	call	_LookInStream_SeekTo
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN35@SzArEx_Ope

; 1150 : 
; 1151 :   if (!Buf_Create(&buffer, nextHeaderSizeT, allocTemp))

	mov	edi, DWORD PTR _allocTemp$GSCopy$[ebp]
	mov	esi, DWORD PTR _nextHeaderSize$[ebp]
	push	edi
	lea	eax, DWORD PTR _buffer$[ebp]
	push	esi
	push	eax
	call	_Buf_Create
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@SzArEx_Ope
$LN26@SzArEx_Ope:
	pop	edi
	pop	esi

; 1152 :     return SZ_ERROR_MEM;

	mov	eax, 2
	pop	ebx

; 1196 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@SzArEx_Ope:

; 1153 : 
; 1154 :   res = LookInStream_Read(inStream, buffer.data, nextHeaderSizeT);

	mov	ecx, DWORD PTR _buffer$[ebp]
	push	esi
	push	ecx
	push	ebx
	call	_LookInStream_Read
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 1155 :   if (res == SZ_OK)

	test	esi, esi
	jne	$LN1@SzArEx_Ope

; 1156 :   {
; 1157 :     res = SZ_ERROR_ARCHIVE;
; 1158 :     if (CrcCalc(buffer.data, nextHeaderSizeT) == nextHeaderCRC)

	mov	edx, DWORD PTR _nextHeaderSize$[ebp]
	mov	ecx, DWORD PTR _buffer$[ebp]
	lea	esi, DWORD PTR [eax+16]
	call	@CrcCalc@8
	cmp	eax, DWORD PTR _nextHeaderCRC$[ebp]
	jne	$LN1@SzArEx_Ope

; 1159 :     {
; 1160 :       CSzData sd;
; 1161 :       UInt64 type;
; 1162 :       sd.Data = buffer.data;
; 1163 :       sd.Size = buffer.size;

	mov	eax, DWORD PTR _buffer$[ebp+4]
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _sd$81114[ebp+4], eax

; 1164 :       res = SzReadID(&sd, &type);

	lea	esi, DWORD PTR _type$81115[ebp]
	lea	eax, DWORD PTR _sd$81114[ebp]
	mov	DWORD PTR _sd$81114[ebp], edx
	call	_SzReadID
	mov	esi, eax

; 1165 :       if (res == SZ_OK)

	test	esi, esi
	jne	$LN1@SzArEx_Ope

; 1166 :       {
; 1167 :         if (type == k7zIdEncodedHeader)

	cmp	DWORD PTR _type$81115[ebp], 23		; 00000017H
	jne	SHORT $LN32@SzArEx_Ope
	cmp	DWORD PTR _type$81115[ebp+4], eax
	jne	SHORT $LN32@SzArEx_Ope

; 1168 :         {
; 1169 :           CBuf outBuffer;
; 1170 :           Buf_Init(&outBuffer);

	lea	ecx, DWORD PTR _outBuffer$81118[ebp]
	push	ecx
	call	_Buf_Init

; 1171 :           res = SzReadAndDecodePackedStreams(inStream, &sd, &outBuffer, p->startPosAfterHeader, allocTemp);

	mov	eax, DWORD PTR _p$GSCopy$[ebp]
	mov	edx, DWORD PTR [eax+36]
	mov	eax, DWORD PTR [eax+32]
	push	edx
	push	eax
	lea	ecx, DWORD PTR _outBuffer$81118[ebp]
	push	ecx
	lea	edx, DWORD PTR _sd$81114[ebp]
	push	edx
	push	ebx
	mov	esi, edi
	call	_SzReadAndDecodePackedStreams
	add	esp, 24					; 00000018H
	mov	esi, eax

; 1172 :           if (res != SZ_OK)
; 1173 :             Buf_Free(&outBuffer, allocTemp);

	push	edi
	test	esi, esi
	je	SHORT $LN5@SzArEx_Ope
	lea	eax, DWORD PTR _outBuffer$81118[ebp]
	push	eax
	call	_Buf_Free
	add	esp, 8

; 1174 :           else

	jmp	SHORT $LN4@SzArEx_Ope
$LN5@SzArEx_Ope:

; 1175 :           {
; 1176 :             Buf_Free(&buffer, allocTemp);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_Buf_Free

; 1177 :             buffer.data = outBuffer.data;

	mov	eax, DWORD PTR _outBuffer$81118[ebp]

; 1178 :             buffer.size = outBuffer.size;

	mov	ecx, DWORD PTR _outBuffer$81118[ebp+4]
	mov	DWORD PTR _buffer$[ebp], eax

; 1179 :             sd.Data = buffer.data;

	mov	DWORD PTR _sd$81114[ebp], eax
	add	esp, 8

; 1180 :             sd.Size = buffer.size;
; 1181 :             res = SzReadID(&sd, &type);

	lea	esi, DWORD PTR _type$81115[ebp]
	lea	eax, DWORD PTR _sd$81114[ebp]
	mov	DWORD PTR _buffer$[ebp+4], ecx
	mov	DWORD PTR _sd$81114[ebp+4], ecx
	call	_SzReadID
	mov	esi, eax
$LN4@SzArEx_Ope:

; 1182 :           }
; 1183 :         }
; 1184 :       }
; 1185 :       if (res == SZ_OK)

	test	esi, esi
	jne	SHORT $LN1@SzArEx_Ope
$LN32@SzArEx_Ope:

; 1186 :       {
; 1187 :         if (type == k7zIdHeader)

	cmp	DWORD PTR _type$81115[ebp], 1
	jne	SHORT $LN2@SzArEx_Ope
	cmp	DWORD PTR _type$81115[ebp+4], 0
	jne	SHORT $LN2@SzArEx_Ope

; 1188 :           res = SzReadHeader(p, &sd, allocMain, allocTemp);

	mov	edx, DWORD PTR _allocMain$GSCopy$[ebp]
	mov	ecx, DWORD PTR _p$GSCopy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sd$81114[ebp]
	push	eax
	push	ecx
	mov	esi, edi
	call	_SzReadHeader
	add	esp, 12					; 0000000cH

; 1191 :       }
; 1192 :     }
; 1193 :   }
; 1194 :   Buf_Free(&buffer, allocTemp);

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edi
	push	edx
	mov	esi, eax
	call	_Buf_Free
	add	esp, 8
	pop	edi

; 1195 :   return res;

	mov	eax, esi
	pop	esi
	pop	ebx

; 1196 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@SzArEx_Ope:

; 1189 :         else
; 1190 :           res = SZ_ERROR_UNSUPPORTED;

	mov	esi, 4
$LN1@SzArEx_Ope:

; 1191 :       }
; 1192 :     }
; 1193 :   }
; 1194 :   Buf_Free(&buffer, allocTemp);

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edi
	push	edx
	call	_Buf_Free
	add	esp, 8
	pop	edi

; 1195 :   return res;

	mov	eax, esi
	pop	esi
	pop	ebx

; 1196 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@SzArEx_Ope:
	pop	edi
	pop	esi

; 1146 :       return SZ_ERROR_INPUT_EOF;

	mov	eax, 6
	pop	ebx

; 1196 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@SzArEx_Ope:

; 1138 :     return SZ_ERROR_NO_ARCHIVE;

	mov	eax, 17					; 00000011H
$LN35@SzArEx_Ope:
	pop	edi
	pop	esi
	pop	ebx
$LN23@SzArEx_Ope:

; 1196 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SzArEx_Open2 ENDP
_TEXT	ENDS
PUBLIC	_SzArEx_Open
; Function compile flags: /Ogtp
;	COMDAT _SzArEx_Open
_TEXT	SEGMENT
_p$ = 8							; size = 4
_inStream$ = 12						; size = 4
_allocMain$ = 16					; size = 4
_allocTemp$ = 20					; size = 4
_SzArEx_Open PROC					; COMDAT

; 1199 : {

	push	ebp
	mov	ebp, esp

; 1200 :   SRes res = SzArEx_Open2(p, inStream, allocMain, allocTemp);

	mov	eax, DWORD PTR _inStream$[ebp]
	mov	edx, DWORD PTR _allocTemp$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _allocMain$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _p$[ebp]
	push	eax
	push	edi
	mov	ecx, ebx
	call	_SzArEx_Open2
	mov	esi, eax
	add	esp, 8

; 1201 :   if (res != SZ_OK)

	test	esi, esi
	je	SHORT $LN1@SzArEx_Ope@2

; 1202 :     SzArEx_Free(p, allocMain);

	push	ebx
	push	edi
	call	_SzArEx_Free
	add	esp, 8

; 1203 :   return res;

	mov	eax, esi
$LN1@SzArEx_Ope@2:
	pop	edi
	pop	esi
	pop	ebx

; 1204 : }

	pop	ebp
	ret	0
_SzArEx_Open ENDP
_TEXT	ENDS
END
