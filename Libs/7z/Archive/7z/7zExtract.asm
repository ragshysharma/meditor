; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	H:\MinGW\home\other\meditor2\Libs\7z\Archive\7z\7zExtract.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_SzAr_Extract
EXTRN	@CrcCalc@8:PROC
EXTRN	_SzDecode:PROC
EXTRN	_LookInStream_SeekTo:PROC
EXTRN	_SzArEx_GetFolderStreamPos:PROC
EXTRN	_SzFolder_GetUnpackSize:PROC
; Function compile flags: /Ogtp
; File h:\mingw\home\other\meditor2\libs\7z\archive\7z\7zextract.c
;	COMDAT _SzAr_Extract
_TEXT	SEGMENT
_unpackSizeSpec$80145 = -20				; size = 8
_startOffset$80148 = -12				; size = 8
_folder$80144 = -4					; size = 4
_res$ = 8						; size = 4
_p$ = 8							; size = 4
_inStream$ = 12						; size = 4
_fileIndex$ = 16					; size = 4
_blockIndex$ = 20					; size = 4
_outBuffer$ = 24					; size = 4
_outBufferSize$ = 28					; size = 4
_offset$ = 32						; size = 4
_outSizeProcessed$ = 36					; size = 4
_allocMain$ = 40					; size = 4
_allocTemp$ = 44					; size = 4
_SzAr_Extract PROC					; COMDAT

; 19   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 20   :   UInt32 folderIndex = p->FileIndexToFolderIndexMap[fileIndex];

	mov	ecx, DWORD PTR _fileIndex$[ebp]

; 21   :   SRes res = SZ_OK;
; 22   :   *offset = 0;

	mov	edx, DWORD PTR _offset$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edi+60]
	mov	esi, DWORD PTR [eax+ecx*4]

; 23   :   *outSizeProcessed = 0;

	mov	eax, DWORD PTR _outSizeProcessed$[ebp]
	mov	DWORD PTR [edx], 0
	mov	DWORD PTR _res$[ebp], 0
	mov	DWORD PTR [eax], 0

; 24   :   if (folderIndex == (UInt32)-1)

	cmp	esi, -1
	jne	SHORT $LN19@SzAr_Extra

; 25   :   {
; 26   :     IAlloc_Free(allocMain, *outBuffer);

	mov	esi, DWORD PTR _outBuffer$[ebp]
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR _allocMain$[ebp]
	mov	edx, DWORD PTR [eax+4]
	push	ecx
	push	eax
	call	edx

; 27   :     *blockIndex = folderIndex;

	mov	eax, DWORD PTR _blockIndex$[ebp]

; 28   :     *outBuffer = 0;
; 29   :     *outBufferSize = 0;

	mov	ecx, DWORD PTR _outBufferSize$[ebp]
	add	esp, 8
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [esi], 0
	pop	edi
	mov	DWORD PTR [ecx], 0

; 30   :     return SZ_OK;

	xor	eax, eax
	pop	esi

; 93   : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@SzAr_Extra:

; 31   :   }
; 32   : 
; 33   :   if (*outBuffer == 0 || *blockIndex != folderIndex)

	mov	eax, DWORD PTR _outBuffer$[ebp]
	cmp	DWORD PTR [eax], 0
	push	ebx
	je	SHORT $LN17@SzAr_Extra
	mov	eax, DWORD PTR _blockIndex$[ebp]
	cmp	DWORD PTR [eax], esi
	je	$LN24@SzAr_Extra
$LN17@SzAr_Extra:

; 34   :   {
; 35   :     CSzFolder *folder = p->db.Folders + folderIndex;

	mov	edx, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [esi+esi*4]
	lea	eax, DWORD PTR [edx+ecx*8]

; 36   :     UInt64 unpackSizeSpec = SzFolder_GetUnpackSize(folder);

	push	eax
	mov	DWORD PTR _folder$80144[ebp], eax
	call	_SzFolder_GetUnpackSize

; 37   :     size_t unpackSize = (size_t)unpackSizeSpec;
; 38   :     UInt64 startOffset = SzArEx_GetFolderStreamPos(p, folderIndex, 0);

	push	0
	push	esi
	push	edi
	mov	ebx, eax
	mov	DWORD PTR _unpackSizeSpec$80145[ebp+4], edx
	call	_SzArEx_GetFolderStreamPos
	mov	DWORD PTR _startOffset$80148[ebp], eax
	add	esp, 16					; 00000010H

; 39   : 
; 40   :     if (unpackSize != unpackSizeSpec)

	xor	eax, eax
	mov	DWORD PTR _startOffset$80148[ebp+4], edx
	cmp	ebx, ebx
	jne	SHORT $LN27@SzAr_Extra
	cmp	eax, DWORD PTR _unpackSizeSpec$80145[ebp+4]
	je	SHORT $LN16@SzAr_Extra
$LN27@SzAr_Extra:
	pop	ebx
	pop	edi

; 41   :       return SZ_ERROR_MEM;

	mov	eax, 2
	pop	esi

; 93   : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@SzAr_Extra:

; 42   :     *blockIndex = folderIndex;

	mov	eax, DWORD PTR _blockIndex$[ebp]

; 43   :     IAlloc_Free(allocMain, *outBuffer);

	mov	ecx, DWORD PTR _outBuffer$[ebp]
	mov	DWORD PTR [eax], esi
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _allocMain$[ebp]
	push	edx
	push	eax
	mov	eax, DWORD PTR [eax+4]
	call	eax

; 44   :     *outBuffer = 0;
; 45   :     
; 46   :     RINOK(LookInStream_SeekTo(inStream, startOffset));

	mov	edx, DWORD PTR _startOffset$80148[ebp+4]
	mov	ecx, DWORD PTR _outBuffer$[ebp]
	mov	eax, DWORD PTR _startOffset$80148[ebp]
	push	edx
	mov	DWORD PTR [ecx], 0
	mov	ecx, DWORD PTR _inStream$[ebp]
	push	eax
	push	ecx
	call	_LookInStream_SeekTo
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$LN31@SzAr_Extra

; 47   :     
; 48   :     if (res == SZ_OK)
; 49   :     {
; 50   :       *outBufferSize = unpackSize;

	mov	edx, DWORD PTR _outBufferSize$[ebp]
	mov	DWORD PTR [edx], ebx

; 51   :       if (unpackSize != 0)

	test	ebx, ebx
	je	SHORT $LN28@SzAr_Extra

; 52   :       {
; 53   :         *outBuffer = (Byte *)IAlloc_Alloc(allocMain, unpackSize);

	mov	eax, DWORD PTR _allocMain$[ebp]
	push	ebx
	push	eax
	mov	eax, DWORD PTR [eax]
	call	eax
	mov	ecx, DWORD PTR _outBuffer$[ebp]
	add	esp, 8
	mov	DWORD PTR [ecx], eax

; 54   :         if (*outBuffer == 0)

	test	eax, eax
	jne	SHORT $LN28@SzAr_Extra

; 55   :           res = SZ_ERROR_MEM;

	pop	ebx
	mov	DWORD PTR _res$[ebp], 2

; 89   :       }
; 90   :     }
; 91   :   }
; 92   :   return res;

	mov	eax, DWORD PTR _res$[ebp]
	pop	edi
	pop	esi

; 93   : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@SzAr_Extra:

; 56   :       }
; 57   :       if (res == SZ_OK)
; 58   :       {
; 59   :         res = SzDecode(p->db.PackSizes +
; 60   :           p->FolderStartPackStreamIndex[folderIndex], folder,
; 61   :           inStream, startOffset,
; 62   :           *outBuffer, unpackSize, allocTemp);

	mov	edx, DWORD PTR _allocTemp$[ebp]
	mov	eax, DWORD PTR _outBuffer$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _startOffset$80148[ebp]
	push	edx
	mov	edx, DWORD PTR _startOffset$80148[ebp+4]
	push	ebx
	push	ecx
	mov	ecx, DWORD PTR _inStream$[ebp]
	push	edx
	mov	edx, DWORD PTR _folder$80144[ebp]
	push	eax
	mov	eax, DWORD PTR [edi+48]
	push	ecx
	mov	ecx, DWORD PTR [eax+esi*4]
	push	edx
	mov	edx, DWORD PTR [edi]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	call	_SzDecode
	add	esp, 32					; 00000020H
	mov	DWORD PTR _res$[ebp], eax

; 63   :         if (res == SZ_OK)

	test	eax, eax
	jne	$LN30@SzAr_Extra

; 64   :         {
; 65   :           if (folder->UnpackCRCDefined)

	mov	ecx, DWORD PTR _folder$80144[ebp]
	cmp	DWORD PTR [ecx+28], eax
	je	SHORT $LN29@SzAr_Extra

; 66   :           {
; 67   :             if (CrcCalc(*outBuffer, unpackSize) != folder->UnpackCRC)

	mov	eax, DWORD PTR _outBuffer$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, ebx
	call	@CrcCalc@8
	mov	ecx, DWORD PTR _folder$80144[ebp]
	cmp	eax, DWORD PTR [ecx+32]

; 68   :               res = SZ_ERROR_CRC;
; 69   :           }
; 70   :         }
; 71   :       }
; 72   :     }
; 73   :   }
; 74   :   if (res == SZ_OK)

	jne	SHORT $LN32@SzAr_Extra
$LN29@SzAr_Extra:
	mov	edx, DWORD PTR _offset$[ebp]
	mov	ecx, DWORD PTR _fileIndex$[ebp]
$LN24@SzAr_Extra:

; 75   :   {
; 76   :     UInt32 i;
; 77   :     CSzFileItem *fileItem = p->db.Files + fileIndex;

	mov	ebx, ecx
	shl	ebx, 5
	add	ebx, DWORD PTR [edi+16]

; 78   :     *offset = 0;

	mov	DWORD PTR [edx], 0

; 79   :     for (i = p->FolderStartFileIndex[folderIndex]; i < fileIndex; i++)

	mov	eax, DWORD PTR [edi+56]
	mov	esi, DWORD PTR [eax+esi*4]
	cmp	esi, ecx
	jae	SHORT $LN4@SzAr_Extra

; 75   :   {
; 76   :     UInt32 i;
; 77   :     CSzFileItem *fileItem = p->db.Files + fileIndex;

	mov	eax, esi
	shl	eax, 5
	sub	ecx, esi
	npad	5
$LL6@SzAr_Extra:

; 80   :       *offset += (UInt32)p->db.Files[i].Size;

	mov	esi, DWORD PTR [edi+16]
	mov	esi, DWORD PTR [eax+esi+8]
	add	DWORD PTR [edx], esi
	add	eax, 32					; 00000020H
	dec	ecx
	jne	SHORT $LL6@SzAr_Extra
$LN4@SzAr_Extra:

; 81   :     *outSizeProcessed = (size_t)fileItem->Size;

	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR _outSizeProcessed$[ebp]

; 82   :     if (*offset + *outSizeProcessed > *outBufferSize)

	mov	esi, DWORD PTR _outBufferSize$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+edx]
	cmp	ecx, DWORD PTR [esi]
	jbe	SHORT $LN3@SzAr_Extra

; 83   :       return SZ_ERROR_FAIL;

	pop	ebx
	pop	edi
	mov	eax, 11					; 0000000bH
	pop	esi

; 93   : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@SzAr_Extra:

; 84   :     {
; 85   :       if (fileItem->FileCRCDefined)

	cmp	BYTE PTR [ebx+27], 0
	je	SHORT $LN30@SzAr_Extra

; 86   :       {
; 87   :         if (CrcCalc(*outBuffer + *offset, *outSizeProcessed) != fileItem->FileCRC)

	mov	ecx, DWORD PTR _outBuffer$[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, edx
	mov	edx, eax
	call	@CrcCalc@8
	cmp	eax, DWORD PTR [ebx+20]
	je	SHORT $LN30@SzAr_Extra
$LN32@SzAr_Extra:

; 88   :           res = SZ_ERROR_CRC;

	mov	DWORD PTR _res$[ebp], 3
$LN30@SzAr_Extra:

; 89   :       }
; 90   :     }
; 91   :   }
; 92   :   return res;

	mov	eax, DWORD PTR _res$[ebp]
$LN31@SzAr_Extra:
	pop	ebx
	pop	edi
	pop	esi

; 93   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SzAr_Extract ENDP
_TEXT	ENDS
END
