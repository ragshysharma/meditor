; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	H:\MinGW\home\other\meditor2\Libs\7z\Bcj2.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_outBuf$GSCopy$
PUBLIC	_buf0$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_Bcj2_Decode
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtp
; File h:\mingw\home\other\meditor2\libs\7z\bcj2.c
;	COMDAT _Bcj2_Decode
_TEXT	SEGMENT
_outBuf$GSCopy$ = -548					; size = 4
_buf0$GSCopy$ = -544					; size = 4
_bufferLim$ = -540					; size = 4
_range$ = -536						; size = 4
_buffer$ = -532						; size = 4
_inPos$ = -528						; size = 4
_b$79929 = -521						; size = 1
_p$ = -520						; size = 516
__$ArrayPad$ = -4					; size = 4
_buf0$ = 8						; size = 4
_size0$ = 12						; size = 4
_buf1$ = 16						; size = 4
_size1$ = 20						; size = 4
_buf2$ = 24						; size = 4
_size2$ = 28						; size = 4
_buf3$ = 32						; size = 4
_size3$ = 36						; size = 4
_outBuf$ = 40						; size = 4
_outSize$ = 44						; size = 4
_Bcj2_Decode PROC					; COMDAT

; 39   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 548				; 00000224H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _buf0$[ebp]
	mov	ecx, DWORD PTR _outBuf$[ebp]

; 40   :   CProb p[256 + 2];
; 41   :   SizeT inPos = 0, outPos = 0;

	mov	DWORD PTR _buf0$GSCopy$[ebp], eax
	push	ebx
	push	esi

; 42   : 
; 43   :   const Byte *buffer, *bufferLim;
; 44   :   UInt32 range, code;
; 45   :   Byte prevByte = 0;
; 46   : 
; 47   :   unsigned int i;
; 48   :   for (i = 0; i < sizeof(p) / sizeof(p[0]); i++)
; 49   :     p[i] = kBitModelTotal >> 1;

	mov	eax, 1024				; 00000400H
	movzx	esi, ax
	mov	eax, esi
	push	edi
	mov	DWORD PTR _outBuf$GSCopy$[ebp], ecx
	shl	esi, 16					; 00000010H
	or	eax, esi
	mov	ecx, 129				; 00000081H
	lea	edi, DWORD PTR _p$[ebp]
	rep stosd

; 50   : 
; 51   :   buffer = buf3;

	mov	eax, DWORD PTR _buf3$[ebp]
	mov	ecx, eax

; 52   :   bufferLim = buffer + size3;

	add	eax, DWORD PTR _size3$[ebp]
	xor	edx, edx
	xor	bl, bl
	mov	DWORD PTR _bufferLim$[ebp], eax

; 53   :   RC_INIT2

	xor	edi, edi
	mov	DWORD PTR _inPos$[ebp], edx
	mov	DWORD PTR _range$[ebp], -1
	xor	eax, eax
	npad	6
$LL63@Bcj2_Decod:
	cmp	ecx, DWORD PTR _bufferLim$[ebp]
	je	SHORT $LN41@Bcj2_Decod
	movzx	esi, BYTE PTR [ecx]
	shl	edi, 8
	inc	eax
	or	edi, esi
	inc	ecx
	cmp	eax, 5
	jl	SHORT $LL63@Bcj2_Decod
	mov	DWORD PTR _buffer$[ebp], ecx

; 54   : 
; 55   :   if (outSize == 0)

	cmp	DWORD PTR _outSize$[ebp], edx
	jne	SHORT $LL26@Bcj2_Decod

; 56   :     return SZ_OK;

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 131  :   return (outPos == outSize) ? SZ_OK : SZ_ERROR_DATA;
; 132  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@Bcj2_Decod:
	pop	edi
	pop	esi

; 53   :   RC_INIT2

	mov	eax, 1
	pop	ebx

; 131  :   return (outPos == outSize) ? SZ_OK : SZ_ERROR_DATA;
; 132  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	5
$LL26@Bcj2_Decod:

; 57   : 
; 58   :   for (;;)
; 59   :   {
; 60   :     Byte b;
; 61   :     CProb *prob;
; 62   :     UInt32 bound;
; 63   :     UInt32 ttt;
; 64   : 
; 65   :     SizeT limit = size0 - inPos;

	mov	esi, DWORD PTR _size0$[ebp]

; 66   :     if (outSize - outPos < limit)

	mov	eax, DWORD PTR _outSize$[ebp]
	sub	esi, DWORD PTR _inPos$[ebp]
	sub	eax, edx
	cmp	eax, esi
	jae	SHORT $LN40@Bcj2_Decod

; 67   :       limit = outSize - outPos;

	mov	esi, eax
$LN40@Bcj2_Decod:

; 68   :     while (limit != 0)

	test	esi, esi
	je	SHORT $LN62@Bcj2_Decod
	npad	8
$LL23@Bcj2_Decod:

; 69   :     {
; 70   :       Byte b = buf0[inPos];

	mov	ecx, DWORD PTR _inPos$[ebp]
	mov	eax, DWORD PTR _buf0$GSCopy$[ebp]
	mov	al, BYTE PTR [eax+ecx]

; 71   :       outBuf[outPos++] = b;

	mov	ecx, DWORD PTR _outBuf$GSCopy$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 72   :       if (IsJ(prevByte, b))

	mov	cl, al
	and	cl, 254					; 000000feH
	inc	edx
	cmp	cl, 232					; 000000e8H
	je	SHORT $LN42@Bcj2_Decod
	cmp	bl, 15					; 0000000fH
	jne	SHORT $LN21@Bcj2_Decod
	mov	cl, al
	and	cl, 240					; 000000f0H
	cmp	cl, 128					; 00000080H
	je	SHORT $LN42@Bcj2_Decod
$LN21@Bcj2_Decod:

; 73   :         break;
; 74   :       inPos++;

	inc	DWORD PTR _inPos$[ebp]

; 75   :       prevByte = b;
; 76   :       limit--;

	dec	esi
	mov	bl, al
	jne	SHORT $LL23@Bcj2_Decod
$LN62@Bcj2_Decod:

; 131  :   return (outPos == outSize) ? SZ_OK : SZ_ERROR_DATA;
; 132  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR _outSize$[ebp]
	pop	edi
	setne	al
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@Bcj2_Decod:

; 77   :     }
; 78   : 
; 79   :     if (limit == 0 || outPos == outSize)

	test	esi, esi
	je	SHORT $LN62@Bcj2_Decod
	cmp	edx, DWORD PTR _outSize$[ebp]
	je	SHORT $LN62@Bcj2_Decod

; 80   :       break;
; 81   : 
; 82   :     b = buf0[inPos++];

	mov	ecx, DWORD PTR _inPos$[ebp]
	mov	eax, DWORD PTR _buf0$GSCopy$[ebp]
	mov	al, BYTE PTR [eax+ecx]
	inc	ecx
	mov	BYTE PTR _b$79929[ebp], al
	mov	DWORD PTR _inPos$[ebp], ecx

; 83   : 
; 84   :     if (b == 0xE8)

	cmp	al, 232					; 000000e8H
	jne	SHORT $LN17@Bcj2_Decod

; 85   :       prob = p + prevByte;

	movzx	esi, bl
	lea	esi, DWORD PTR _p$[ebp+esi*2]
	jmp	SHORT $LN14@Bcj2_Decod
$LN17@Bcj2_Decod:

; 86   :     else if (b == 0xE9)
; 87   :       prob = p + 256;

	lea	esi, DWORD PTR _p$[ebp+512]
	cmp	al, 233					; 000000e9H
	je	SHORT $LN14@Bcj2_Decod

; 88   :     else
; 89   :       prob = p + 257;

	lea	esi, DWORD PTR _p$[ebp+514]
$LN14@Bcj2_Decod:

; 90   : 
; 91   :     IF_BIT_0(prob)

	mov	ebx, DWORD PTR _range$[ebp]
	movzx	ecx, WORD PTR [esi]
	mov	eax, ebx
	shr	eax, 11					; 0000000bH
	imul	eax, ecx
	cmp	edi, eax
	jae	SHORT $LN13@Bcj2_Decod

; 92   :     {
; 93   :       UPDATE_0(prob)

	mov	ebx, 2048				; 00000800H
	sub	ebx, ecx
	shr	ebx, 5
	add	ebx, ecx
	mov	DWORD PTR _range$[ebp], eax
	mov	WORD PTR [esi], bx
	cmp	eax, 16777216				; 01000000H
	jae	SHORT $LN12@Bcj2_Decod
	mov	ecx, DWORD PTR _buffer$[ebp]
	cmp	ecx, DWORD PTR _bufferLim$[ebp]
	je	$LN41@Bcj2_Decod
	shl	eax, 8
	mov	DWORD PTR _range$[ebp], eax
	movzx	eax, BYTE PTR [ecx]
	shl	edi, 8
	or	edi, eax
	inc	ecx
	mov	DWORD PTR _buffer$[ebp], ecx
$LN12@Bcj2_Decod:

; 94   :       prevByte = b;

	mov	bl, BYTE PTR _b$79929[ebp]

; 95   :     }
; 96   :     else

	jmp	$LL26@Bcj2_Decod
$LN13@Bcj2_Decod:

; 97   :     {
; 98   :       UInt32 dest;
; 99   :       const Byte *v;
; 100  :       UPDATE_1(prob)

	sub	ebx, eax
	sub	edi, eax
	mov	eax, ecx
	shr	eax, 5
	sub	ecx, eax
	mov	DWORD PTR _range$[ebp], ebx
	mov	WORD PTR [esi], cx
	cmp	ebx, 16777216				; 01000000H
	jae	SHORT $LN61@Bcj2_Decod
	mov	eax, DWORD PTR _buffer$[ebp]
	cmp	eax, DWORD PTR _bufferLim$[ebp]
	je	$LN41@Bcj2_Decod
	movzx	ecx, BYTE PTR [eax]
	shl	edi, 8
	shl	ebx, 8
	or	edi, ecx
	inc	eax
	mov	DWORD PTR _range$[ebp], ebx
	mov	DWORD PTR _buffer$[ebp], eax
$LN61@Bcj2_Decod:

; 101  :       if (b == 0xE8)

	cmp	BYTE PTR _b$79929[ebp], 232		; 000000e8H
	jne	SHORT $LN7@Bcj2_Decod

; 102  :       {
; 103  :         v = buf1;

	mov	ecx, DWORD PTR _buf1$[ebp]

; 104  :         if (size1 < 4)

	mov	esi, 4
	cmp	DWORD PTR _size1$[ebp], esi
	jb	$LN41@Bcj2_Decod

; 105  :           return SZ_ERROR_DATA;
; 106  :         buf1 += 4;

	add	DWORD PTR _buf1$[ebp], esi

; 107  :         size1 -= 4;

	sub	DWORD PTR _size1$[ebp], esi

; 108  :       }
; 109  :       else

	jmp	SHORT $LN5@Bcj2_Decod
$LN7@Bcj2_Decod:

; 110  :       {
; 111  :         v = buf2;

	mov	ecx, DWORD PTR _buf2$[ebp]

; 112  :         if (size2 < 4)

	mov	eax, 4
	cmp	DWORD PTR _size2$[ebp], eax
	jb	$LN41@Bcj2_Decod

; 113  :           return SZ_ERROR_DATA;
; 114  :         buf2 += 4;

	add	DWORD PTR _buf2$[ebp], eax

; 115  :         size2 -= 4;

	sub	DWORD PTR _size2$[ebp], eax
	mov	esi, eax
$LN5@Bcj2_Decod:

; 116  :       }
; 117  :       dest = (((UInt32)v[0] << 24) | ((UInt32)v[1] << 16) |
; 118  :           ((UInt32)v[2] << 8) | ((UInt32)v[3])) - ((UInt32)outPos + 4);

	movzx	eax, BYTE PTR [ecx]
	movzx	ebx, BYTE PTR [ecx+1]
	shl	eax, 8
	or	eax, ebx
	movzx	ebx, BYTE PTR [ecx+2]
	movzx	ecx, BYTE PTR [ecx+3]
	shl	eax, 8
	or	eax, ebx
	shl	eax, 8
	or	eax, ecx
	sub	eax, edx
	sub	eax, esi

; 119  :       outBuf[outPos++] = (Byte)dest;

	mov	esi, DWORD PTR _outBuf$GSCopy$[ebp]
	mov	BYTE PTR [esi+edx], al
	inc	edx

; 120  :       if (outPos == outSize)

	cmp	edx, DWORD PTR _outSize$[ebp]
	je	$LN62@Bcj2_Decod

; 121  :         break;
; 122  :       outBuf[outPos++] = (Byte)(dest >> 8);

	mov	ecx, eax
	shr	ecx, 8
	mov	BYTE PTR [esi+edx], cl
	inc	edx

; 123  :       if (outPos == outSize)

	cmp	edx, DWORD PTR _outSize$[ebp]
	je	$LN62@Bcj2_Decod

; 124  :         break;
; 125  :       outBuf[outPos++] = (Byte)(dest >> 16);

	mov	ecx, eax
	shr	ecx, 16					; 00000010H
	mov	BYTE PTR [esi+edx], cl
	inc	edx

; 126  :       if (outPos == outSize)

	cmp	edx, DWORD PTR _outSize$[ebp]
	je	$LN62@Bcj2_Decod

; 127  :         break;
; 128  :       outBuf[outPos++] = prevByte = (Byte)(dest >> 24);

	shr	eax, 24					; 00000018H
	mov	bl, al
	mov	BYTE PTR [esi+edx], bl
	inc	edx

; 129  :     }
; 130  :   }

	jmp	$LL26@Bcj2_Decod
_Bcj2_Decode ENDP
_TEXT	ENDS
END
