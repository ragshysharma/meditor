; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	H:\MinGW\home\other\meditor2\Libs\7z\7zStream.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_SeqInStream_Read2
; Function compile flags: /Ogtp
; File h:\mingw\home\other\meditor2\libs\7z\7zstream.c
;	COMDAT _SeqInStream_Read2
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_buf$ = 12						; size = 4
_processed$79877 = 16					; size = 4
_size$ = 16						; size = 4
_errorType$ = 20					; size = 4
_SeqInStream_Read2 PROC					; COMDAT

; 9    : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 10   :   while (size != 0)

	mov	esi, DWORD PTR _size$[ebp]
	push	edi
	test	esi, esi
	je	SHORT $LN3@SeqInStrea
	mov	edi, DWORD PTR _stream$[ebp]
	mov	ebx, DWORD PTR _buf$[ebp]
$LL4@SeqInStrea:

; 11   :   {
; 12   :     size_t processed = size;
; 13   :     RINOK(stream->Read(stream, buf, &processed));

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR _processed$79877[ebp]
	push	eax
	push	ebx
	push	edi
	mov	DWORD PTR _processed$79877[ebp], esi
	call	ecx
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@SeqInStrea

; 14   :     if (processed == 0)

	mov	eax, DWORD PTR _processed$79877[ebp]
	test	eax, eax
	je	SHORT $LN9@SeqInStrea

; 16   :     buf = (void *)((Byte *)buf + processed);

	add	ebx, eax

; 17   :     size -= processed;

	sub	esi, eax
	jne	SHORT $LL4@SeqInStrea
$LN3@SeqInStrea:

; 18   :   }
; 19   :   return SZ_OK;

	xor	eax, eax
$LN5@SeqInStrea:
	pop	edi
	pop	esi
	pop	ebx

; 20   : }

	pop	ebp
	ret	0
$LN9@SeqInStrea:

; 15   :       return errorType;

	mov	eax, DWORD PTR _errorType$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 20   : }

	pop	ebp
	ret	0
_SeqInStream_Read2 ENDP
_TEXT	ENDS
PUBLIC	_SeqInStream_Read
; Function compile flags: /Ogtp
;	COMDAT _SeqInStream_Read
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_buf$ = 12						; size = 4
_size$ = 16						; size = 4
_SeqInStream_Read PROC					; COMDAT

; 23   : {

	push	ebp
	mov	ebp, esp

; 24   :   return SeqInStream_Read2(stream, buf, size, SZ_ERROR_INPUT_EOF);

	mov	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _stream$[ebp]
	push	6
	push	eax
	push	ecx
	push	edx
	call	_SeqInStream_Read2
	add	esp, 16					; 00000010H

; 25   : }

	pop	ebp
	ret	0
_SeqInStream_Read ENDP
_TEXT	ENDS
PUBLIC	_SeqInStream_ReadByte
; Function compile flags: /Ogtp
;	COMDAT _SeqInStream_ReadByte
_TEXT	SEGMENT
_processed$ = -4					; size = 4
_stream$ = 8						; size = 4
_buf$ = 12						; size = 4
_SeqInStream_ReadByte PROC				; COMDAT

; 28   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 29   :   size_t processed = 1;
; 30   :   RINOK(stream->Read(stream, buf, &processed));

	mov	ecx, DWORD PTR _buf$[ebp]
	lea	eax, DWORD PTR _processed$[ebp]
	push	eax
	mov	eax, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	eax
	mov	DWORD PTR _processed$[ebp], 1
	call	edx
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@SeqInStrea@2

; 31   :   return (processed == 1) ? SZ_OK : SZ_ERROR_INPUT_EOF;

	mov	eax, DWORD PTR _processed$[ebp]
	dec	eax
	neg	eax
	sbb	eax, eax
	and	eax, 6
$LN2@SeqInStrea@2:

; 32   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SeqInStream_ReadByte ENDP
_TEXT	ENDS
PUBLIC	_LookInStream_SeekTo
; Function compile flags: /Ogtp
;	COMDAT _LookInStream_SeekTo
_TEXT	SEGMENT
_t$ = -8						; size = 8
_stream$ = 8						; size = 4
_offset$ = 12						; size = 8
_LookInStream_SeekTo PROC				; COMDAT

; 35   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 36   :   Int64 t = offset;

	mov	eax, DWORD PTR _offset$[ebp]
	mov	ecx, DWORD PTR _offset$[ebp+4]
	mov	DWORD PTR _t$[ebp], eax

; 37   :   return stream->Seek(stream, &t, SZ_SEEK_SET);

	mov	eax, DWORD PTR _stream$[ebp]
	push	0
	lea	edx, DWORD PTR _t$[ebp]
	push	edx
	push	eax
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _t$[ebp+4], ecx
	call	eax
	add	esp, 12					; 0000000cH

; 38   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_LookInStream_SeekTo ENDP
_TEXT	ENDS
PUBLIC	_LookInStream_LookRead
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT _LookInStream_LookRead
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_buf$ = 12						; size = 4
_lookBuf$ = 16						; size = 4
_size$ = 16						; size = 4
_LookInStream_LookRead PROC				; COMDAT

; 41   : {

	push	ebp
	mov	ebp, esp
	push	edi

; 42   :   void *lookBuf;
; 43   :   if (*size == 0)

	mov	edi, DWORD PTR _size$[ebp]
	cmp	DWORD PTR [edi], 0
	jne	SHORT $LN2@LookInStre

; 44   :     return SZ_OK;

	xor	eax, eax
	pop	edi

; 48   : }

	pop	ebp
	ret	0
$LN2@LookInStre:
	push	esi

; 45   :   RINOK(stream->Look(stream, &lookBuf, size));

	mov	esi, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [esi]
	push	edi
	lea	eax, DWORD PTR _lookBuf$[ebp]
	push	eax
	push	esi
	call	ecx
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@LookInStre

; 46   :   memcpy(buf, lookBuf, *size);

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR _lookBuf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	push	edx
	push	eax
	push	ecx
	call	_memcpy

; 47   :   return stream->Skip(stream, *size);

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [esi+4]
	push	edx
	push	esi
	call	eax
	add	esp, 20					; 00000014H
$LN5@LookInStre:
	pop	esi
	pop	edi

; 48   : }

	pop	ebp
	ret	0
_LookInStream_LookRead ENDP
_TEXT	ENDS
PUBLIC	_LookInStream_Read2
; Function compile flags: /Ogtp
;	COMDAT _LookInStream_Read2
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_buf$ = 12						; size = 4
_processed$79927 = 16					; size = 4
_size$ = 16						; size = 4
_errorType$ = 20					; size = 4
_LookInStream_Read2 PROC				; COMDAT

; 51   : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 52   :   while (size != 0)

	mov	esi, DWORD PTR _size$[ebp]
	push	edi
	test	esi, esi
	je	SHORT $LN3@LookInStre@2
	mov	edi, DWORD PTR _stream$[ebp]
	mov	ebx, DWORD PTR _buf$[ebp]
$LL4@LookInStre@2:

; 53   :   {
; 54   :     size_t processed = size;
; 55   :     RINOK(stream->Read(stream, buf, &processed));

	mov	ecx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR _processed$79927[ebp]
	push	eax
	push	ebx
	push	edi
	mov	DWORD PTR _processed$79927[ebp], esi
	call	ecx
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@LookInStre@2

; 56   :     if (processed == 0)

	mov	eax, DWORD PTR _processed$79927[ebp]
	test	eax, eax
	je	SHORT $LN9@LookInStre@2

; 58   :     buf = (void *)((Byte *)buf + processed);

	add	ebx, eax

; 59   :     size -= processed;

	sub	esi, eax
	jne	SHORT $LL4@LookInStre@2
$LN3@LookInStre@2:

; 60   :   }
; 61   :   return SZ_OK;

	xor	eax, eax
$LN5@LookInStre@2:
	pop	edi
	pop	esi
	pop	ebx

; 62   : }

	pop	ebp
	ret	0
$LN9@LookInStre@2:

; 57   :       return errorType;

	mov	eax, DWORD PTR _errorType$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 62   : }

	pop	ebp
	ret	0
_LookInStream_Read2 ENDP
_TEXT	ENDS
PUBLIC	_LookInStream_Read
; Function compile flags: /Ogtp
;	COMDAT _LookInStream_Read
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_buf$ = 12						; size = 4
_size$ = 16						; size = 4
_LookInStream_Read PROC					; COMDAT

; 65   : {

	push	ebp
	mov	ebp, esp

; 66   :   return LookInStream_Read2(stream, buf, size, SZ_ERROR_INPUT_EOF);

	mov	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _stream$[ebp]
	push	6
	push	eax
	push	ecx
	push	edx
	call	_LookInStream_Read2
	add	esp, 16					; 00000010H

; 67   : }

	pop	ebp
	ret	0
_LookInStream_Read ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _LookToRead_Look_Lookahead
_TEXT	SEGMENT
_size2$ = 8						; size = 4
_pp$ = 8						; size = 4
_buf$ = 12						; size = 4
_size$ = 16						; size = 4
_LookToRead_Look_Lookahead PROC				; COMDAT

; 70   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 71   :   SRes res = SZ_OK;
; 72   :   CLookToRead *p = (CLookToRead *)pp;
; 73   :   size_t size2 = p->size - p->pos;

	mov	esi, DWORD PTR _pp$[ebp]
	mov	ecx, DWORD PTR [esi+24]
	xor	eax, eax
	sub	ecx, DWORD PTR [esi+20]
	push	edi

; 74   :   if (size2 == 0 && *size > 0)

	mov	edi, DWORD PTR _size$[ebp]
	jne	SHORT $LN2@LookToRead
	cmp	DWORD PTR [edi], eax
	jbe	SHORT $LN2@LookToRead

; 75   :   {
; 76   :     p->pos = 0;
; 77   :     size2 = LookToRead_BUF_SIZE;
; 78   :     res = p->realStream->Read(p->realStream, p->buf, &size2);

	lea	ecx, DWORD PTR _size2$[ebp]
	push	ecx
	mov	DWORD PTR [esi+20], eax
	mov	eax, DWORD PTR [esi+16]
	lea	edx, DWORD PTR [esi+28]
	push	edx
	mov	DWORD PTR _size2$[ebp], 16384		; 00004000H
	push	eax
	mov	eax, DWORD PTR [eax]
	call	eax

; 79   :     p->size = size2;

	mov	ecx, DWORD PTR _size2$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+24], ecx
$LN2@LookToRead:

; 80   :   }
; 81   :   if (size2 < *size)

	cmp	ecx, DWORD PTR [edi]
	jae	SHORT $LN1@LookToRead

; 82   :     *size = size2;

	mov	DWORD PTR [edi], ecx
$LN1@LookToRead:

; 83   :   *buf = p->buf + p->pos;

	mov	ecx, DWORD PTR [esi+20]
	lea	edx, DWORD PTR [ecx+esi+28]
	mov	ecx, DWORD PTR _buf$[ebp]
	pop	edi
	mov	DWORD PTR [ecx], edx
	pop	esi

; 84   :   return res;
; 85   : }

	pop	ebp
	ret	0
_LookToRead_Look_Lookahead ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _LookToRead_Look_Exact
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_buf$ = 12						; size = 4
_size$ = 16						; size = 4
_LookToRead_Look_Exact PROC				; COMDAT

; 88   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 89   :   SRes res = SZ_OK;
; 90   :   CLookToRead *p = (CLookToRead *)pp;
; 91   :   size_t size2 = p->size - p->pos;

	mov	esi, DWORD PTR _pp$[ebp]
	mov	ecx, DWORD PTR [esi+24]
	xor	eax, eax
	sub	ecx, DWORD PTR [esi+20]
	push	edi

; 92   :   if (size2 == 0 && *size > 0)

	mov	edi, DWORD PTR _size$[ebp]
	jne	SHORT $LN3@LookToRead@2
	cmp	DWORD PTR [edi], eax
	jbe	SHORT $LN3@LookToRead@2

; 93   :   {
; 94   :     p->pos = 0;

	mov	DWORD PTR [esi+20], eax

; 95   :     if (*size > LookToRead_BUF_SIZE)

	cmp	DWORD PTR [edi], 16384			; 00004000H
	jbe	SHORT $LN2@LookToRead@2

; 96   :       *size = LookToRead_BUF_SIZE;

	mov	DWORD PTR [edi], 16384			; 00004000H
$LN2@LookToRead@2:

; 97   :     res = p->realStream->Read(p->realStream, p->buf, size);

	mov	eax, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [eax]
	push	edi
	lea	ecx, DWORD PTR [esi+28]
	push	ecx
	push	eax
	call	edx

; 98   :     size2 = p->size = *size;

	mov	ecx, DWORD PTR [edi]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+24], ecx
$LN3@LookToRead@2:

; 99   :   }
; 100  :   if (size2 < *size)

	cmp	ecx, DWORD PTR [edi]
	jae	SHORT $LN1@LookToRead@2

; 101  :     *size = size2;

	mov	DWORD PTR [edi], ecx
$LN1@LookToRead@2:

; 102  :   *buf = p->buf + p->pos;

	mov	ecx, DWORD PTR [esi+20]
	lea	edx, DWORD PTR [ecx+esi+28]
	mov	ecx, DWORD PTR _buf$[ebp]
	pop	edi
	mov	DWORD PTR [ecx], edx
	pop	esi

; 103  :   return res;
; 104  : }

	pop	ebp
	ret	0
_LookToRead_Look_Exact ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _LookToRead_Skip
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_offset$ = 12						; size = 4
_LookToRead_Skip PROC					; COMDAT

; 107  : {

	push	ebp
	mov	ebp, esp

; 108  :   CLookToRead *p = (CLookToRead *)pp;
; 109  :   p->pos += offset;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	ecx, DWORD PTR _offset$[ebp]
	add	DWORD PTR [eax+20], ecx

; 110  :   return SZ_OK;

	xor	eax, eax

; 111  : }

	pop	ebp
	ret	0
_LookToRead_Skip ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _LookToRead_Read
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_buf$ = 12						; size = 4
_size$ = 16						; size = 4
_LookToRead_Read PROC					; COMDAT

; 114  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 115  :   CLookToRead *p = (CLookToRead *)pp;
; 116  :   size_t rem = p->size - p->pos;

	mov	edi, DWORD PTR _pp$[ebp]
	mov	ecx, DWORD PTR [edi+20]
	mov	esi, DWORD PTR [edi+24]
	sub	esi, ecx

; 117  :   if (rem == 0)

	jne	SHORT $LN2@LookToRead@3

; 118  :     return p->realStream->Read(p->realStream, buf, size);

	mov	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edi, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [edi]
	push	eax
	push	ecx
	push	edi
	call	edx
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 125  : }

	pop	ebp
	ret	0
$LN2@LookToRead@3:
	push	ebx

; 119  :   if (rem > *size)

	mov	ebx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR [ebx]
	cmp	esi, eax
	jbe	SHORT $LN1@LookToRead@3

; 120  :     rem = *size;

	mov	esi, eax
$LN1@LookToRead@3:

; 121  :   memcpy(buf, p->buf + p->pos, rem);

	lea	eax, DWORD PTR [ecx+edi+28]
	mov	ecx, DWORD PTR _buf$[ebp]
	push	esi
	push	eax
	push	ecx
	call	_memcpy

; 122  :   p->pos += rem;

	add	DWORD PTR [edi+20], esi
	add	esp, 12					; 0000000cH

; 123  :   *size = rem;

	mov	DWORD PTR [ebx], esi
	pop	ebx
	pop	edi

; 124  :   return SZ_OK;

	xor	eax, eax
	pop	esi

; 125  : }

	pop	ebp
	ret	0
_LookToRead_Read ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _LookToRead_Seek
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_pos$ = 12						; size = 4
_origin$ = 16						; size = 4
_LookToRead_Seek PROC					; COMDAT

; 128  : {

	push	ebp
	mov	ebp, esp

; 129  :   CLookToRead *p = (CLookToRead *)pp;
; 130  :   p->pos = p->size = 0;

	mov	eax, DWORD PTR _pp$[ebp]

; 131  :   return p->realStream->Seek(p->realStream, pos, origin);

	mov	edx, DWORD PTR _pos$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	eax, DWORD PTR [eax+16]
	push	ecx
	push	edx
	push	eax
	mov	eax, DWORD PTR [eax+4]
	call	eax
	add	esp, 12					; 0000000cH

; 132  : }

	pop	ebp
	ret	0
_LookToRead_Seek ENDP
_TEXT	ENDS
PUBLIC	_LookToRead_CreateVTable
; Function compile flags: /Ogtp
;	COMDAT _LookToRead_CreateVTable
_TEXT	SEGMENT
_p$ = 8							; size = 4
_lookahead$ = 12					; size = 4
_LookToRead_CreateVTable PROC				; COMDAT

; 135  : {

	push	ebp
	mov	ebp, esp

; 136  :   p->s.Look = lookahead ?
; 137  :       LookToRead_Look_Lookahead :
; 138  :       LookToRead_Look_Exact;

	cmp	DWORD PTR _lookahead$[ebp], 0
	mov	ecx, OFFSET _LookToRead_Look_Lookahead
	jne	SHORT $LN4@LookToRead@4
	mov	ecx, OFFSET _LookToRead_Look_Exact
$LN4@LookToRead@4:
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], ecx

; 139  :   p->s.Skip = LookToRead_Skip;

	mov	DWORD PTR [eax+4], OFFSET _LookToRead_Skip

; 140  :   p->s.Read = LookToRead_Read;

	mov	DWORD PTR [eax+8], OFFSET _LookToRead_Read

; 141  :   p->s.Seek = LookToRead_Seek;

	mov	DWORD PTR [eax+12], OFFSET _LookToRead_Seek

; 142  : }

	pop	ebp
	ret	0
_LookToRead_CreateVTable ENDP
_TEXT	ENDS
PUBLIC	_LookToRead_Init
; Function compile flags: /Ogtp
;	COMDAT _LookToRead_Init
_TEXT	SEGMENT
_p$ = 8							; size = 4
_LookToRead_Init PROC					; COMDAT

; 145  : {

	push	ebp
	mov	ebp, esp

; 146  :   p->pos = p->size = 0;

	mov	eax, DWORD PTR _p$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+20], ecx

; 147  : }

	pop	ebp
	ret	0
_LookToRead_Init ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _SecToLook_Read
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_buf$ = 12						; size = 4
_size$ = 16						; size = 4
_SecToLook_Read PROC					; COMDAT

; 150  : {

	push	ebp
	mov	ebp, esp

; 151  :   CSecToLook *p = (CSecToLook *)pp;
; 152  :   return LookInStream_LookRead(p->realStream, buf, size);

	mov	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _pp$[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	push	ecx
	push	eax
	call	_LookInStream_LookRead
	add	esp, 12					; 0000000cH

; 153  : }

	pop	ebp
	ret	0
_SecToLook_Read ENDP
_TEXT	ENDS
PUBLIC	_SecToLook_CreateVTable
; Function compile flags: /Ogtp
;	COMDAT _SecToLook_CreateVTable
_TEXT	SEGMENT
_p$ = 8							; size = 4
_SecToLook_CreateVTable PROC				; COMDAT

; 156  : {

	push	ebp
	mov	ebp, esp

; 157  :   p->s.Read = SecToLook_Read;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET _SecToLook_Read

; 158  : }

	pop	ebp
	ret	0
_SecToLook_CreateVTable ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _SecToRead_Read
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_buf$ = 12						; size = 4
_size$ = 16						; size = 4
_SecToRead_Read PROC					; COMDAT

; 161  : {

	push	ebp
	mov	ebp, esp

; 162  :   CSecToRead *p = (CSecToRead *)pp;
; 163  :   return p->realStream->Read(p->realStream, buf, size);

	mov	ecx, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _pp$[ebp]
	mov	eax, DWORD PTR [eax+4]
	push	ecx
	push	edx
	push	eax
	mov	eax, DWORD PTR [eax+8]
	call	eax
	add	esp, 12					; 0000000cH

; 164  : }

	pop	ebp
	ret	0
_SecToRead_Read ENDP
_TEXT	ENDS
PUBLIC	_SecToRead_CreateVTable
; Function compile flags: /Ogtp
;	COMDAT _SecToRead_CreateVTable
_TEXT	SEGMENT
_p$ = 8							; size = 4
_SecToRead_CreateVTable PROC				; COMDAT

; 167  : {

	push	ebp
	mov	ebp, esp

; 168  :   p->s.Read = SecToRead_Read;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET _SecToRead_Read

; 169  : }

	pop	ebp
	ret	0
_SecToRead_CreateVTable ENDP
_TEXT	ENDS
END
