; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	H:\MinGW\home\other\meditor2\Libs\7z\Bra86.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_kMaskToAllowedStatus
PUBLIC	_kMaskToBitNumber
CONST	SEGMENT
_kMaskToAllowedStatus DB 01H
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
_kMaskToBitNumber DB 00H
	DB	01H
	DB	02H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
CONST	ENDS
PUBLIC	_x86_Convert
; Function compile flags: /Ogtp
; File h:\mingw\home\other\meditor2\libs\7z\bra86.c
;	COMDAT _x86_Convert
_TEXT	SEGMENT
_limit$79944 = -8					; size = 4
_prevPosT$ = -4						; size = 4
_data$ = 8						; size = 4
_prevMask$ = 12						; size = 4
_size$ = 12						; size = 4
_ip$ = 16						; size = 4
_state$ = 20						; size = 4
_encoding$ = 24						; size = 4
_x86_Convert PROC					; COMDAT

; 12   : {

	push	ebp
	mov	ebp, esp

; 13   :   SizeT bufferPos = 0, prevPosT;
; 14   :   UInt32 prevMask = *state & 0x7;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx]

; 15   :   if (size < 5)

	mov	ecx, DWORD PTR _size$[ebp]
	sub	esp, 8
	xor	eax, eax
	and	edx, 7
	cmp	ecx, 5
	jae	SHORT $LN23@x86_Conver

; 84   :   return bufferPos;
; 85   : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@x86_Conver:

; 16   :     return 0;
; 17   :   ip += 5;

	add	DWORD PTR _ip$[ebp], 5
	push	ebx
	push	esi

; 23   :     Byte *limit = data + size - 4;

	mov	esi, DWORD PTR _data$[ebp]
	lea	ebx, DWORD PTR [esi+ecx-4]
	push	edi
	mov	DWORD PTR _prevPosT$[ebp], -1
	mov	DWORD PTR _limit$79944[ebp], ebx
$LL22@x86_Conver:

; 18   :   prevPosT = (SizeT)0 - 1;
; 19   : 
; 20   :   for (;;)
; 21   :   {
; 22   :     Byte *p = data + bufferPos;

	mov	esi, DWORD PTR _data$[ebp]
	lea	edi, DWORD PTR [eax+esi]

; 24   :     for (; p < limit; p++)

	cmp	edi, ebx
	jae	SHORT $LN34@x86_Conver
	npad	2
$LL20@x86_Conver:

; 25   :       if ((*p & 0xFE) == 0xE8)

	mov	al, BYTE PTR [edi]
	and	al, 254					; 000000feH
	cmp	al, 232					; 000000e8H
	je	SHORT $LN34@x86_Conver

; 24   :     for (; p < limit; p++)

	inc	edi
	cmp	edi, ebx
	jb	SHORT $LL20@x86_Conver
$LN34@x86_Conver:

; 26   :         break;
; 27   :     bufferPos = (SizeT)(p - data);

	mov	eax, edi
	sub	eax, esi

; 28   :     if (p >= limit)
; 29   :       break;
; 30   :     prevPosT = bufferPos - prevPosT;

	mov	ecx, eax
	sub	ecx, DWORD PTR _prevPosT$[ebp]
	cmp	edi, ebx
	jae	$LN37@x86_Conver

; 31   :     if (prevPosT > 3)

	cmp	ecx, 3
	jbe	SHORT $LN15@x86_Conver

; 32   :       prevMask = 0;

	xor	esi, esi
	mov	DWORD PTR _prevMask$[ebp], esi

; 33   :     else

	jmp	SHORT $LN12@x86_Conver
$LN15@x86_Conver:

; 34   :     {
; 35   :       prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;

	dec	ecx
	shl	edx, cl
	and	edx, 7
	mov	DWORD PTR _prevMask$[ebp], edx

; 36   :       if (prevMask != 0)

	je	SHORT $LN39@x86_Conver

; 37   :       {
; 38   :         Byte b = p[4 - kMaskToBitNumber[prevMask]];

	mov	ecx, edx
	movzx	edx, BYTE PTR _kMaskToBitNumber[ecx]
	mov	esi, edi
	sub	esi, edx

; 39   :         if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))

	cmp	BYTE PTR _kMaskToAllowedStatus[ecx], 0
	mov	dl, BYTE PTR [esi+4]
	je	SHORT $LN10@x86_Conver
	test	dl, dl
	je	SHORT $LN10@x86_Conver
	cmp	dl, 255					; 000000ffH
	jne	SHORT $LN39@x86_Conver
$LN10@x86_Conver:

; 40   :         {
; 41   :           prevPosT = bufferPos;
; 42   :           prevMask = ((prevMask << 1) & 0x7) | 1;

	and	ecx, 3
	add	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR _prevPosT$[ebp], eax
	mov	DWORD PTR _prevMask$[ebp], ecx

; 43   :           bufferPos++;

	inc	eax

; 44   :           continue;

	mov	edx, ecx
	jmp	SHORT $LL22@x86_Conver
$LN39@x86_Conver:
	mov	esi, DWORD PTR _prevMask$[ebp]
$LN12@x86_Conver:

; 45   :         }
; 46   :       }
; 47   :     }
; 48   :     prevPosT = bufferPos;
; 49   : 
; 50   :     if (Test86MSByte(p[4]))

	mov	cl, BYTE PTR [edi+4]
	mov	DWORD PTR _prevPosT$[ebp], eax
	test	cl, cl
	je	SHORT $LN8@x86_Conver
	cmp	cl, 255					; 000000ffH
	je	SHORT $LN8@x86_Conver

; 75   :     }
; 76   :     else
; 77   :     {
; 78   :       prevMask = ((prevMask << 1) & 0x7) | 1;

	and	esi, 3
	add	esi, esi
	or	esi, 1
	mov	DWORD PTR _prevMask$[ebp], esi

; 79   :       bufferPos++;

	inc	eax
	mov	edx, esi
	jmp	$LL22@x86_Conver
$LN8@x86_Conver:

; 51   :     {
; 52   :       UInt32 src = ((UInt32)p[4] << 24) | ((UInt32)p[3] << 16) | ((UInt32)p[2] << 8) | ((UInt32)p[1]);

	movzx	edx, cl
	movzx	ecx, BYTE PTR [edi+3]
	shl	edx, 8
	or	edx, ecx
	movzx	ecx, BYTE PTR [edi+2]
	shl	edx, 8
	or	edx, ecx
	movzx	ecx, BYTE PTR [edi+1]
	shl	edx, 8
	or	edx, ecx
	npad	3
$LL7@x86_Conver:

; 53   :       UInt32 dest;
; 54   :       for (;;)
; 55   :       {
; 56   :         Byte b;
; 57   :         int index;
; 58   :         if (encoding)

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN5@x86_Conver

; 59   :           dest = (ip + (UInt32)bufferPos) + src;

	lea	ebx, DWORD PTR [edx+eax]
	add	ebx, DWORD PTR _ip$[ebp]

; 60   :         else

	jmp	SHORT $LN4@x86_Conver
$LN5@x86_Conver:

; 61   :           dest = src - (ip + (UInt32)bufferPos);

	sub	edx, eax
	sub	edx, DWORD PTR _ip$[ebp]
	mov	ebx, edx
$LN4@x86_Conver:

; 62   :         if (prevMask == 0)

	test	esi, esi
	je	SHORT $LN40@x86_Conver

; 63   :           break;
; 64   :         index = kMaskToBitNumber[prevMask] * 8;

	movzx	esi, BYTE PTR _kMaskToBitNumber[esi]
	add	esi, esi
	add	esi, esi
	add	esi, esi

; 65   :         b = (Byte)(dest >> (24 - index));

	mov	ecx, 24					; 00000018H
	sub	ecx, esi
	mov	edx, ebx
	shr	edx, cl
	mov	cl, dl

; 66   :         if (!Test86MSByte(b))

	test	cl, cl
	je	SHORT $LN2@x86_Conver
	cmp	cl, 255					; 000000ffH
	jne	SHORT $LN40@x86_Conver
$LN2@x86_Conver:

; 67   :           break;
; 68   :         src = dest ^ ((1 << (32 - index)) - 1);

	mov	ecx, 32					; 00000020H
	sub	ecx, esi

; 69   :       }

	mov	esi, DWORD PTR _prevMask$[ebp]
	mov	edx, 1
	shl	edx, cl
	dec	edx
	xor	edx, ebx
	jmp	SHORT $LL7@x86_Conver
$LN40@x86_Conver:

; 70   :       p[4] = (Byte)(~(((dest >> 24) & 1) - 1));

	mov	ecx, ebx
	shr	ecx, 24					; 00000018H
	and	cl, 1
	dec	cl
	not	cl
	mov	BYTE PTR [edi+4], cl

; 71   :       p[3] = (Byte)(dest >> 16);

	mov	edx, ebx
	shr	edx, 16					; 00000010H

; 72   :       p[2] = (Byte)(dest >> 8);

	mov	ecx, ebx
	shr	ecx, 8
	mov	BYTE PTR [edi+3], dl
	mov	edx, DWORD PTR _prevMask$[ebp]

; 73   :       p[1] = (Byte)dest;

	mov	BYTE PTR [edi+1], bl
	mov	ebx, DWORD PTR _limit$79944[ebp]
	mov	BYTE PTR [edi+2], cl

; 74   :       bufferPos += 5;

	add	eax, 5
	jmp	$LL22@x86_Conver
$LN37@x86_Conver:
	pop	edi
	pop	esi
	pop	ebx

; 80   :     }
; 81   :   }
; 82   :   prevPosT = bufferPos - prevPosT;
; 83   :   *state = ((prevPosT > 3) ? 0 : ((prevMask << ((int)prevPosT - 1)) & 0x7));

	cmp	ecx, 3
	jbe	SHORT $LN26@x86_Conver
	mov	ecx, DWORD PTR _state$[ebp]
	xor	edx, edx
	mov	DWORD PTR [ecx], edx

; 84   :   return bufferPos;
; 85   : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@x86_Conver:

; 80   :     }
; 81   :   }
; 82   :   prevPosT = bufferPos - prevPosT;
; 83   :   *state = ((prevPosT > 3) ? 0 : ((prevMask << ((int)prevPosT - 1)) & 0x7));

	dec	ecx
	shl	edx, cl
	mov	ecx, DWORD PTR _state$[ebp]
	and	edx, 7
	mov	DWORD PTR [ecx], edx

; 84   :   return bufferPos;
; 85   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_x86_Convert ENDP
_TEXT	ENDS
END
